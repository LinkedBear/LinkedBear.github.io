<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LinkedBear的GitHub</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-08T06:59:59.226Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LinkedBear</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring如何在运行期动态注册新的数据源？</title>
    <link href="http://yoursite.com/2021/05/08/Spring%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%9F/"/>
    <id>http://yoursite.com/2021/05/08/Spring%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%9F/</id>
    <published>2021-05-08T06:57:23.000Z</published>
    <updated>2021-05-08T06:59:59.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2021 年已经过去 1/3 了，阿熊怎么还不写文章呢？</p></blockquote><p>哎，不是不写，是一直在更新着新的 MyBatis 小册嘛，正好这段时间处在换工作的阶段，白天除了找找招聘岗位就是写写小册和文章，相对也清闲一点（但是快要饿死了呀 ~ ）。最近在翻底稿的时候找到了一个之前跟小册交流群的群友讨论的话题，感觉这个主题还不错，所以本篇文章，我们就来研究一下本文标题所述的这个话题：<strong>SpringFramework 如何在运行期动态注册新的数据源？</strong></p><h2 id="需求来源"><a href="#需求来源" class="headerlink" title="需求来源"></a>需求来源</h2><p>这个需求的起源是来自一个 SpringBoot 自动装配的数据源注册，因为一个项目中需要注册的数据源不确定，所以需要在启动时根据配置文件的内容动态注册多个数据源。后来聊着聊着，就演变成运行时动态注册新的数据源了。虽然看上去这两个事情好像差不多，但实际上两件事差了很多哈。</p><ul><li>启动时动态初始化数据源：在基于 SpringFramework / SpringBoot 的应用初始化，也即 IOC 容器初始化时，读取并解析配置文件，构造多个数据源，并注册到 IOC 容器中<ul><li>此时通常情况下 IOC 容器还没有刷新完毕，项目还没有启动完成</li></ul></li><li>运行期动态注册新的数据源：在项目的运行期间，动态的构造数据源，并注册到 Spring 的 IOC 容器中<ul><li>此时项目已经在正常运行中了</li></ul></li></ul><p>前者的处理方式相对比较简单，通过声明一个标注了 <code>@ConfigurationProperties</code> 的类，并用 Map 接收数据源的参数就可以把数据源的定义信息都获取到了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.dynamic"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceProperties</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Map&lt;String, DataSource&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>然后，再编写一个 <code>ImportBeanDefinitionRegistrar</code> ，读取这个 <code>DynamicDataSourceProperties</code> 的内容，就可以把这些数据源都注册到 IOC 容器中。</p><p>但是后者就麻烦了，运行期动态注册新的数据源应该如何实现才行呢？下面我们来通过几个方案，讲解该需求的实现。</p><h2 id="编码环境搭建"><a href="#编码环境搭建" class="headerlink" title="编码环境搭建"></a>编码环境搭建</h2><p>首先，我们先来搭建一下编码环境。</p><h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><p>首先，我们先来创建 3 个不同的数据库（当然也可以只创建一个数据库，这里我们搞的更真实一点吧）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> db3;</span></pre></td></tr></table></figure><p>接下来给每一个数据库中都初始化一张相同的表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_user  (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  tel <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="literal">NULL</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure><p>OK 就这么简单的准备一下就可以了。</p><h3 id="初始代码编写"><a href="#初始代码编写" class="headerlink" title="初始代码编写"></a>初始代码编写</h3><p>为了快速编码，我们仍然采用 SpringBoot 构建项目，直接使用 SpringInitializer 就挺好，当然也可以通过 Maven 构建项目，这里我们就省去那些麻烦的构建步骤了，只把代码贴一下哈。</p><p>项目名称：<strong><code>dynamic-register-datasource</code></strong> 。</p><p><code>pom.xml</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.linkedbear.spring<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-register-datasource<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></pre></td></tr></table></figure><p><code>application.yml</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">datasource:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">db1:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost:3306/db1?characterEncoding=utf8</span> <span class="comment"># 注意这里是jdbc-url而不是url</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">db2:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost:3306/db2?characterEncoding=utf8</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span></pre></td></tr></table></figure><p><code>DataSourceConfiguration</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Primary</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.db1"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">db1</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.db2"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">db2</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>以上的代码，是我们最常见到的 SpringBoot 中定义多个数据源的方法了是吧。</p><h3 id="测试运行一下"><a href="#测试运行一下" class="headerlink" title="测试运行一下"></a>测试运行一下</h3><p>最后编写 SpringBoot 主启动类，在这里我们将启动完成后的 IOC 容器拿到，并从中取出所有的 <code>DataSource</code> ，取一下它们其中的数据库连接 <code>Connection</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicRegisterDataSourceApplication</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        ConfigurableApplicationContext ctx = SpringApplication.run(DynamicRegisterDataSourceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        Map&lt;String, DataSource&gt; dataSourceMap = ctx.getBeansOfType(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, DataSource&gt; entry : dataSourceMap.entrySet()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            String name = entry.getKey();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            DataSource dataSource = entry.getValue();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            System.out.println(name);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            System.out.println(dataSource.getConnection()); <span class="comment">// 这里会抛出异常，直接throws走了</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>运行主启动类，可以在控制台中发现我们已经注册好的两个 <code>DataSource</code> ，以及它们对应的 <code>Connection</code> ：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">db1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">43</span>:<span class="number">14.299</span>  INFO <span class="number">7624</span> --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool<span class="number">-1</span> - Starting...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">43</span>:<span class="number">14.412</span>  INFO <span class="number">7624</span> --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool<span class="number">-1</span> - Start completed.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="symbol">HikariProxyConnection@</span><span class="number">65982709</span> wrapping com.mysql.jdbc.<span class="symbol">JDBC4Connection@</span><span class="number">64030</span>b91</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">db2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">43</span>:<span class="number">14.414</span>  INFO <span class="number">7624</span> --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool<span class="number">-2</span> - Starting...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-15</span> <span class="number">20</span>:<span class="number">43</span>:<span class="number">14.418</span>  INFO <span class="number">7624</span> --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool<span class="number">-2</span> - Start completed.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="symbol">HikariProxyConnection@</span><span class="number">652007616</span> wrapping com.mysql.jdbc.<span class="symbol">JDBC4Connection@</span><span class="number">66e889</span>df</span></pre></td></tr></table></figure><p>到这里，基本的环境和代码都就准备好了。</p><hr><p>下面，我们来讲解两种程序运行期动态注册数据源的解决方案。</p><h2 id="解决方案1：基于BeanDefinition"><a href="#解决方案1：基于BeanDefinition" class="headerlink" title="解决方案1：基于BeanDefinition"></a>解决方案1：基于BeanDefinition</h2><p>如果各位小伙伴有学习过我 Spring 小册的 IOC 高级部分，应该都知道 <strong>bean 的创建来源是 <code>BeanDefinition</code></strong> 吧！通常情况下，我们通过 <code>&lt;bean&gt;</code> 标签、<code>@Bean</code> 注解，或者 <code>@Component</code> 配合 <code>@ComponentScan</code> 注解完成的 bean 注册，都是先封装为一个个的 <code>BeanDefinition</code> ，然后才是根据 <code>BeanDefinition</code> 创建 bean 对象！</p><p>使用 SpringFramework 的 <code>BeanDefinition</code> 元编程，我们可以手动构造一个 <code>BeanDefinition</code> ，并注册到 <code>DefaultListableBeanFactory</code>（ <code>BeanDefinitionRegistry</code> ）中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterDataSourceController</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> DefaultListableBeanFactory beanFactory;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/register1"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register1</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(HikariDataSource<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        builder.addPropertyReference(<span class="string">"driverClassName"</span>, <span class="string">"com.mysql.jdbc.Driver"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        builder.addPropertyReference(<span class="string">"jdbcUrl"</span>, <span class="string">"jdbc:mysql://localhost:3306/db3?characterEncoding=utf8"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        builder.addPropertyReference(<span class="string">"username"</span>, <span class="string">"root"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        builder.addPropertyReference(<span class="string">"password"</span>, <span class="string">"123456"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// builder.setScope(ConfigurableListableBeanFactory.SCOPE_SINGLETON);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        beanFactory.registerBeanDefinition(<span class="string">"db3"</span>, builder.getBeanDefinition());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getDataSources"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDataSources</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        Map&lt;String, DataSource&gt; dataSourceMap = beanFactory.getBeansOfType(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        dataSourceMap.forEach((s, dataSource) -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            System.out.println(s + <span class="string">" ======== "</span> + dataSource);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>如果构造的 <code>DataSource</code> 需要指定作用域等额外的配置，可以操纵 <code>BeanDefinitionBuilder</code> 的 API 进行设置。</p><p>以此法编写好之后，我们可以重启项目测试一下。重启之后先访问 <code>/getDataSources</code> ，可以发现控制台只有两个 <code>DataSource</code> 的打印：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">db1</span> ======== HikariDataSource (HikariPool-<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">db2</span> ======== HikariDataSource (HikariPool-<span class="number">2</span>)</span></pre></td></tr></table></figure><p>然后访问 <code>/register1</code> 路径，之后再访问 <code>/getDataSources</code> ，控制台就可以打印三个 <code>DataSource</code> 了：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">db1</span> ======== HikariDataSource (HikariPool-<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">db2</span> ======== HikariDataSource (HikariPool-<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">db3</span> ======== HikariDataSource (HikariPool-<span class="number">3</span>)</span></pre></td></tr></table></figure><p>这种方法比较简单，比较具有通用性，关键的点是抓住核心知识点：<strong><code>BeanFactory</code> 中的 bean 绝大多数都是通过 <code>BeanDefinition</code> 创建而来</strong>。</p><h2 id="解决方案2：基于SingletonBeanRegistry"><a href="#解决方案2：基于SingletonBeanRegistry" class="headerlink" title="解决方案2：基于SingletonBeanRegistry"></a>解决方案2：基于SingletonBeanRegistry</h2><p>如果需要注册的 bean 都是<strong>单实例 bean</strong> ，而且<strong>不需要经过 AOP 处理</strong>的话，则也可以使用接下来要讲的这种方式，相较于上一种而言，采用这种方法相对会更友好。</p><p>如果小伙伴有看过我的 <a href="https://juejin.cn/book/6857911863016390663/section/6859985939314245635" target="_blank" rel="noopener">Spring 小册第 14 章 <code>BeanFactory</code></a> 章节，应该不会忘记 <code>BeanFactory</code> 在 <code>ApplicationContext</code> 中唯一现役的最终实现是 <strong><code>DefaultListableBeanFactory</code></strong> 吧。那这个实现类，最终是继承了 <code>AbstractBeanFactory</code> ，而它又继承了一个叫 <code>DefaultSingletonBeanRegistry</code> 的类，这个类我们在 Spring 小册的正篇中没有提及，现已经补充到<a href="https://juejin.cn/book/6857911863016390663/section/6919486650951139328" target="_blank" rel="noopener">小册的加餐内容</a>中了，小伙伴们可以戳链接去学习呀。</p><h3 id="简单示例代码"><a href="#简单示例代码" class="headerlink" title="简单示例代码"></a>简单示例代码</h3><p>我们简单的来说哈，<code>DefaultSingletonBeanRegistry</code> 这个类实现了一个 <code>SingletonBeanRegistry</code> 接口，这个接口中定义了一个方法：<strong><code>registerSingleton</code></strong> ，它可以<strong>直接向 IOC 容器注册一个已经完完全全存在的对象，使其成为 IOC 容器中的一个 bean</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span></span>;</span></pre></td></tr></table></figure><p>又因为 <code>DefaultListableBeanFactory</code> 继承自 <code>DefaultSingletonBeanRegistry</code> ，所以借助这个原理之后，实现这个需求就简单的很了。我们只需要拿到 <code>DefaultListableBeanFactory</code> ，之后调用它的 <code>registerSingleton</code> 方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterDataSourceController</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> DefaultListableBeanFactory beanFactory;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getDataSources"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDataSources</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        Map&lt;String, DataSource&gt; dataSourceMap = beanFactory.getBeansOfType(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        dataSourceMap.forEach((s, dataSource) -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            System.out.println(s + <span class="string">" ======== "</span> + dataSource);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/register2"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        HikariDataSource dataSource = <span class="keyword">new</span> HikariDataSource();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/db3?characterEncoding=utf8"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        dataSource.setUsername(<span class="string">"root"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        dataSource.setPassword(<span class="string">"123456"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        dataSource.getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"db3 创建完成！"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        beanFactory.registerSingleton(<span class="string">"db3"</span>, dataSource);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.beanFactory = (DefaultListableBeanFactory) beanFactory;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这样注册好了，IOC 容器中就有这个 db3 的数据源了，我们可以再测试一下。</p><h4 id="测试注册效果"><a href="#测试注册效果" class="headerlink" title="测试注册效果"></a>测试注册效果</h4><p>重启工程，先访问 <code>/getDataSources</code> ，控制台依然是只有两个 <code>DataSource</code> 的打印：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">db1</span> ======== HikariDataSource (HikariPool-<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">db2</span> ======== HikariDataSource (HikariPool-<span class="number">2</span>)</span></pre></td></tr></table></figure><p>然后访问 <code>/register2</code> 路径，控制台可以打印成功 <code>db3 创建完成！</code> ，此时再访问 <code>/getDataSources</code> 路径，控制台也可以打印三个 <code>DataSource</code> 了：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">db1</span> ======== HikariDataSource (HikariPool-<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">db2</span> ======== HikariDataSource (HikariPool-<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">db3</span> ======== HikariDataSource (HikariPool-<span class="number">3</span>)</span></pre></td></tr></table></figure><h3 id="依赖注入？"><a href="#依赖注入？" class="headerlink" title="依赖注入？"></a>依赖注入？</h3><p>上面我们看到的生效，那仅仅是我们拿到 <code>BeanFactory</code> ，或者 <code>ApplicationContext</code> 后主动调用 <code>getBean</code> 系列方法，去获取 IOC 容器的 bean 。但对于那些依赖了 <code>DataSource</code> 的 bean ，这种情况就不好办了：<strong>因为依赖注入的时机是 bean 的初始化阶段，当 bean 创建完成后，没有其他代码的干涉，bean 依赖的那些 bean 就不会变化</strong>。</p><p>听起来有点绕，我们来写一个 Service 类来解释一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceService</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    Map&lt;String, DataSource&gt; dataSourceMap;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printDataSources</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        dataSourceMap.forEach((s, dataSource) -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            System.out.println(s + <span class="string">" ======== "</span> + dataSource);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里我们造了一个 <code>DataSourceService</code> ，并通过注入一整个 <code>Map</code> 的方式，将 IOC 容器中的 <code>DataSource</code> 连带着 bean 的 name 都注入进来。</p><p>然后我们修改一下 Controller ，让它取容器中的 <code>DataSourceService</code> ，打印它里面的 <code>DataSource</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getDataSources"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDataSources</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    DataSourceService dataSourceService = beanFactory.getBean(DataSourceService<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    dataSourceService.printDataSources();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>重启工程，并重复上面的测试效果，这次发现两次打印的结果是一样的：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">db1 ======== HikariDataSource (HikariPool-1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">db2 ======== HikariDataSource (HikariPool-2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">db3 创建完成！</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">db1 ======== HikariDataSource (HikariPool-1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">db2 ======== HikariDataSource (HikariPool-2)</span></pre></td></tr></table></figure><p>这个现象就是上面提到的：<strong>bean 中依赖注入的属性没有被主动干预，则不会发生变化</strong>。</p><p>怎么解决这个问题呢？哎，还是靠 <code>BeanFactory</code> 。</p><p>在  <a href="https://juejin.cn/book/6857911863016390663/section/6859985939314245635" target="_blank" rel="noopener">Spring 小册第 14 章 <code>BeanFactory</code></a> 的 1.4.2 节中我们讲到了有关 <code>AutowireCapableBeanFactory</code> 的一个作用是<strong>框架集成</strong>，它提供了一个 <code>autowireBean</code> 方法，用于给现有的对象进行依赖注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">autowireBean</span><span class="params">(Object existingBean)</span> <span class="keyword">throws</span> BeansException</span>;</span></pre></td></tr></table></figure><p>所以我们可以借助这个特性，在动态注册完 <code>DataSource</code> 后，把 IOC 容器中的 <code>DataSourceService</code> 取出来，让它重新执行一次依赖注入即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/register2"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    HikariDataSource dataSource = <span class="keyword">new</span> HikariDataSource();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/db3?characterEncoding=utf8"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    dataSource.setUsername(<span class="string">"root"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    dataSource.setPassword(<span class="string">"123456"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    dataSource.getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"db3 创建完成！"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    beanFactory.registerSingleton(<span class="string">"db3"</span>, dataSource);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 重新执行依赖注入</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    beanFactory.autowireBean(beanFactory.getBean(DataSourceService<span class="class">.<span class="keyword">class</span>))</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>就这么简单，添加这样一行代码即可。</p><h4 id="再测试"><a href="#再测试" class="headerlink" title="再测试"></a>再测试</h4><p>OK ，重新测试一下效果怎样，重启工程，按照上面的测试过程，先访问 <code>/getDataSources</code> ，再访问 <code>/register2</code> ，然后重新访问 <code>/getDataSources</code> ，这次控制台打印了 <code>DataSourceService</code> 中的 3 个 <code>DataSource</code> 了：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">db1 ======== HikariDataSource (HikariPool-1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">db2 ======== HikariDataSource (HikariPool-2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">db3 创建完成！</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">db1 ======== HikariDataSource (HikariPool-1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">db2 ======== HikariDataSource (HikariPool-2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">db3 ======== HikariDataSource (HikariPool-3)</span></pre></td></tr></table></figure><p>这样依赖注入的问题也就解决了。</p><h4 id="不足？"><a href="#不足？" class="headerlink" title="不足？"></a>不足？</h4><p>虽然上面这样的写法没啥问题，但如果依赖 <code>DataSource</code> 的 bean 太多，那我们一个一个的重新依赖注入，那岂不是太费劲了？有没有更好的方案，能<strong>针对某一种特定的 bean 的类型，当 <code>BeanFactory</code> 动态注册该类型的 bean 时，自动刷新 IOC 容器中依赖了该类型 bean 的 bean</strong> 。这个想法是否能实现呢？</p><h3 id="优化方案：自定义注解-事件监听"><a href="#优化方案：自定义注解-事件监听" class="headerlink" title="优化方案：自定义注解+事件监听"></a>优化方案：自定义注解+事件监听</h3><p>比较可惜，使用普通的套路我们无法比较容易的获取到 IOC 容器中哪些 bean 依赖这些 <code>DataSource</code> ，所以我们可以换一个思路：既然依赖这些 <code>DataSource</code> 的 bean 通常都是我们自己编写的（我们自己的业务场景需要呀），所以我们完全可以给这些 bean 上面添加一个自定义的注解。</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>譬如说，我们给上面的代码中，<code>DataSourceService</code> 的上面添加一个 <code>@RefreshDependency</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RefreshDependency &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshDependency</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceService</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    Map&lt;String, DataSource&gt; dataSourceMap;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个注解的作用，就是标识那些需要 <code>BeanFactory</code> 去执行依赖重注入动作的 bean 。</p><p>接下来，就是每次动态注册完 bean 后，让 <code>BeanFactory</code> 去寻找这些标有 <code>@RefreshDependency</code> 注解的 bean ，并执行依赖重注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/register3"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register3</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    HikariDataSource dataSource = <span class="keyword">new</span> HikariDataSource();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/db3?characterEncoding=utf8"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    dataSource.setUsername(<span class="string">"root"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    dataSource.setPassword(<span class="string">"123456"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    dataSource.getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"db3 创建完成！"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    beanFactory.registerSingleton(<span class="string">"db3"</span>, dataSource);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    Map&lt;String, Object&gt; beansMap = beanFactory.getBeansWithAnnotation(RefreshDependency<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    beansMap.values().forEach(bean -&gt; beanFactory.autowireBean(bean));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>当然，这两行代码虽然不长，但它毕竟是一个可以抽取的逻辑。如果后续我们的代码中还有别的地方也需要动态注册新的 bean 后通知其它 bean 完成依赖重注入，则相同的代码又要再写一次。</p><p>针对这个问题，我们可以继续使用事件驱动的特性来优化。</p><h4 id="事件驱动优化"><a href="#事件驱动优化" class="headerlink" title="事件驱动优化"></a>事件驱动优化</h4><p>既然要用事件驱动，而我们又知道 <code>ApplicationContext</code> 本身也是一个 <code>ApplicationEventPublisher</code> ，它具备发布事件的能力，所以我们这次就不必在 Controller 中注入 <code>BeanFactory</code> 了，而是换用 <code>ApplicationContext</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterDataSourceController</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext ctx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext ctx)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.ctx = (ConfigurableApplicationContext) ctx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><blockquote><p>注意这里要用 <code>ConfigurableApplicationContext</code> 去接收，因为 <code>ApplicationContext</code> 接口并没有继承 <code>SingletonBeanRegistry</code> 接口，<code>ConfigurableApplicationContext</code> 才继承了它。</p></blockquote><p>然后，在注册完 bean 之后，就可以发布一个事件，通过事件机制来触发 bean 的依赖重注入了。我们先来把事件和监听器造出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自ApplicationContextEvent，则可以直接从事件中获取ApplicationContext</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicRegisterEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationContextEvent</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicRegisterEvent</span><span class="params">(ApplicationContext source)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">super</span>(source);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicRegisterListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">DynamicRegisterEvent</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(DynamicRegisterEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        ApplicationContext ctx = event.getApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        AutowireCapableBeanFactory beanFactory = ctx.getAutowireCapableBeanFactory();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        Map&lt;String, Object&gt; beansMap = ctx.getBeansWithAnnotation(RefreshDependency<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        beansMap.values().forEach(beanFactory::autowireBean);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>OK ，把监听器注册到 IOC 容器周，接下来再修改 Controller 中的动态注册 bean 的逻辑，让它注册完 bean 后发布 <code>DynamicRegisterEvent</code> 事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/register3"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register3</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    HikariDataSource dataSource = <span class="keyword">new</span> HikariDataSource();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/db3?characterEncoding=utf8"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    dataSource.setUsername(<span class="string">"root"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    dataSource.setPassword(<span class="string">"123456"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    dataSource.getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"db3 创建完成！"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ctx.getBeanFactory().registerSingleton(<span class="string">"db3"</span>, dataSource);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    ctx.publishEvent(<span class="keyword">new</span> DynamicRegisterEvent(ctx));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这样一切就大功告成了，注册 bean 的逻辑，和依赖重注入的逻辑也都通过事件驱动解耦了。</p><p>重新测试一下，浏览器先后访问 <code>/getDataSources</code> 、<code>/register3</code> 、<code>/getDataSources</code> ，控制台依然可以打印 <code>DataSourceService</code> 中的 3 个 <code>DataSource</code> ：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">db1 ======== HikariDataSource (HikariPool-1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">db2 ======== HikariDataSource (HikariPool-2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">db3 创建完成！</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">db1 ======== HikariDataSource (HikariPool-1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">db2 ======== HikariDataSource (HikariPool-2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">db3 ======== HikariDataSource (HikariPool-3)</span></pre></td></tr></table></figure><p>说明我们的优化方案是没有问题的。</p><p>本文涉及到的所有源码可以从 GitHub 中找到：<a href="https://github.com/LinkedBear/juejin-posts-sources" target="_blank" rel="noopener">https://github.com/LinkedBear/juejin-posts-sources</a></p><p>【都看到这里了，小伙伴们要不要关注点赞一下呀，有 Spring 、SpringBoot 、MyBatis 及相关源码学习需要的可以看我的柯基小册四件套哦（对，是四件套了），学习起来 ~ 奥利给】</p>]]></content>
    
    <summary type="html">
    
      本文的主题：SpringFramework 如何在运行期动态注册新的数据源，分析其中的思路并提供两种解决方案。
    
    </summary>
    
    
      <category term="SpringFramework" scheme="http://yoursite.com/categories/SpringFramework/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>艰难又收获满满的2020</title>
    <link href="http://yoursite.com/2020/12/01/2020%E6%8E%98%E9%87%91%E5%B9%B4%E5%BA%A6%E5%BE%81%E6%96%87/"/>
    <id>http://yoursite.com/2020/12/01/2020%E6%8E%98%E9%87%91%E5%B9%B4%E5%BA%A6%E5%BE%81%E6%96%87/</id>
    <published>2020-12-01T05:57:16.000Z</published>
    <updated>2021-02-01T07:32:18.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="艰难又收获满满的2020"><a href="#艰难又收获满满的2020" class="headerlink" title="艰难又收获满满的2020"></a>艰难又收获满满的2020</h1><blockquote><p>伙计们，这一年过得都好吗？</p></blockquote><p>2020 年是很艰难的一年，是不寻常的一年，这一年大家都很难，很多在年初立下的 flag 都因为这场疫情而不得不作出改变，不过话又说回来，疫情的影响又带来了一些新的机遇，不少小伙伴也趁此机会谋求了更好的工作。总的来看，这一年既有挑战，也有机会。借此机会，我也来写一写我的 2020 ，我这一年的经历。</p><blockquote><p>加班加点肝小册之余，与小伙伴们分享这一年的经历，希望小伙伴们能多多给阿熊点赞呀  Ｏ(≧▽≦)Ｏ  期待与小伙伴的交流。</p></blockquote><h3 id="小册写作"><a href="#小册写作" class="headerlink" title="小册写作"></a>小册写作</h3><p>如果你要问我这一年最大的精力都放在哪里，那毫无疑问是掘金的两本小册了。继 2019 年 11 月 <a href="https://juejin.cn/book/6844733814560784397" target="_blank" rel="noopener">《SpringBoot 源码解读与原理分析》</a>小册发布之后，2020 年 6 月，第二本小册<a href="https://juejin.cn/book/6844733831069564941" target="_blank" rel="noopener">《SpringCloudNetflix 源码解读与原理分析》</a>，以及 9 月的第三本小册<a href="https://juejin.cn/book/6857911863016390663" target="_blank" rel="noopener">《从 0 开始深入学习 Spring 》</a>也都陆续发布，而且目前 Spring 小册还在继续连载更新中。</p><p><img src="/2020/12/01/2020%E6%8E%98%E9%87%91%E5%B9%B4%E5%BA%A6%E5%BE%81%E6%96%87/%E5%B0%8F%E5%86%8C%E6%88%AA%E5%9B%BE.png" alt></p><p>回想 19 年的那个秋天，当时写第一本小册的动机，可能还是单纯的觉得，完成一本成体系的、有深度的付费读物，就已经是一个不错的目标了。直到今年第二本小册，也就是 SpringCloudNetflix 的小册发布之后，越来越多的小伙伴反映没有 SpringFramework 的坚实的基础，阅读源码和原理级别的东西真的蛮吃力，我就下定决心，准备在下半年策划写一本回归 SpringFramework 基础到深入的小册。这时的我已经不再是单纯的为了写作而写作了，更多的是抱着如何能让更多的小伙伴，能<strong>更容易、更完整、更深入、成体系</strong>的学习一个框架技术，而且尽可能的让小伙伴能追根溯源的了解技术的演变，以及最终在实际开发中的落地，最后才是深入底层、剖析原理。</p><p>我想，以这种思路与大家分享技术，应该会学起来更加轻松吧。果不其然，在 Spring 小册发布后的不到一周，在第三章 <a href="https://juejin.cn/book/6857911863016390663/section/6857750666513743883" target="_blank" rel="noopener">入门-IOC是怎么来的</a> 的底部就已经得到了大量的积极反馈，而且还有不少小伙伴主动地在下面分享自己的思考和总结，整个氛围都非常的积极。由此我也更加坚定了这个思路，之后的文章更新也是完全按照<strong>从基础，到进阶，再到高级，最后深入原理底层</strong>，尽可能地既覆盖足够大的广度，又能让小伙伴们学到足够的深度。目前来看，IOC 和 AOP 的内容也都全部更新完毕了，在计划中，<strong>12 月 31 日之前，Spring 小册的所有正篇内容都会如期更新完毕</strong>。</p><p>当然，Spring 的小册也不会因为正篇更新完毕而完结，通过这几个月与小册交流群里的小伙伴沟通交流，发现有一些知识点或者问题，对于部分小伙伴来讲还是蛮有兴趣或者存在疑惑的，所以我打算在正篇更新完毕后，会根据小伙伴的反馈，在小册的最后<strong>追加</strong>几篇<strong>加餐</strong>内容，以尽可能多的帮助到小伙伴，解答你们的疑惑，拓宽大家的知识范围。</p><h3 id="B站直播"><a href="#B站直播" class="headerlink" title="B站直播"></a>B站直播</h3><p>2020 年 10 月 15 日，有幸受掘金官方的邀请，本人在 B 站以掘金技术社区的主讲人身份，跟小伙伴们分享了一些有关 Spring 方面的技术和学习思路，包括一些常见的 Spring 相关的面试题。这也是我本人第一次参与线上的直播技术分享，总的来说还算挺成功的，小伙伴们反响也不错，小册姐也有夸，说到底还是很荣幸参与的啦。</p><p><img src="/2020/12/01/2020%E6%8E%98%E9%87%91%E5%B9%B4%E5%BA%A6%E5%BE%81%E6%96%87/%E7%9B%B4%E6%92%AD%E5%B0%81%E9%9D%A2.png" alt></p><p>当时直播的时候人还蛮多的，不少买过我小册的小伙伴都去捧场了，还有几位在小册交流群的小伙伴抽到了掘金官方的缸子、保温杯等周边，我也只能表示实名羡慕啦 o(￣▽￣)ｄ  。如果小伙伴对那一次的直播还蛮有兴趣，或者当时没有来得及上车，可以戳链接去看直播回放： <a href="https://juejin.cn/post/6884752295637024781" target="_blank" rel="noopener">Spring漫漫深耕路 - 记在掘金的第一次直播</a> 。</p><p>当然，这一次直播并不是终点，我自己也在策划着如何更近距离、更有效的与小伙伴们沟通交流，之前也有考虑设计过，<strong>针对小册的某些复杂或者困难的章节辅以直播 / 视频讲解</strong>，这些设想我一直都有保留，只不过当下最重要的，是把 Spring 的小册更新完结，明年吧，明年一定会把这些设想都落实到位的，小伙伴们等我 ~ </p><h3 id="社区日常"><a href="#社区日常" class="headerlink" title="社区日常"></a>社区日常</h3><p>除了上班时间之外，我的空余时间大部分都放在技术研究，和小册的写作上了。当然这其中少不了我与读者伙伴们的沟通交流。就目前而言，比较活跃的群有 SpringBoot 的群，和两个 Spring 小册的群，我也经常出没在这两个群里。（对，我一点也不高冷 ~ ）</p><p><img src="/2020/12/01/2020%E6%8E%98%E9%87%91%E5%B9%B4%E5%BA%A6%E5%BE%81%E6%96%87/%E7%BE%A4%E6%88%AA%E5%9B%BE.png" alt></p><p>日常情况我都会没事点开群里看看小伙伴们都在聊什么，感兴趣的还会掺和两句进去；当然，要是遇到有小伙伴问 Spring 相关的问题，我都会尽可能快速及时的响应并给予解答。这里面不乏有一些跟我聊得很熟的小伙伴：<strong>琛羽千遇 、Mtc 、皮皮柒 、唯有大骨熬成汤 、南岩 、Seirios 、Y 、小橙子 、阿甘</strong> ，等等等等（人太多了没办法在短时间一一喊出各位的名字），他们都是本身小册学习就特别积极，也特别优秀，而且在群里也是超级活跃的，我很荣幸能有你们这些优秀的读者伙伴，当然支持小册的小伙伴都是很优秀的伙伴啦 ヽ(￣▽￣)ﾉ ，感谢你们对阿熊的支持和认可，阿熊也会一如既往用高质量的知识分享陪伴大家的。</p><h3 id="展望2021"><a href="#展望2021" class="headerlink" title="展望2021"></a>展望2021</h3><p>最后再聊一下明年的计划吧，照目前看来，2021 年的安排主要<strong>以写作为主，直播 / 视频为辅</strong>。</p><h5 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h5><p>今年小册完结之后，明年暂时没有新小册开坑的计划，而是考虑<strong>将 《SpringBoot 源码解读与原理分析》重新整理并发行实体书</strong>。经过一年多的时间考验，以及在小册交流群里与小伙伴们的交流，我大概清楚了深入学习 SpringBoot 深层次原理的思路，并且会将这些思路，加上目前 Spring 小册中的部分核心知识，重新整合进接下来要写的实体书中，相信接下来新出的 SpringBoot 原理分析实体书会帮助小伙伴们更好地理解、学习 SpringBoot 、SpringFramework 中的核心知识点，以及它们的特性。小伙伴们敬请期待吧！</p><h5 id="直播-视频"><a href="#直播-视频" class="headerlink" title="直播/视频"></a>直播/视频</h5><p>前面也说了，现在的三本小册中肯定存在一些小伙伴们比较难理解的、讨论度高的问题，我会把这些问题收集好，单独摘出来，以直播 Q&amp;A 或者视频讲解的方式来解答这些问题，至于承载的媒介，我暂时还没想好用哪些平台，小伙伴们也可以多多给我提建议呀！期待能与小伙伴的交流！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2020 是艰难的，但也是收获满满的，我收获了小册的产出和反馈，更收获了支持小册支持阿熊的你们。2021 ，阿熊会继续前行，同小伙伴们一起进步一起成长。</p><p>相信未来美好的事情即将发生，相信一切都会变得更好，你也是。</p>]]></content>
    
    <summary type="html">
    
      2020 年是很艰难的一年，我也来写一写我的 2020 ，我这一年的经历。
    
    </summary>
    
    
      <category term="掘金日记" scheme="http://yoursite.com/categories/%E6%8E%98%E9%87%91%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="2020" scheme="http://yoursite.com/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>记【在掘金的第一次直播】</title>
    <link href="http://yoursite.com/2020/10/18/%E8%AE%B0%E3%80%90%E5%9C%A8%E6%8E%98%E9%87%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B4%E6%92%AD%E3%80%91/"/>
    <id>http://yoursite.com/2020/10/18/%E8%AE%B0%E3%80%90%E5%9C%A8%E6%8E%98%E9%87%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B4%E6%92%AD%E3%80%91/</id>
    <published>2020-10-18T00:30:00.000Z</published>
    <updated>2020-10-31T09:29:12.971Z</updated>
    
    <content type="html"><![CDATA[<p>2020年10月15日，本人有幸参与了掘金技术社区的一次直播活动，作为主讲人与小伙伴们分享了一些关于 Spring 方面的内容。这次分享的内容以概述为主，主要帮小伙伴们理清楚学习 Spring 的思路，以及学完 Spring 框架之后的进一步规划。</p><p>写这篇文章，主要是记录一下当天分享的内容，以及一些后续的复盘等等，帮助没有赶上车的小伙伴们。</p><p>【B站直播回放：<a href="https://www.bilibili.com/video/BV13i4y177ZW" target="_blank" rel="noopener">https://www.bilibili.com/video/BV13i4y177ZW</a>】</p><h2 id="Java开发生态中，Spring究竟有多重要"><a href="#Java开发生态中，Spring究竟有多重要" class="headerlink" title="Java开发生态中，Spring究竟有多重要"></a>Java开发生态中，Spring究竟有多重要</h2><p>既然是聊 Spring ，那咱还是要知道它的地位和分量。Spring 的地位想必都已经到 2020 年了，小伙伴们都非常的清楚。</p><h4 id="Spring使Java变得简单"><a href="#Spring使Java变得简单" class="headerlink" title="Spring使Java变得简单"></a>Spring使Java变得简单</h4><p>在 Spring 的官方网站 <a href="https://spring.io" target="_blank" rel="noopener">https://spring.io</a> 中，一上来我们看到的就是 Spring 官方对 Spring 的描述：</p><blockquote><p>Spring makes Java <strong>simple.modern.productive.reactive.cloud-ready.</strong></p><p>Spring 使 Java 开发变得简单、现代化，并且可以编写生产级别的应用、响应式的应用，并且也支持云应用。</p></blockquote><p>包括下面主页上也列出了 Spring 可以做的内容：</p><p><img src="/2020/10/18/%E8%AE%B0%E3%80%90%E5%9C%A8%E6%8E%98%E9%87%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B4%E6%92%AD%E3%80%91/Snipaste_2020-10-17_09-49-54.png" alt></p><p>可见，Spring 代表的不仅仅是一个框架 / 一个技术，而是一整个生态。</p><h4 id="Spring是一个生态"><a href="#Spring是一个生态" class="headerlink" title="Spring是一个生态"></a>Spring是一个生态</h4><p>翻开 Spring 官网的工程概览 <a href="https://spring.io/projects" target="_blank" rel="noopener">https://spring.io/projects</a> ，我们会发现里面的工程实在是好多好多呀！</p><p>最顶部的两个代表之作，分别是现阶段最最流行的后端服务搭建基本框架 SpringBoot ，以及它的基底 SpringFramework ：</p><p><img src="/2020/10/18/%E8%AE%B0%E3%80%90%E5%9C%A8%E6%8E%98%E9%87%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B4%E6%92%AD%E3%80%91/Snipaste_2020-10-17_10-15-58.png" alt></p><p>往下看，还有关于<strong>数据访问层的 SpringData</strong> 、用于<strong>解决微服务开发的整体解决方案 SpringCloud</strong> 、用于<strong>解决权限安全方面的 SpringSecurity</strong> 、用于<strong>解决 Session 外置的 SpringSession</strong> 等等，这些都是 Spring 生态中的一个个解决方案。</p><h4 id="Spring的使用范围极广"><a href="#Spring的使用范围极广" class="headerlink" title="Spring的使用范围极广"></a>Spring的使用范围极广</h4><p>如果只是人家官方自己吹，那说服力很明显不是很足，咱看看主流的比较受欢迎的开源项目，它们都用了什么底层框架。</p><p>翻开码云的开源项目 <a href="https://gitee.com/explore/backend?lang=Java" target="_blank" rel="noopener">https://gitee.com/explore/backend?lang=Java</a> ，观察这些比较受欢迎的后台管理系统都是用什么搭建的：</p><p><img src="/2020/10/18/%E8%AE%B0%E3%80%90%E5%9C%A8%E6%8E%98%E9%87%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B4%E6%92%AD%E3%80%91/Snipaste_2020-10-17_10-41-45.png" alt></p><p>可见这些开源项目都是基于 Spring / SpringBoot 搭建的！这足够有说服力了吧，连这些主流的、受欢迎的项目都是用 Spring 搭建的，那就足以说明 Spring 真的足够的强大了。</p><h4 id="Spring是面试常客"><a href="#Spring是面试常客" class="headerlink" title="Spring是面试常客"></a>Spring是面试常客</h4><p>最后一个点是关于面试，一直以来面试中就容易问到 Spring 这个框架，而且近年来难度有上升趋势，小伙伴们看以下几个问题都能回答多少呢：</p><ul><li>如何理解 Spring 中的 IOC ？</li><li>Bean 的生命周期包括哪些阶段？</li><li>Spring 如何处理循环依赖？</li><li>Spring 的事务在什么情况下会失效？</li><li>DispatcherServlet 的工作流程？</li></ul><p>这些问题，在 Spring 的小册，以及 SpringBoot 的小册中，都有相应的解答，小册总结的面试题很多，如果小伙伴们有在准备面试的话，小册会是你备战的一个坚实的依靠。</p><h2 id="如何才能全方面的掌握Spring"><a href="#如何才能全方面的掌握Spring" class="headerlink" title="如何才能全方面的掌握Spring"></a>如何才能全方面的掌握Spring</h2><p>那既然 Spring 如此的重要，我们应该如何全方面的去学习、掌握 Spring 这个框架呢？</p><p>简单的来讲，我们可以分为 4 个部分来学习：</p><p><img src="/2020/10/18/%E8%AE%B0%E3%80%90%E5%9C%A8%E6%8E%98%E9%87%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B4%E6%92%AD%E3%80%91/Snipaste_2020-10-17_13-14-50.png" alt></p><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><p>IOC 的部分是整个 Spring 框架最强大，同时也是最复杂的部分，这里面包含的知识点实在是太多了，咱可以简单地罗列一下：</p><ul><li>IOC 的思想及实现方式<ul><li>IOC 的两种实现方式分别是依赖查找、依赖注入</li><li>如何实现依赖查找、依赖注入，都有哪些编码实现的方式</li></ul></li><li>Bean 的注册、创建、装配等<ul><li>Bean 的类型、作用域</li><li>Bean 的创建方式、装配方式</li><li>组件扫描</li></ul></li><li>Bean 与 BeanDefinition <ul><li>Bean 的定义是如何设计的</li><li>BeanDefinition 如何与 IOC 容器配合创建 bean 实例</li></ul></li><li>事件驱动、资源管理、后置处理器</li><li>Bean 、IOC 容器的生命周期</li><li>……</li></ul><p>这些知识点，在 《从 0 开始深入学习 Spring》的小册中，全部都会讲到，而且难度都是逐层递进的，包括其中涉及到的面试题总结等等。</p><h4 id="AOP-amp-事务"><a href="#AOP-amp-事务" class="headerlink" title="AOP&amp;事务"></a>AOP&amp;事务</h4><p>Spring 的两大核心，除了 IOC 之外，另外一个就是 AOP 了。咱都知道 AOP 的核心底层实现是动态代理，那它是怎么实现的，如何编写 AOP 的切面；以及 Spring 中对于 AOP 的一个实现：事务管理，它又是怎么使用的，如何编程式 / 声明式 / 配置式的添加事务，以及它的底层如何实现事务控制，这都是在 AOP 和事务部分要学习的。</p><p>这个部分的内容大概可以划分为如下内容：</p><ul><li>AOP 与动态代理<ul><li>jdk / Cglib</li></ul></li><li>AOP 的实现、应用<ul><li>日志打印</li><li>权限拦截</li></ul></li><li>事务管理<ul><li>编程式 / 声明式 / 配置式添加事务</li><li>事务传播行为</li></ul></li><li>AOP &amp; 事务控制底层核心<ul><li>AOP 如何创建代理对象</li><li>事务管理器如何控制开启 / 提交 / 回滚事务</li></ul></li></ul><h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h4><p>大多数人都喜欢把 Spring 跟 SpringMVC 分开来说，但确切的说，SpringMVC 是 Spring 框架的一部分，并且自打 Spring 5 出现之后，SpringMVC 多了一个孪生兄弟 SpringWebFlux ，所以 SpringMVC 也被称为 SpringWebMvc 了。</p><p>同样的，Web 模块中 Spring 也是重拳出击，这部分内容主要围绕以下的一些关键知识点来学习：</p><ul><li>Spring 整合 Web 工程</li><li>SpringWebMvc <ul><li>控制器的编写与使用</li><li>参数绑定</li><li>数据校验</li><li>国际化</li><li>拦截器</li></ul></li><li>WebMvc 中的核心组件工作机制、流程、原理<ul><li>DispatcherServlet</li><li>HandlerMapping</li><li>HandlerAdapter</li><li>ViewResolver</li><li>……</li></ul></li></ul><blockquote><p>SpringWebFlux 因为用的人还很少，而且理解的难度相对很大，所以这里我们只是提一下，如果小伙伴已经熟练掌握了 SpringWebMvc ，那可以试着学习一下 WebFlux 的东西。</p></blockquote><h4 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h4><p>如果只是因为 Spring 这个框架本身强大的话，还不足以在整个 JavaWeb 的开发界独占鳌头，它优秀且强大的整合第三方技术的能力绝对是不可或缺的一部分。通常来讲我们接触的比较多的、比较知名的技术，几乎都与 Spring 框架进行了整合。</p><p>这里面不乏包含咱熟悉的技术：</p><ul><li>数据持久层框架：MyBatis 、Hibernate</li><li>缓存中间件：Redis 、MongoDB</li><li>消息中间件：RabbitMQ 、Kafka</li><li>搜索引擎：ElasticSearch 、Solr</li><li>……</li></ul><p>学习这些技术的时候，一定要记得顺便学习它与 Spring 的整合。</p><h4 id="学习的思路"><a href="#学习的思路" class="headerlink" title="学习的思路"></a>学习的思路</h4><p>对于 Spring 框架的学习，作者可以提供两种思路：</p><h5 id="水平式学习"><a href="#水平式学习" class="headerlink" title="水平式学习"></a>水平式学习</h5><ul><li>第一阶段<ul><li>先学习 Spring 中 IOC 部分相关的基础内容<ul><li>包括 IOC 的实现方式，依赖注入的方式</li><li>Bean 的类型、作用域、创建方式、生命周期控制等等</li></ul></li><li>然后学习 AOP 部分的基础内容<ul><li>复习一下动态代理</li><li>学习 xml / 注解的方式编写 AOP 的切面等等</li></ul></li><li>接下来是事务部分的基础<ul><li>Spring 如何整合 jdbc </li><li>JdbcTemplate 的使用</li><li>如何使用编程式事务、声明式事务</li></ul></li><li>最后学习 SpringWebMvc 的一些基础<ul><li>包括控制器的编写、参数绑定、响应 json 、拦截器等等</li></ul></li><li>等这些基础部分学习完毕后，基本上 Spring 的基础知识你就都掌握了，这些知识可以应对大部分的实际编码场景</li></ul></li><li>后续阶段<ul><li>依次学习 IOC 、AOP 、事务 、Web 等模块的进阶、高级知识</li><li>这种层层递进的方式，可以称其为 <strong>“水平式学习”</strong></li></ul></li></ul><p><img src="/2020/10/18/%E8%AE%B0%E3%80%90%E5%9C%A8%E6%8E%98%E9%87%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B4%E6%92%AD%E3%80%91/%E6%B0%B4%E5%B9%B3%E5%BC%8F%E5%AD%A6%E4%B9%A0.gif" alt></p><h5 id="垂直式学习"><a href="#垂直式学习" class="headerlink" title="垂直式学习"></a>垂直式学习</h5><ul><li>第一阶段<ul><li>还是先学习 IOC 相关的基础知识<ul><li>IOC 的实现方式，依赖注入的方式</li><li>Bean 的类型、作用域、创建方式、生命周期控制等等</li></ul></li><li>然后，继续学习 IOC 部分的进阶知识<ul><li>包括 IOC 容器的设计、思想</li><li>Bean 的装配、组件扫描</li><li>事件驱动</li><li>资源管理、资源文件等等</li></ul></li><li>接下来继续学习 IOC 部分的高级内容<ul><li>Bean 、BeanDefinition</li><li>BeanFactory 、BeanDefinitionRegistry</li><li>后置处理器</li><li>深入底层等</li></ul></li><li>这个阶段学习完成之后，可以说，整个 Spring 的 IOC 模块核心知识点，你基本上已经全部掌握了</li></ul></li><li>后续阶段<ul><li>按照这个顺序继续学习 AOP 、事务 、Web 模块的各个层级的知识</li><li>这种分模块学习，每个模块都是由浅入深的学习思路，可以称其为 <strong>“垂直式学习”</strong></li></ul></li></ul><p><img src="/2020/10/18/%E8%AE%B0%E3%80%90%E5%9C%A8%E6%8E%98%E9%87%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B4%E6%92%AD%E3%80%91/%E5%9E%82%E7%9B%B4%E5%BC%8F%E5%AD%A6%E4%B9%A0.gif" alt></p><p>两种方法思路任选其一，根据自己的学习风格、思维和习惯来就好。</p><blockquote><p>不止是学习 Spring ，学习其它框架 / 技术时，这两种思路同样适用。</p></blockquote><h2 id="掌握Spring之后如何作中长期规划"><a href="#掌握Spring之后如何作中长期规划" class="headerlink" title="掌握Spring之后如何作中长期规划"></a>掌握Spring之后如何作中长期规划</h2><p>Spring 框架学习完毕之后，接下来的规划也是至关重要的。明确自己目前所处的位置，并针对自己的情况制定中长期的规划，对自己的整个职业生涯的重要性不言而喻。作者在此也只是提一些导向性的建议，帮助小伙伴们理清自己。</p><ul><li>如果 Spring 是你的第一个学习的框架 / 刚学完 SSM<ul><li>那么接下来你最好先停下来，把这部分的知识巩固住，并且找一个实际的项目 / 需求做一下，体会一下项目开发的感觉，顺便这个期间你的基础知识也就能得到巩固了</li></ul></li><li>如果 Spring 框架本身已经掌握的不错了<ul><li>后续的计划可以围绕着 Spring 的生态展开，SpringBoot 是一个非常好的选择，因为 SpringBoot 是完全构建于 Spring 框架之上，它充分利用了 Spring 底层设计的机制，也扩展了一些新的机制（如自动装配、新的后置处理器等）</li></ul></li><li>如果 Spring 和 SpringBoot 都基本掌握了<ul><li>那么中长期的规划可以从两种路线出发</li><li>要么，继续进攻 SpringCloud 微服务解决方案，了解和实践微服务开发</li><li>要么，研究学习主流的开源中间件（Redis 、RabbitMQ 、ElasticSearch 等），扩充技术栈的广度</li></ul></li></ul><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h4 id="还没毕业的同学，实习之前需要掌握SpringCloud吗"><a href="#还没毕业的同学，实习之前需要掌握SpringCloud吗" class="headerlink" title="还没毕业的同学，实习之前需要掌握SpringCloud吗"></a>还没毕业的同学，实习之前需要掌握SpringCloud吗</h4><p>回答：不需要。</p><p>原因：对于初入职场的小伙伴，公司更看重的是你的基本功，基本功扎实，想必可塑性都不会差。所以，尽可能的让你的基础知识掌握得更牢靠吧（JavaSE 、JavaWeb 、基本的框架等）。</p><h4 id="AOP在哪些场景下会失效"><a href="#AOP在哪些场景下会失效" class="headerlink" title="AOP在哪些场景下会失效"></a>AOP在哪些场景下会失效</h4><p>回答：一般发生在后置处理器的初始化阶段。</p><p>原理：可参照小册第 34 章和第 48 章（后续更新）。</p><h4 id="JavaSE的源码阅读起来有些吃力，有什么好办法吗"><a href="#JavaSE的源码阅读起来有些吃力，有什么好办法吗" class="headerlink" title="JavaSE的源码阅读起来有些吃力，有什么好办法吗"></a>JavaSE的源码阅读起来有些吃力，有什么好办法吗</h4><p>回答：可参考开源项目 learningjdk 。</p><p><a href="https://github.com/kangjianwei/LearningJDK" target="_blank" rel="noopener">https://github.com/kangjianwei/LearningJDK</a></p><h4 id="学习SpringBoot和Cloud之前需要先学习Servlet吗"><a href="#学习SpringBoot和Cloud之前需要先学习Servlet吗" class="headerlink" title="学习SpringBoot和Cloud之前需要先学习Servlet吗"></a>学习SpringBoot和Cloud之前需要先学习Servlet吗</h4><p>回答：必须的。</p><p>原因：兄dei，如果你连 HttpServletRequest 和 HttpServletResponse 都搞不明白，学 SpringBoot 开发 Web 场景的功能时，岂不就直接废了？Servlet 方面的知识是 JavaWeb 的基础，SpringWebMvc 是构建在 JavaWeb 之上的，SpringBoot 又是整合 SpringWebMvc 的，所以按照这个依赖关系，Servlet 当然是一个必学项啦，而且是基础的必学项。</p><h4 id="框架的高级知识如何能记得更牢靠"><a href="#框架的高级知识如何能记得更牢靠" class="headerlink" title="框架的高级知识如何能记得更牢靠"></a>框架的高级知识如何能记得更牢靠</h4><p>回答：多写多用多练。</p><p>小伙伴们扪心自问一下，你一开始学习那些框架、知识等等的，发现有这样那样的高级知识，你学会了，哇塞我牛X了，我直接芜湖起飞了！可是，你真的有在实际场景下用过吗？对于咱搞开发的来讲，知识不是学了就能记住的，一定要多加练习，这个学习没有捷径，你看到的熟练都是背后有大量付出的。</p><hr><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>初次参与直播分享，前期准备的也比较有限，难免会出现有些地方的疏漏、或者交流不充分不到位的地方，敬请小伙伴们海涵和指正。小伙伴们可以通过加入掘金直播分享群找到我，或者通过邮箱 <a href="mailto:LinkedBear@163.com" target="_blank" rel="noopener">LinkedBear@163.com</a> 与我联系。后续有机会的话，我也会继续参加咱掘金的直播，继续与各位小伙伴作有关 Spring 及生态相关的技术分享和交流。</p><p>最后，感谢各位小伙伴的捧场，也感谢掘金官方工作人员的辛勤付出，各位都辛苦啦！</p>]]></content>
    
    <summary type="html">
    
      2020年10月15日，本人有幸参与了掘金技术社区的一次直播活动，作为主讲人与小伙伴们分享了一些关于 Spring 方面的内容。写这篇文章，主要是记录一下当天分享的内容，以及一些后续的复盘等等。
    
    </summary>
    
    
      <category term="掘金日记" scheme="http://yoursite.com/categories/%E6%8E%98%E9%87%91%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>【不懂就问】MyBatis的一级缓存竟然还会引来麻烦？</title>
    <link href="http://yoursite.com/2020/06/28/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91MyBatis%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AB%9F%E7%84%B6%E8%BF%98%E4%BC%9A%E5%BC%95%E6%9D%A5%E9%BA%BB%E7%83%A6%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/06/28/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91MyBatis%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AB%9F%E7%84%B6%E8%BF%98%E4%BC%9A%E5%BC%95%E6%9D%A5%E9%BA%BB%E7%83%A6%EF%BC%9F/</id>
    <published>2020-06-28T11:48:16.000Z</published>
    <updated>2020-06-28T11:49:08.025Z</updated>
    
    <content type="html"><![CDATA[<p>【<strong>“不懂就问”</strong>，是一个新的系列，主要整理我的小册群里遇到的一些比较有意思的 / 有难度的 / 容易被讨论起来的问题，并给出问题的解析和方案等等。喜欢的小伙伴们可以点赞关注我鸭 ~ ~ 学习源码可以看看我的小册 ~ ~】</p><p>端午假期相信不少小伙伴都在偷偷学习吧（说好了放假一起玩耍呢，结果又背着我学习），这不，刚过了端午，我的一个沙雕程序猿圈子里就有人讨论起来问题了，这个问题聊起来好像挺麻烦，但实际上问题是很简单的，下面咱来讨论下这个问题。</p><h2 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h2><p>MyBatis 一级缓存与 SpringFramework 的声明式事务有冲突吗？在 Service 中开启事务，连续查询两次同样的数据，结果两次查询的结果不一致。</p><p>—— 使用 Mapper 的 <code>selectById</code> 查出来实体，然后修改实体的属性值，然后再 <code>selectById</code> 一下查出来实体，对比一下之前查出来的，发现查出来的是刚才修改过的实体，不是从数据库查出来的。</p><p>—— 如果不开启事务，则两次请求查询的结果是相同的，控制台打印了两次 SQL 。</p><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>讲道理，看到这个问题，我一下子就猜到是 MyBatis 一级缓存重复读取的问题了。</p><blockquote><p>MyBatis 的一级缓存默认开启，属于 <code>SqlSession</code> 作用范围。在事务开启的期间，同样的数据库查询请求只会查询一次数据库，之后重复查询会从一级缓存中获取。当不开启事务时，同样的多次数据库查询都会发送数据库请求。</p></blockquote><p>上面的都属于基础知识了，不多解释。重点是，他修改的实体是<strong>直接从 MyBatis 的一级缓存中查询出来的</strong>。咱都知道，查询出来的这些实体肯定属于对象，拿到的是对象的引用，咱在 Service 里修改了，一级缓存中相应的也就会被影响。由此可见，这个问题的核心原因也就很容易找到了。</p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>为了展示这个问题，咱还是简单复现一下场景吧。</p><h4 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h4><p>咱使用 SpringBoot + <code>mybatis-spring-boot-starter</code> 快速构建出工程，此处 SpringBoot 版本为 2.2.8 ，<code>mybatis-spring-boot-starter</code> 的版本为 2.1.2 。</p><h5 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h5><p>核心的 pom 依赖有 3 个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.199<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure><h5 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h5><p>数据库咱们依然选用 h2 作为快速问题复现的数据库，只需要在 application.properties 中添加如下配置，即可初始化一个 h2 数据库。顺便的，咱把 MyBatis 的配置也简单配置好：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">org.h2.Driver</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:h2:mem:mybatis-transaction-cache</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">sa</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">sa</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">h2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.schema</span>=<span class="string">classpath:sql/schema.sql</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.data</span>=<span class="string">classpath:sql/data.sql</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.h2.console.settings.web-allow-others</span>=<span class="string">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.h2.console.path</span>=<span class="string">/h2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.h2.console.enabled</span>=<span class="string">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.linkedbear.demo.entity</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span></pre></td></tr></table></figure><h5 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h5><p>上面咱使用了 <code>datasource</code> 的 schema 和 data 初始化数据库，那自然的就应该有这两个 .sql 文件。</p><p><code>schema.sql</code> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> sys_department (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure><p><code>data.sql</code> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idaaa'</span>, <span class="string">'testaaa'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idbbb'</span>, <span class="string">'testbbb'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idccc'</span>, <span class="string">'testccc'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idddd'</span>, <span class="string">'testddd'</span>);</span></pre></td></tr></table></figure><h4 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h4><p>咱使用一个最简单的单表模型，快速复现场景。</p><h5 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h5><p>新建一个 Department 类，并声明 id 和 name 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> String id;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// getter setter toString ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h5><p>MyBatis 的接口动态代理方式可以快速声明查询的  statement ，咱只需要声明一个 <code>findById</code> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepartmentMapper</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function">Department <span class="title">findById</span><span class="params">(String id)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="mapper-xml"><a href="#mapper-xml" class="headerlink" title="mapper.xml"></a>mapper.xml</h5><p>对应的，接口需要 xml 作为照应：（此处并没有使用注解式 Mapper ）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.linkedbear.demo.mapper.DepartmentMapper"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultType</span>=<span class="string">"department"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        select * from sys_department where id = #&#123;id&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span></pre></td></tr></table></figure><h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><p>Service 中注入 Mapper ，并编写一个需要事务的 <code>update</code> 方法，模拟更新动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentService</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    DepartmentMapper departmentMapper;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Department</span> <span class="title">update</span>(<span class="title">Department</span> <span class="title">department</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        Department temp = departmentMapper.findById(department.getId());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        temp.setName(department.getName());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        Department temp2 = departmentMapper.findById(department.getId());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"两次查询的结果是否是同一个对象："</span> + temp == temp2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><p>Controller 中注入 Service ，并调用 Service 的 <code>update</code> 方法来触发测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentController</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    DepartmentService departmentService;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/department/&#123;id&#125;"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">findById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> String id) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        Department department = <span class="keyword">new</span> Department();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        department.setId(id);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        department.setName(UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>, <span class="string">""</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> departmentService.update(department);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a>主启动类</h5><p>主启动类中不需要什么特别的内容，只需要记得开启事务就好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisTransactionCacheApplication</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        SpringApplication.run(MyBatisTransactionCacheApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>以 Debug 方式运行 SpringBoot 的主启动类，在浏览器中输入 <code>http://localhost:8080/h2</code> 输入刚才在 <code>application.properties</code> 中声明的配置，即可打开 h2 数据库的管理台。</p><p>执行 <code>SELECT * FROM SYS_DEPARTMENT</code> ，可以发现数据已经成功初始化了：</p><p><img src="/2020/06/28/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91MyBatis%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AB%9F%E7%84%B6%E8%BF%98%E4%BC%9A%E5%BC%95%E6%9D%A5%E9%BA%BB%E7%83%A6%EF%BC%9F/1593329634134.png" alt></p><p>下面测试效果，在浏览器中输入 <code>http://localhost:8080/department/idaaa</code> ，控制台中打印的结果为 <strong>true</strong> ，证明 MyBatis 的一级缓存生效，两次查询最终得到的实体类对象一致。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>对于这个问题的解决方案，其实说白了，就是关闭一级缓存。最常见的几种方案列举一下：</p><ul><li><p>全局关闭：设置 <code>mybatis.configuration.local-cache-scope=statement</code></p></li><li><p>指定 mapper 关闭：在 <code>mapper.xml</code> 的指定 statement 上标注 <code>flushCache=&quot;true&quot;</code></p></li><li><p>另类的办法：在 statement 的 SQL 上添加一串随机数（过于非主流。。。）</p><blockquote><p>select * from sys_department where #{random} = #{random}</p></blockquote></li></ul><hr><h2 id="原理扩展"><a href="#原理扩展" class="headerlink" title="原理扩展"></a>原理扩展</h2><p>其实到这里，问题就已经解决了，但先不要着急，思考一个问题：为什么声明了 <code>local-cache-scope</code> 为 <code>statement</code> ，或者mapper 的 statement 标签中设置 <code>flushCache=true</code> ，一级缓存就被禁用了呢？下面咱来了解下这背后的原理。</p><h4 id="一级缓存失效的原理"><a href="#一级缓存失效的原理" class="headerlink" title="一级缓存失效的原理"></a>一级缓存失效的原理</h4><p>在 <code>DepartmentService</code> 中，执行 <code>mapper.findById</code> 的动作，最终会进入到 <code>DefaultSqlSession</code> 的 <code>selectOne</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.selectOne(statement, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    List&lt;T&gt; list = <span class="keyword">this</span>.selectList(statement, parameter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(<span class="string">"Expected one result (or null) to be returned by selectOne(), but found: "</span> + list.size());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可见 <code>selectOne</code> 的底层是调用的 <code>selectList</code> ，之后 <code>get(0)</code> 取出第一条数据返回。</p><p><code>selectList</code> 的底层会有两个步骤：<strong>获取 <code>MappedStatement</code> → 执行查询</strong>，如下代码中的 <code>try</code> 部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        MappedStatement ms = configuration.getMappedStatement(statement);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        ErrorContext.instance().reset();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>执行 <code>query</code> 方法，来到 <code>BaseExecutor</code> 中，它会执行三个步骤：<strong>获取预编译的 SQL → 创建缓存键 → 真正查询</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, </span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                         RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    BoundSql boundSql = ms.getBoundSql(parameter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里面的缓存键是有一定设计的，它的结构可以简单的看成 <strong>“ statementId + SQL + 参数 ”</strong> 的形式，根据这三个要素，就可以唯一的确定出一个查询结果。</p><p>到了这里面的 <code>query</code> 方法，它就带着这个缓存键，执行真正的查询动作了，如下面的这段长源码：（注意看源码中的注释）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, </span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                         ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (closed) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果statement有设置flushCache="true"，则查询之前先清理一级缓存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        clearLocalCache();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    List&lt;E&gt; list;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        queryStack++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 先检查一级缓存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 如果一级缓存中有，则直接取出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 一级缓存没有，则查询数据库</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        queryStack--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            deferredLoad.load();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// issue #601</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        deferredLoads.clear();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 如果全局配置中有设置local-cache-scope=statement，则清除一级缓存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// issue #482</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            clearLocalCache();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> list;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>上面的注释中，可以发现，只要上面的三个解决方案，任选一个配置，则一级缓存就会失效，分别分析下：</p><ul><li>全局设置 <code>local-cache-scope=statement</code> ，则查询之后即便放入了一级缓存，但存放完立马就给清了，下一次还是要查数据库；</li><li>statement 设置 <code>flushCache=&quot;true&quot;</code> ，则查询之前先清空一级缓存，还是得查数据库；</li><li>设置随机数，如果随机数的上限足够大，那随机到相同数的概率就足够低，也能类似的看成不同的数据库请求，那缓存的 key 都不一样，自然就不会匹配到缓存。</li></ul><p>本文涉及到的所有源码可以从 GitHub 中找到：<a href="https://github.com/LinkedBear/juejin-posts-sources" target="_blank" rel="noopener">github.com/LinkedBear/juejin-posts-sources</a></p><p>【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】</p>]]></content>
    
    <summary type="html">
    
      “不懂就问”，是一个新的系列，主要整理我的小册群里遇到的一些比较有意思的 / 有难度的 / 容易被讨论起来的问题，并给出问题的解析和方案等等。
    
    </summary>
    
    
      <category term="不懂就问" scheme="http://yoursite.com/categories/%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
      <category term="一级缓存" scheme="http://yoursite.com/tags/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    
      <category term="声明式事务" scheme="http://yoursite.com/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>【不懂就问】SpringFramework中的注解声明式事务怎么被Shiro搞失效了</title>
    <link href="http://yoursite.com/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/"/>
    <id>http://yoursite.com/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/</id>
    <published>2020-06-24T05:30:16.000Z</published>
    <updated>2020-06-28T07:06:05.100Z</updated>
    
    <content type="html"><![CDATA[<p>【<strong>“不懂就问”</strong>，是一个新的系列，主要整理我的小册群里遇到的一些比较有意思的 / 有难度的 / 容易被讨论起来的问题，并给出问题的解析和方案等等。喜欢的小伙伴们可以点赞关注我鸭 ~ ~ 学习源码可以看看我的小册 ~ ~】</p><p>近期我在 SpringBoot 的小册交流群里碰见一个问题，感觉蛮有意思的，拿出来跟小伙伴们分享一下。</p><h2 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h2><p>那位小伙伴的项目中，有<strong>一部分 Service 的注解事务一直不起作用</strong>，但也只是一部分起作用，<strong>也有一部分是好的</strong>。而且更奇怪的是，如果他把一个事务不起作用的 ServiceImpl 代码完整的抄一遍到新的复制类里头，那个类居然是有事务的！</p><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>咱回想一下，按常理来讲，SpringFramework 中的事务不生效，大概有这么几种情况：</p><ul><li><code>@Transactional</code> 注解标注在非 public 方法上</li><li><code>@Transactional</code> 注解标注在接口上，但实现类使用 Cglib 代理</li><li><code>@Transactional</code> 注解标注抛出 <code>Exception</code> ，默认不捕捉</li><li>service 方法中自行 <code>try-catch</code> 了异常但没有再抛出 <code>RuntimeException</code> </li><li>原生 SSM 开发中，父子容器一起包扫描，会导致子容器先扫描到 service 并注册到子容器中但不加载事务，之后虽然父容器也扫描到 service 但因为子容器中的 controller 已经注入了没有事务代理的 service ，会导致事务失效</li><li>声明式事务的配置必须由父 IOC 容器加载，SpringWebMvc 的子 IOC 容器加载不生效</li></ul><p>除此之外，如果使用的关系型数据库是 MySQL ，还要关注是否为 InnoDB 引擎（ MyISAM 不支持事务）。</p><p>结果小伙伴一通分析，发现这上面罗列的情况都没有出现，排查难度进一步加大。</p><h2 id="新的关注点"><a href="#新的关注点" class="headerlink" title="新的关注点"></a>新的关注点</h2><p>隔了大概半天吧，那位小伙伴突然发现了一点问题：他们的项目使用了 <strong>Shiro</strong> 作为权限校验框架，而且那些<strong>事务失效的 Service 刚好就是被 Shiro 中自定义 Realm 依赖的 Service</strong> ！有了这个线索，下面排查起来就容易一些了。</p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>咱也自己搞一套，看看是不是像他说的那样吧！</p><h4 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h4><p>为了快速复现这个问题，咱使用 SpringBoot + <code>shiro-spring-boot-web-starter</code> 构建。( SpringBoot 版本只要在 2.x 就可以，本文测试功能选用 2.2.8 )</p><h5 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h5><p>关键的依赖有下面 4 个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.199<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure><h5 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h5><p>Shiro 的自定义策略核心就是 <strong><code>Realm</code></strong> ，咱也不整那些花里胡哨的，直接糊弄下算了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (token.getPrincipal() == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        String name = token.getPrincipal().toString();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 请求数据库查询是否存在用户，这里省略</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(name, <span class="string">"123456"</span>, getName());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 请求数据库/缓存加载用户的权限，这里暂时使用一组假数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        authorizationInfo.addStringPermissions(Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> authorizationInfo;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><p>只声明 Realm 还不够，需要定义几个 Bean 来补充必需的组件才行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 自定义Realm注册</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> CustomRealm <span class="title">authorizer</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomRealm();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 动态代理创建器（上面没有导入AOP）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">advisorAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        advisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> advisorAutoProxyCreator;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 过滤器定义，此处选择全部放行，方便调试</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterChainDefinition <span class="title">filterChainDefinition</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        DefaultShiroFilterChainDefinition filterChainDefinition = <span class="keyword">new</span> DefaultShiroFilterChainDefinition();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        filterChainDefinition.addPathDefinition(<span class="string">"/**"</span>, <span class="string">"anon"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> filterChainDefinition;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h5><p>快速搭建临时测试的、结构很简单的数据库，选择 h2 内存数据库更为合适。</p><p><code>application.properties</code> 中配置 h2 的数据源及初始化数据库的 SQL ：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">org.h2.Driver</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:h2:mem:shiro-test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">sa</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">sa</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">h2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.schema</span>=<span class="string">classpath:sql/schema.sql</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.data</span>=<span class="string">classpath:sql/data.sql</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.h2.console.settings.web-allow-others</span>=<span class="string">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.h2.console.path</span>=<span class="string">/h2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.h2.console.enabled</span>=<span class="string">true</span></span></pre></td></tr></table></figure><p><code>resources</code> 目录下创建 sql 文件夹，并创建两个 .sql 文件，分别声明数据库表的结构和数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> sys_department (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">---</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idaaa'</span>, <span class="string">'testaaa'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idbbb'</span>, <span class="string">'testbbb'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idccc'</span>, <span class="string">'testccc'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idddd'</span>, <span class="string">'testddd'</span>);</span></pre></td></tr></table></figure><h4 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h4><p>下面就可以按照三层架构来写一些很简单的测试代码了。</p><h5 id="DemoDao"><a href="#DemoDao" class="headerlink" title="DemoDao"></a>DemoDao</h5><p>这里咱就不整合 MyBatis / Hibernate 了，直接使用原生的 <code>JdbcTemplate</code> 就可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDao</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    JdbcTemplate jdbcTemplate;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; findAll() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(<span class="string">"select * from sys_department"</span>, <span class="keyword">new</span> ColumnMapRowMapper());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(String name)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> jdbcTemplate.update(<span class="string">"insert into sys_department (id, name) values (?, ?)"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>, <span class="string">""</span>), name);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> jdbcTemplate.update(<span class="string">"update sys_department set name = ? where id = ?"</span>, name, id);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="DemoService-DemoService2"><a href="#DemoService-DemoService2" class="headerlink" title="DemoService + DemoService2"></a>DemoService + DemoService2</h5><p>声明一个会触发抛出运行时异常的方法，并标注 <code>@Transactional</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    DemoDao demoDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">doTransaction</span>() </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        demoDao.save(<span class="string">"aaaaaaaa"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        demoDao.update(<span class="string">"18"</span>, <span class="string">"ccc"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><code>DemoService2</code> 同样的代码，仅仅是类名不同，代码不再贴出。</p><h5 id="DemoController"><a href="#DemoController" class="headerlink" title="DemoController"></a>DemoController</h5><p>Controller 里面同时依赖这两个 Service ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    DemoService demoService;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    DemoService2 demoService2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/doTransaction"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doTransaction</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        demoService.doTransaction();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"doTransaction"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/doTransaction2"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doTransaction2</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        demoService2.doTransaction();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"doTransaction2"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="Realm依赖Service"><a href="#Realm依赖Service" class="headerlink" title="Realm依赖Service"></a>Realm依赖Service</h4><p>最后，让自定义的 Realm 依赖咱刚写的 <code>DemoService</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    DemoService demoService;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr></table></figure><h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>运行 SpringBoot 的主启动类，在浏览器输入 <code>http://localhost:8080/h2</code> 输入刚才在 properties 文件中声明的配置，即可打开 h2 数据库的管理台。</p><p>执行 <code>SELECT * FROM SYS_DEPARTMENT</code> ，可以发现数据已经成功初始化了：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592959256988.png" alt="1592959256988"></p><p>下面测试事务，在浏览器输入 <code>localhost:8080/doTransaction</code> ，浏览器自然会报除零异常，但刷新数据库，会发现数据库真的多了一条 insert 过去的数据！请求 <code>/doTransaction2</code> 则不会插入新的数据。</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592959284044.png" alt="1592959284044"></p><p>到这里，问题就真的发生了，下面要想办法解决这个问题才行。</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>既然两个 Service 在代码上完全一致，只是一个被 Realm 依赖了，一个没有依赖而已，那总不能是这两个 Service 本来就不一样吧！</p><h4 id="检查两个Service对象"><a href="#检查两个Service对象" class="headerlink" title="检查两个Service对象"></a>检查两个Service对象</h4><p>将断点打在 <code>/doTransaction</code> 对应的方法上，Debug 重新启动工程，待断点落下后，发现被 Realm 依赖的 <code>DemoService</code> 不是代理对象，而没有被 Realm 依赖的 <code>DemoService2</code> 经过事务的增强，成为了一个代理对象：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592916608297.png" alt="1592916608297"></p><p>所以由此就可以看到问题所在了吧！上面的那个 <code>DemoService</code> 都没经过事务代理，凭什么能支持事务呢？？？</p><h4 id="检查Service的创建时机"><a href="#检查Service的创建时机" class="headerlink" title="检查Service的创建时机"></a>检查Service的创建时机</h4><p>既然两个 Service 都不是一个样的，那咱就看看这俩对象都啥时候创建的吧！给 <code>DemoService</code> 上显式的添加上无参构造方法，方便过会 Debug ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoService</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"DemoService constructor run ......"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><p>重新以 Debug 运行，等断点打在构造方法中，观察方法调用栈：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592917238145.png" alt="1592917238145"></p><p>看上去还比较正常吧，但如果往下拉到底，这问题就太严重了：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592917282785.png" alt="1592917282785"></p><p>哦，合着我这个 <code>DemoService</code> 在 <strong><code>refresh</code> 方法的后置处理器注册步骤就已经创建好了</strong>啊！小伙伴们要知道，SpringFramework 中 <code>ApplicationContext</code> 的初始化流程，一定是<strong>先把后置处理器都注册好了，再创建单实例 Bean</strong> 。但是这里很明显是后置处理器还没完全处理完，就引发单实例 Bean 的创建了！</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>问题终于找明白了，咋解决呢？其实网上有的是现成的文章了：</p><p><a href="https://blog.csdn.net/hzw2312/article/details/81030277" target="_blank" rel="noopener">spring boot shiro 事务无效</a></p><p><a href="https://blog.csdn.net/yucaifu1989/article/details/79206369" target="_blank" rel="noopener">shiro导致springboot事务不起效解决办法</a></p><p><a href="https://blog.csdn.net/keliii/article/details/80051688" target="_blank" rel="noopener">spring + shiro 配置中部分事务失效分析及解决方案</a></p><p>总的来看，解决方案的核心在于：如何让 <code>Realm</code> 创建时不立即依赖创建 <code>DemoService</code> ，所以就有两种解决方案了：要么延迟初始化 <code>DemoService</code> ，要么<strong>把自定义的 <code>Realm</code> 和 <code>SecurityManager</code> 放在一个额外的空间，利用监听器机制创建它们</strong> 。具体的实现可以参照上面文章的写法，这里就不赘述了。</p><h2 id="原理扩展"><a href="#原理扩展" class="headerlink" title="原理扩展"></a>原理扩展</h2><p>解决问题之后，如果能从这里面了解到一点更深入的原理知识，想必那是最好不过了。下面就这个问题出现的原因，以及上面 <code>@Lazy</code> 方案的原理，咱都深入解析一下。</p><h4 id="Shiro提早创建Realm的原因"><a href="#Shiro提早创建Realm的原因" class="headerlink" title="Shiro提早创建Realm的原因"></a>Shiro提早创建Realm的原因</h4><p>既然上面看到了方法调用栈中，<code>DemoService</code> 被自定义 <code>Realm</code> 依赖后在 <code>ApplicationContext</code> 的 <code>refresh</code> 阶段的 <strong><code>registerBeanPostProcessors</code></strong> 中就已经被触发创建，可它为什么非要搞这一出呢？自定义 <code>Realm</code> 放到 <strong><code>finishBeanFactoryInitialization</code></strong> 中统一创建不好吗？下面咱通过 Debug 研究问题的成因。</p><h5 id="Debug运行"><a href="#Debug运行" class="headerlink" title="Debug运行"></a>Debug运行</h5><p><code>DemoService</code> 中的断点不要去掉，重新 Debug 让断点停在那里，翻到最底下的调用栈，查看那个正在创建的 <code>BeanPostProcessor</code> ，发现它的名称是 <code>shiroEventBusAwareBeanPostProcessor</code> ：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592959800675.png" alt="1592959800675"></p><h5 id="Shiro的后置处理器创建"><a href="#Shiro的后置处理器创建" class="headerlink" title="Shiro的后置处理器创建"></a>Shiro的后置处理器创建</h5><p>翻开创建 <code>shiroEventBusAwareBeanPostProcessor</code> 的位置，在 <code>ShiroBeanAutoConfiguration</code> 中，它又依赖了一个 <code>EventBus</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ShiroEventBusBeanPostProcessor <span class="title">shiroEventBusAwareBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.shiroEventBusAwareBeanPostProcessor();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ShiroEventBusBeanPostProcessor <span class="title">shiroEventBusAwareBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ShiroEventBusBeanPostProcessor(eventBus());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>顺着方法调用栈往上爬，找到下一个 <code>doCreateBean</code> ，发现确实有创建 <code>eventBus</code> 的部分：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592962300364.png" alt="1592962300364"></p><p>再往上爬，发现这上面有一个 <code>wrapIfNecessary</code> 方法的调用，很明显这是要搞 <strong>AOP</strong> 增强了啊：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592962353901.png" alt="1592962353901"></p><p>AOP 的增强需要先获取到增强器，继续往上爬方法调用，在 <code>findAdvisorBeans</code> 方法中找到了两个适配的增强器：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592962931169.png" alt="1592962931169"></p><p>上面的是 Shiro 的授权相关的增强器，下面是 SpringFramework 中的事务控制增强器。</p><h5 id="触发AOP增强器的创建"><a href="#触发AOP增强器的创建" class="headerlink" title="触发AOP增强器的创建"></a>触发AOP增强器的创建</h5><p>根据迭代顺序，先取出下面的事务控制增强器 <code>TransactionAdvisor</code> ，由于获取到增强器的 Bean 也是需要走统一的 <code>getBean</code> 方法，所以在方法调用栈中，咱又一次看到了 <code>getBean</code> 方法，继续往下创建。</p><p>由于在 SpringFramework 中，使用 <code>@Configuration</code> + <code>@Bean</code> 声明的 Bean ，都是要<strong>先把配置类初始化好，才能创建 Bean</strong> 。所以继续往上爬调用栈时，会发现它并没有接着创建 Shiro 的增强器 <code>authorizationAttributeSourceAdvisor</code> ，而是先初始化了声明有 <code>TransactionAttributeSourceAdvisor</code> 的配置类 <code>ProxyTransactionManagementConfiguration</code> ：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592963447497.png" alt="1592963447497"></p><p>再往上走，发现又出现了一次 <code>wrapIfNecessary</code> 方法，说明<strong>配置类也会被 AOP 增强</strong>。那就重复一遍上面的步骤，继续遇到这两个增强器。</p><p>这个时候可能有小伙伴产生疑问了：这次创建就是因为上面的 <code>TransactionAttributeSourceAdvisor</code> 创建才跟过来的，这次还要再创建，这是闹哪出呢？放心，咱都想到这个问题了，人家写 SpringFramework 的大佬们能想不到吗？所以在创建之前，它加了一个判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果当前bean正在创建，则跳过</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        logger.trace(<span class="string">"Skipping currently created advisor '"</span> + name + <span class="string">"'"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor<span class="class">.<span class="keyword">class</span>))</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><p>这里巧妙的利用了 <strong><code>singletonsCurrentlyInCreation</code></strong> 这个集合，判断了当前增强器是否在创建，这样就不会出现重复创建无限死循环的问题了。</p><blockquote><p><code>singletonsCurrentlyInCreation</code> 的存放是在 <code>getSingleton</code> 方法调用时就已经放进去了，所以能很稳妥的记录下当前正在创建的所有 Bean ，防止死循环重复创建。</p></blockquote><h5 id="Shiro增强器的创建"><a href="#Shiro增强器的创建" class="headerlink" title="Shiro增强器的创建"></a>Shiro增强器的创建</h5><p>上面的事务控制增强器跳过去了，那就可以创建 Shiro 的增强器了：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592963883656.png" alt="1592963883656"></p><p>这次没有再出现那些幺蛾子，但是这个增强器本身依赖一个 <code>SecurityManager</code> ：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592963942464.png" alt="1592963942464"></p><p>那就继续创建呗，创建 <code>SecurityManager</code> 的过程中又出现了新的依赖：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592964032857.png" alt="1592964032857"></p><p>这个 <code>authorizer</code> ，就是咱上面在 <code>ShiroConfiguration</code> 中注册的自定义 <code>Realm</code> 。</p><p>看到这里了，后续的步骤想必不用我说小伙伴们也能自己想到了吧：<strong>Realm 的创建又需要依赖 <code>DemoService</code> ，而 <code>DemoService</code> 在创建时由于事务控制增强器还没有创建好，所以无法代理 <code>DemoService</code> ，最终注入到 Realm 的 <code>DemoService</code> 就是不带事务的</strong>。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>捋一捋整个流程哈，整个创建过程经历了以下几个层级的依赖创建：</p><ol><li><p><code>ApplicationContext</code> 的 <code>refresh</code> 方法要创建 <code>BeanPostProcessor</code> </p></li><li><p><code>ShiroEventBusBeanPostProcessor</code> 的创建需要依赖 <code>EventBus</code></p></li><li><p><code>EventBus</code> 创建时需要被 AOP 增强，触发 AOP 增强器的创建逻辑</p><blockquote><p>此时 AOP 增强器有 2 个，分别是事务控制增强器，和 Shiro 的增强器</p></blockquote></li><li><p>首先创建事务控制的 AOP 增强器 <code>TransactionAttributeSourceAdvisor</code> ，由于它定义在配置类中，又触发配置类的创建</p></li><li><p>配置类创建时也要被 AOP 增强，再一次触发 AOP 增强器的创建逻辑</p><blockquote><p>此时事务控制增强器正在被创建，所以被跳过了</p></blockquote></li><li><p>触发 Shiro 增强器的创建，而 Shiro 增强器又依赖 <code>SecurityManager</code></p></li><li><p><code>SecurityManager</code> 又依赖 <code>authorizer</code> ，也就是自定义的 <code>Realm</code> </p></li><li><p>自定义 <code>Realm</code> 依赖 <code>DemoService</code> ，触发 <code>DemoService</code> 的创建</p></li><li><p><code>DemoService</code> 创建后要被事务 AOP 增强，但此时事务控制增强器还没有完全创建好，所以无法代理，导致 <code>DemoService</code> 不带事务</p></li></ol><h4 id="Lazy解决该问题的原理"><a href="#Lazy解决该问题的原理" class="headerlink" title="@Lazy解决该问题的原理"></a>@Lazy解决该问题的原理</h4><p>上面解决方案的第三篇文章，他提到可以用 <code>@Lazy</code> 注解解决问题，我在翻文章时有人说不能用（他把 <code>@Lazy</code> 注解标注到 <code>DemoService</code> 类上了），讲道理可能是他不会用才这么说的（￣へ￣）。其实用 <code>@Lazy</code> 注解是完全可行的，不过标注的位置要对，真正要标注的位置是自定义 <code>Realm</code> 的 <code>DemoService</code> 成员上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">DemoService demoService;</span></pre></td></tr></table></figure><p>下面咱解释下为什么 <code>@Lazy</code> 标注在自定义 <code>Realm</code> 的依赖上好用，标注在 <code>DemoService</code> 类上不好用。</p><h5 id="测试-Lazy标注在DemoService上"><a href="#测试-Lazy标注在DemoService上" class="headerlink" title="测试-@Lazy标注在DemoService上"></a>测试-@Lazy标注在DemoService上</h5><p>将 <code>@Lazy</code> 注解标注到 <code>DemoService</code> 的类上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span></span></span></pre></td></tr></table></figure><p>重新 Debug ，发现断点落在 <code>DemoService</code> 的构造方法时，<code>refresh</code> 的动作仍然停在 <code>registerBeanPostProcessors</code> 步骤，说明将 <code>@Lazy</code> 标注在 <code>DemoService</code> 上是不可行的，这也就是上面我提的那个文章里说 <code>@Lazy</code> 不可行。</p><h5 id="测试-Lazy标注在自定义Realm的依赖上"><a href="#测试-Lazy标注在自定义Realm的依赖上" class="headerlink" title="测试-@Lazy标注在自定义Realm的依赖上"></a>测试-@Lazy标注在自定义Realm的依赖上</h5><p>去掉上面 <code>DemoService</code> 类上的 <code>@Lazy</code> ，在自定义 <code>Realm</code> 的 <code>DemoService</code> 依赖上标注，重新 Debug，观察断点停下时 <code>refresh</code> 执行的步骤：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592966236460.png" alt="1592966236460"></p><p>可以发现已经到了可以正常初始化单实例 Bean 的时机了，此时创建的 <code>DemoService</code> 就不会有问题了。</p><p>放行断点，待应用启动完成后，浏览器再发送 <code>/doTransaction</code> 的请求，发现这次事务已经生效了。</p><p>到这里，就验证了 <code>@Lazy</code> 的正确使用方法。</p><p>但是！！！不要着急！下面咱再扩展一点原理哈 ~ ~ ~</p><p>想一下，此时这个 <code>DemoService</code> 是啥玩意触发创建的？</p><p>答案很明显是 <strong><code>DemoController</code></strong> ，因为 Controller 还依赖着 Service 呢。</p><h5 id="测试-Lazy标注Realm-Controller"><a href="#测试-Lazy标注Realm-Controller" class="headerlink" title="测试-@Lazy标注Realm+Controller"></a>测试-@Lazy标注Realm+Controller</h5><p>继续测试，把自定义 <code>Realm</code> 和 <code>DemoController</code> 两个类的 <code>DemoService</code> 依赖都标注上 <code>@Lazy</code> ，重新 Debug ，待断点停下后，想一下此时 <code>DemoService</code> 又是谁触发它创建的呢？</p><p>答案也不难猜，是 <strong>IOC 容器本身</strong>创建的，因为 <code>DemoService</code> 所有被依赖的关系都延迟加载了，但 <strong>IOC 容器本身还要预先创建好所有的单实例 Bean</strong> ，所以 <code>DemoService</code> 还是在 IOC 容器启动的过程中创建了。</p><h5 id="测试-Lazy全标注"><a href="#测试-Lazy全标注" class="headerlink" title="测试-@Lazy全标注"></a>测试-@Lazy全标注</h5><p>继续，这次把 <code>DemoService</code> 上也标注上 <code>@Lazy</code> ，重新 Debug ，这次应用没有落在断点上直接启动了，说明 IOC 容器本身发现 <code>DemoService</code> 也可以延迟创建，就跳过去了，所以 IOC 容器初始化的全过程中 <code>DemoService</code> 都没有创建。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>总结一下 <code>@Lazy</code> 的使用规则和对应的原理：</p><ul><li><code>@Lazy</code> 标注在 Bean 的类上：告诉 IOC 容器，在<strong>容器初始化阶段不要实例化</strong>我</li><li><code>@Lazy</code> 标注在其他 Bean 的依赖上：告诉 IOC 容器，在创建这个标注了 <code>@Lazy</code> 的 Bean 时，<strong>不要立即处理</strong>我标注的这个<strong>依赖</strong></li></ul><p>本文涉及到的所有源码可以从 GitHub 中找到：<a href="https://github.com/LinkedBear/juejin-posts-sources" target="_blank" rel="noopener">https://github.com/LinkedBear/juejin-posts-sources</a></p><p>【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】</p>]]></content>
    
    <summary type="html">
    
      “不懂就问”，是一个新的系列，主要整理我的小册群里遇到的一些比较有意思的 / 有难度的 / 容易被讨论起来的问题，并给出问题的解析和方案等等。
    
    </summary>
    
    
      <category term="不懂就问" scheme="http://yoursite.com/categories/%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="声明式事务" scheme="http://yoursite.com/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="Shiro" scheme="http://yoursite.com/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Spring中使用的设计模式，你都能说全吗？[下]</title>
    <link href="http://yoursite.com/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8B]/"/>
    <id>http://yoursite.com/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8B]/</id>
    <published>2020-06-13T05:16:55.000Z</published>
    <updated>2020-06-28T07:07:04.448Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Spring 面试题系列的第二篇 【Spring 中的设计模式】 下半部分，</p><p>本篇只回答一个问题：</p><h2 id="Spring-中使用了哪些设计模式？分别都是如何实现的？"><a href="#Spring-中使用了哪些设计模式？分别都是如何实现的？" class="headerlink" title="Spring 中使用了哪些设计模式？分别都是如何实现的？"></a>Spring 中使用了哪些设计模式？分别都是如何实现的？</h2><p>回顾一下上一篇的概述，从整体上讲，SpringFramework 中使用了 11 种设计模式：</p><ul><li><strong>单例模式+原型模式</strong></li><li><strong>工厂模式</strong></li><li><strong>代理模式</strong></li><li><strong>策略模式</strong></li><li><strong>模板方法模式</strong></li><li><strong>观察者模式</strong></li><li><strong>适配器模式</strong></li><li><strong>装饰者模式</strong></li><li><strong>外观模式</strong></li><li><strong>委派模式</strong>（不属于GoF23）</li></ul><p>这一篇咱把下面的 6 个设计模式也详细解析一下。</p><blockquote><p>喜欢本文的小伙伴不要忘记点赞呀 ~ ~ ~ 三克油！！！</p></blockquote><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式，在 SpringFramework 中使用的那是相当的多啊！即便是初学 SpringFramework ，在学习到 jdbc 部分，也应该接触过一个模板方法模式的体现，就是 <code>JdbcTemplate</code> 的回调机制：（贴两个比较常见的经典方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result(query(sql, <span class="keyword">new</span> RowMapperResultSetExtractor&lt;&gt;(rowMapper)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql) <span class="keyword">throws</span> DataAccessException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> query(sql, getColumnMapRowMapper());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在调用时，只需要一句话就够了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; datas = jdbcTemplate.queryForList(<span class="string">"select * from user"</span>);</span></pre></td></tr></table></figure><p>小伙伴们可能会一脸懵，这么个方法就体现模板方法模式了吗？我也看不出来啊？莫慌，下面咱先回顾下原生 jdbc 的操作步骤，慢慢自然就明白了。</p><h4 id="原生jdbc使用步骤"><a href="#原生jdbc使用步骤" class="headerlink" title="原生jdbc使用步骤"></a>原生jdbc使用步骤</h4><p>原生的 jdbc 操作需要以下这么多步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册驱动</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">PreparedStatement statement = connection.prepareStatement(<span class="string">"select * from user"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装结果数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; datas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    data.put(<span class="string">"id"</span>, resultSet.getString(<span class="string">"id"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    data.put(<span class="string">"name"</span>, resultSet.getString(<span class="string">"name"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    datas.add(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">resultSet.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">statement.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">connection.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回/输出数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">System.out.println(datas);</span></pre></td></tr></table></figure><p>但是，这里面的操作有很多是重复的，所以这一段代码可以抽取为几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; encapsulate(ResultSet resultSet) <span class="keyword">throws</span> SQLException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; datas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        data.put(<span class="string">"id"</span>, resultSet.getString(<span class="string">"id"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        data.put(<span class="string">"name"</span>, resultSet.getString(<span class="string">"name"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        datas.add(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> datas;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection connection, PreparedStatement statement, ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    resultSet.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    statement.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    connection.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>如此下来，主干代码就只剩下这些了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Connection connection = getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    PreparedStatement statement = connection.prepareStatement(<span class="string">"select * from user"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装结果数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; datas = encapsulate(resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    close(connection, statement, resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回/输出数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    System.out.println(datas);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>那最后稍微调整一下，就可以成为一个通用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; query(String sql, List&lt;Object&gt; params) <span class="keyword">throws</span> Exception &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Connection connection = getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    PreparedStatement statement = connection.prepareStatement(sql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 填充占位符参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        statement.setObject(i + <span class="number">1</span>, params.get(i));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装结果数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; datas = encapsulate(resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    close(connection, statement, resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> datas;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>目前这个方法已经可以通用了，不过只能返回 Map ，如果想返回模型类对象怎么办呢？这样咱就可以扩展一个自定义结果集封装的方法，让调用者自己决定如何封装。再次改动的代码可以像如下优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql, List&lt;Object&gt; params, Function&lt;ResultSet, List&lt;T&gt;&gt; encapsulate)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Connection connection = getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    PreparedStatement statement = connection.prepareStatement(sql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 填充占位符参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        statement.setObject(i + <span class="number">1</span>, params.get(i));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装结果数据（借助Function接口实现结果集封装）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    List&lt;T&gt; datas = encapsulate.apply(resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    close(connection, statement, resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> datas;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看最后一个参数，我让方法的调用者传一个 <code>Function&lt;ResultSet, List&lt;T&gt;&gt;</code> 类型的自定义处理逻辑，这样返回的数据究竟是什么类型我也就不用管了，完全由调用者自己决定。</p><p>到这里，模板方法模式就得以体现了，整个查询的动作我只需要让方法调用者传 SQL 、SQL 中可能出现的参数，以及自定义的结果集封装逻辑，其余的动作都不需要方法调用者关注。</p><p>可是，这跟 <code>JdbcTemplate</code> 又有什么关系呢？？？</p><h4 id="JdbcTemplate中体现的模板方法"><a href="#JdbcTemplate中体现的模板方法" class="headerlink" title="JdbcTemplate中体现的模板方法"></a>JdbcTemplate中体现的模板方法</h4><p>我上面不是摘出来一个 <code>JdbcTemplate</code> 的方法嘛：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result(query(sql, <span class="keyword">new</span> RowMapperResultSetExtractor&lt;&gt;(rowMapper)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>咱点进去看 <code>query</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// assert logger ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title">StatementCallback</span>&lt;<span class="title">T</span>&gt;, <span class="title">SqlProvider</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            ResultSet rs = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                rs = stmt.executeQuery(sql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> rse.extractData(rs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                JdbcUtils.closeResultSet(rs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> sql;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> execute(<span class="keyword">new</span> QueryStatementCallback());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>注意看方法参数列表的最后一个：<code>ResultSetExtractor</code> ，它是一个函数式接口，而且它只有一个方法，就是<strong>根据结果集返回泛型类型的数据</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetExtractor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">extractData</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException, DataAccessException</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>是不是这个设计跟我上面演示的思路基本一致了？这就是 <code>JdbcTemplate</code> 中体现的模板方法模式。</p><p>除了这些 <code>xxxTemplate</code> 中有体现，其实在 SpringFramework 中的最底层 IOC 容器模型，<code>BeanFactory</code> 和 <code>ApplicationContext</code> ，以及 SpringWebMvc 中的 <code>HandlerMapping</code> 、<code>HandlerAdapter</code> 等等，都有很多模板方法模式的体现。下面咱也举两个例子来体会。</p><h4 id="ApplicationContext中体现的模板方法"><a href="#ApplicationContext中体现的模板方法" class="headerlink" title="ApplicationContext中体现的模板方法"></a>ApplicationContext中体现的模板方法</h4><p>说到 <code>ApplicationContext</code> ，最经典的方法莫过于 <code>AbstractApplicationContext</code> 中的 <code>refresh</code> ：（只截取很少的一部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            onRefresh();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="comment">// catch finally ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在这个方法中有一个动作是 <code>onRefresh</code> 方法，点进去发现它是一个空方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Template method which can be overridden to add context-specific refresh work.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Called on initialization of special beans, before instantiation of singletons.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * &lt;p&gt;This implementation is empty.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of errors</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// For subclasses: do nothing by default.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>注意看文档注释的前两个单词：<strong>Template method</strong> ！！！文档注释已经告诉咱这是一个模板方法了！而且方法体中也说了，<strong>它默认不做任何事情，留给子类扩展使用。</strong>由此咱就可以了解 <code>ApplicationContext</code> 中最经典的模板方法模式设计之一了。</p><h4 id="HandlerMapping中体现的模板方法"><a href="#HandlerMapping中体现的模板方法" class="headerlink" title="HandlerMapping中体现的模板方法"></a>HandlerMapping中体现的模板方法</h4><p>在 <code>DispatcherServlet</code> 接收到客户端的请求，要进行实际处理时，需要先根据 uri 寻找能匹配的 <code>HandlerMapping</code> ，这一步它会委托 <code>HandlerMapping</code> 帮忙找（这里面涉及到委派了，下面会讲到），而这个寻找 <code>HandlerMapping</code> 的动作在 <code>AbstractHandlerMapping</code> 的 <code>getHandler</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Object handler = getHandlerInternal(request);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        handler = getDefaultHandler();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里面第一句就会调另一个 <code>getHandlerInternal</code> 方法，而这个方法在 <code>AbstractHandlerMapping</code> 中是自己定义的抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span></pre></td></tr></table></figure><p>这就是非常经典的模板方法模式的体现了：<strong>父类 / 抽象类把逻辑步骤都定义出来，具体的动作让子类实现</strong>。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中体现的模板方法模式非常多，包括各种 Template （ <code>JdbcTemplate</code> 、<code>HibernateTemplate</code> 、<code>RedisTemplate</code> 等），以及核心源码内部设计的模板方法（如 <code>AbstractApplicationContext</code> 中的 <code>refresh</code> 套 <code>onRefresh</code> 、<code>AbstractHandlerMapping</code> 中的 <code>getHandler</code> 套 <code>getHandlerInternal</code> 等），它设计的核心思想是父类 / 抽象类把逻辑步骤都定义出来，具体的动作让子类实现。</strong></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><strong>观察者模式</strong>，也被称为<strong>发布订阅模式</strong>，其实它还有一个叫法：<strong>监听器模式</strong>。那说到监听器，是不是就立马想起来 SpringFramework 中的 <strong><code>ApplicationListener</code></strong> 了？对了，就这么回事，其实都不用展开讲，小伙伴们也能答得出来了。不过，想回答的漂亮，还需要额外知道一点点东西。</p><h4 id="观察者模式的核心"><a href="#观察者模式的核心" class="headerlink" title="观察者模式的核心"></a>观察者模式的核心</h4><p>咱都知道，观察者模式的两大核心是：<strong>观察者、被观察主题</strong>。对应到 SpringFramework 中的概念分别是：<strong>事件、监听器</strong>。</p><p>不过我个人比较喜欢把 SpringFramework 的事件驱动核心概念划分为 4 个：<strong>事件源、事件、广播器、监听器</strong>。</p><ul><li><strong>事件源：发布事件的对象</strong></li><li><strong>事件：事件源发布的信息</strong></li><li><strong>广播器：事件真正广播给监听器的对象</strong>【即 <strong><code>ApplicationContext</code></strong> 】<ul><li><code>ApplicationContext</code> 接口有实现 <code>ApplicationEventPublisher</code> 接口，具备<strong>事件广播器的发布事件的能力</strong></li></ul></li><li><strong>监听器：监听事件的对象</strong></li></ul><p>在 SpringFramework 中，<strong>事件源想要发布事件，需要注入事件广播器，通过事件广播器来广播事件</strong>。</p><h4 id="SpringFramework使用监听器"><a href="#SpringFramework使用监听器" class="headerlink" title="SpringFramework使用监听器"></a>SpringFramework使用监听器</h4><p>以下是一个最简单的监听器使用实例：</p><h5 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceEvent</span><span class="params">(Object source)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">super</span>(source);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventService</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ApplicationContext ctx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        ctx.publishEvent(<span class="keyword">new</span> ServiceEvent(<span class="keyword">this</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext ctx)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ServiceEvent</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ServiceEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"监听到ServiceEvent事件："</span> + event);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中实现的观察者模式就是事件驱动机制，可以通过自定义监听器，监听不同的事件，完成不同的业务处理。</strong></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>了解 SpringWebMvc 中 <code>DispatcherServlet</code> 的工作原理，应该对 <code>HandlerAdapter</code> 不陌生，它就是辅助执行 Controller 中具体方法的<strong>适配器</strong>。如果只答这一句当然够用，不过回答的再细致点，那自然是更好的。</p><h4 id="DispatcherServlet委派HandlerAdapter"><a href="#DispatcherServlet委派HandlerAdapter" class="headerlink" title="DispatcherServlet委派HandlerAdapter"></a>DispatcherServlet委派HandlerAdapter</h4><p>在 <code>DispatcherServlet</code> 的 <code>doDispatch</code> 方法中，有一句代码是根据 <code>HandlerMapping</code> 中的 <code>Handler</code> 获取 <code>HandlerAdapter</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span></pre></td></tr></table></figure><p>这个 <strong>Handler</strong> 就是<strong>目标 Controller 中的目标方法</strong>，在适配的过程中它会寻找现有的所有 <code>HandlerAdapter</code> 是否能支持执行这个 Handler ，根据 <code>RequestMappingHandlerMapping</code> 的命名，自然也能猜得出来，真正负责执行目标 Controller 中方法的是 <strong><code>RequestMappingHandlerAdapter</code></strong> 。</p><h4 id="HandlerAdapter执行Handler"><a href="#HandlerAdapter执行Handler" class="headerlink" title="HandlerAdapter执行Handler"></a>HandlerAdapter执行Handler</h4><p>在 <code>RequestMappingHandlerAdapter</code> 中，执行目标 Controller 中方法的核心方法是 <code>handle</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看到了 <code>handleInternal</code> ，是不是又想到了<strong>模板方法</strong>？没错，就是这个设计。</p><p>在底层，核心的执行 Handler 的逻辑其实就是<strong>反射</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ReflectionUtils.makeAccessible(getBridgedMethod());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// method.invoke</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>由此可知，<code>HandlerAdapter</code> 的执行其实也没有很神秘，最终还是玩的反射而已。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中的适配器模式，体现之一是 <code>HandlerAdapter</code> 辅助执行目标 Controller 中的方法，底层是借助反射执行。</strong></p><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰者跟代理、适配器都有些相似，不过<strong>装饰者</strong>更强调的是<strong>在原有的基础上附加额外的动作 / 方法 / 特性</strong>，而<strong>代理模式</strong>有<strong>控制内部对象访问</strong>的意思。</p><p>SpringFramework 中体现的装饰者模式，在核心源码中并没有体现，不过在缓存模块 spring-cache 中倒是有一个体现：<strong><code>TransactionAwareCacheDecorator</code></strong> 。</p><h4 id="Bean的包装"><a href="#Bean的包装" class="headerlink" title="Bean的包装"></a>Bean的包装</h4><p>了解过 Bean 的创建流程，应该知道最底层的创建动作发生在 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>doCreateBean</code>  中，而这里面第一波动作就把 <code>BeanWrapper</code> 都创建好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Instantiate the bean.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><p>注意看，它创建的动作是 <code>createBeanInstance</code> ，意为“创建 bean 实例”，那就可以理解为：<strong>bean 对象已经在这个动作下实例化好了</strong>。深入这个方法，最终可以在 <code>createBeanInstance</code> 方法的最后一句 return 中看到 bean 实例的创建，以及 <code>BeanWrapper</code> 的包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        Object beanInstance;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 实例化对象......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        initBeanWrapper(bw);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> bw;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看到下面的代码中，它把 bean 的实例对象包装为一个 <code>BeanWrapper</code> ，形成装饰者。</p><h4 id="SpringCache的核心设计"><a href="#SpringCache的核心设计" class="headerlink" title="SpringCache的核心设计"></a>SpringCache的核心设计</h4><p>SpringCache 主做的是应用业务层级的缓存，它与 JSR107 有一定关系但又不同（Spring 自己实现了一套缓存，就是这个 SpringCache ）。</p><p>用一张简单的图解释 SpringCache 的核心，大概可以这样理解：</p><p><img src="/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8B]/1592051318911.png" alt></p><p>一个 <code>CacheManager</code> 中包含多个 <code>Cache</code> ，一个 <code>Cache</code> 可以简单理解为一个 <strong>Map&lt;String, T&gt;</strong> 。</p><p>从 <code>Cache</code> 接口的设计，也能看出来就是 <strong><code>Map</code></strong> 的思路：（核心方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">ValueWrapper <span class="title">get</span><span class="params">(Object key)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Object key, @Nullable Object value)</span></span>;</span></pre></td></tr></table></figure><h4 id="Cache的装饰者体现"><a href="#Cache的装饰者体现" class="headerlink" title="Cache的装饰者体现"></a>Cache的装饰者体现</h4><p><code>TransactionAwareCacheDecorator</code> 作为装饰者，那肯定要实现 Cache 接口，并且组合一个 Cache 的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAwareCacheDecorator</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache targetCache;</span></pre></td></tr></table></figure><p>这里面，真正体现装饰者的位置是在 <code>put</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">final</span> Object key, @Nullable <span class="keyword">final</span> Object value)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                TransactionAwareCacheDecorator.<span class="keyword">this</span>.targetCache.put(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.targetCache.put(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可以发现，它会在 <strong>put 之前，检查当前线程中是否存在已经开启的事务</strong>：如果存在事务，则会将 put 操作注册到<strong>事务结束后</strong>。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中实现的装饰者模式，体现之一是在 SpringCache 缓存的存放逻辑中，如果执行缓存时的线程中存在事务，则缓存的保存会在事务结束后再执行。</strong></p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式算是比较简单的模式，它强调的是<strong>统一入口，内部组合</strong>。一个经典的体现是在 IOC 解析 Bean 的定义信息时使用的 <code>BeanDefinitionLoader</code> 。</p><p>在 <code>BeanDefinitionLoader</code> 中，它组合了 4 种不同类型的解析器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionLoader</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 注解式Bean定义解析器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader annotatedReader;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// xml文件的Bean定义解析器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader xmlReader;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Groovy的Bean定义解析器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BeanDefinitionReader groovyReader;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 类路径的Bean定义扫描器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span></pre></td></tr></table></figure><p>尽管组合的解析器很多，但最终暴露出来的方法是同样的名：<code>load</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Class&lt;?&gt; source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(GroovyBeanDefinitionSource source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Resource source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Package source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(CharSequence source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr></table></figure><p>由此可以体现出很经典的外观模式。</p><h3 id="委派模式"><a href="#委派模式" class="headerlink" title="委派模式"></a>委派模式</h3><p>委派模式本不属于 GoF23 中的设计模式，不过既然咱在前面也反复提到过几次，这里咱还是摘出来说两句。</p><p>在 <code>DispatcherServlet</code> 的核心工作流程中，委派模式体现在 <code>HandlerMapping</code> 、<code>HandlerAdapter</code> 、<code>ViewResolver</code> 接受 <code>DispatcherServlet</code> 的委派，如下面的整体流程图：</p><p><img src="/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8B]/DispatcherServlet%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt></p><p>到这里，SpringFramework 中使用的设计模式就差不多整理完了，想要回答的尽可能全面、准确、有深度，小伙伴们要好好理解这些模式的设计、思想，以及 SpringFramework 中的源码实现，这样在被面试官问到才会更加游刃有余。</p><p>【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】</p>]]></content>
    
    <summary type="html">
    
      本文的主题：Spring 中涉及到的设计模式，如何在面试中回答的尽可能全面、准确、有深度。
    
    </summary>
    
    
      <category term="SpringFramework" scheme="http://yoursite.com/categories/SpringFramework/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring中使用的设计模式，你都能说全吗？[上]</title>
    <link href="http://yoursite.com/2020/06/09/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8A]/"/>
    <id>http://yoursite.com/2020/06/09/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8A]/</id>
    <published>2020-06-09T05:16:55.000Z</published>
    <updated>2020-06-28T07:06:53.647Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Spring 面试题系列的第二篇，本文的主题：Spring 中涉及到的<strong>设计模式</strong>，如何在面试中回答的尽可能全面、准确、有深度。</p><p>本篇只回答一个问题：</p><h2 id="Spring-中使用了哪些设计模式？分别都是如何实现的？"><a href="#Spring-中使用了哪些设计模式？分别都是如何实现的？" class="headerlink" title="Spring 中使用了哪些设计模式？分别都是如何实现的？"></a>Spring 中使用了哪些设计模式？分别都是如何实现的？</h2><p>首先作一个概述，从整体上讲，SpringFramework 中使用了 11 种设计模式：</p><ul><li><strong>单例模式+原型模式</strong></li><li><strong>工厂模式</strong></li><li><strong>代理模式</strong></li><li><strong>策略模式</strong></li><li><strong>模板方法模式</strong></li><li><strong>观察者模式</strong></li><li><strong>适配器模式</strong></li><li><strong>装饰者模式</strong></li><li><strong>外观模式</strong></li><li><strong>委派模式</strong>（不属于GoF23）</li></ul><p>当然，如果只是这么回答，面试官会怎么想：你这。。。不会是在<strong>背答案</strong>吧！随便揪出一个来细问，可能就翻皮水了 ~ ~ 所以咱不光要知道用了啥，而且还要知道如何用的，在哪里用的，这样才能用自己真正的技术储备征服面试官。</p><p>下面咱详细的介绍 11 种设计模式的设计场景和原理。</p><blockquote><p>由于 11 种设计模式全部展开篇幅过长，会分成两篇专栏介绍。</p></blockquote><h3 id="单例模式-原型模式"><a href="#单例模式-原型模式" class="headerlink" title="单例模式+原型模式"></a>单例模式+原型模式</h3><p>SpringFramework 的 IOC 容器中放了很多很多的 Bean ，默认情况下，Bean 的作用域（ Scope ）是 <strong><code>singleton</code></strong> ，就是单实例的；如果显式声明作用域为 <strong><code>prototype</code></strong> ，那 Bean 的作用域就会变为每次获取都是一个新的，即原型 Bean 。这个知识点本应该在 SpringFramework 最基础阶段就应该知道的，咱也不多啰嗦。关键的问题是，如果我定义的 Bean 声明了 prototype ，那 SpringFramework 肯定知道我要搞原型 Bean ；但我定义 Bean 的时候没声明 Scope ，它怎么就给我默认成单实例的呢？</p><p>下面咱先从最熟悉的 Bean 注册场景出发。（原型模式相对简单，内容已穿插在解释单例模式之中）</p><h4 id="Bean的注册"><a href="#Bean的注册" class="headerlink" title="Bean的注册"></a>Bean的注册</h4><h5 id="xml方式注册Bean"><a href="#xml方式注册Bean" class="headerlink" title="xml方式注册Bean"></a>xml方式注册Bean</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.demo.bean.Person"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span></pre></td></tr></table></figure><p>这是最最简单的 Bean 的注册了，这里面如果显式声明了 <code>scope=&quot;singleton&quot;</code> 后，IDE 会报黄（警告）：</p><p><img src="/2020/06/09/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8A]/Snipaste_2020-06-09_10-03-38.png" alt></p><p>很明显它提示了默认值就是 <code>singleton</code> ，咱没必要再主动声明了。这个提示是 IDEA 智能识别的，咱不好找出处，不过咱可以点进去这个 scope ，看一眼 xsd 中的注释：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"scope"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">The scope of this bean: typically "singleton" (one shared instance,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">which will be returned by all calls to getBean with the given id), ......</span></pre></td></tr></table></figure><p>很明显文档注释的第一句就说了：<strong>通常它是 <code>singleton</code> 的</strong>。</p><h5 id="注解驱动注册Bean"><a href="#注解驱动注册Bean" class="headerlink" title="注解驱动注册Bean"></a>注解驱动注册Bean</h5><p>注解驱动的方式，都是使用一个 <code>@Scope</code> 注解来声明作用域的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>点开 <code>@Scope</code> 注解看源码，可以发现只标注 <code>@Scope</code> 注解，不声明作用域，默认值是空字符串（不是 <code>singleton</code> ）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scope &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"scopeName"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span></pre></td></tr></table></figure><p>这个地方可能就会有疑惑了，它声明的是空字符串，可是在 xml 中我配置的是 <code>singleton</code> 啊，这怎么不一样呢？莫慌，下面咱来解析这其中的原因。</p><h5 id="默认的作用域标注"><a href="#默认的作用域标注" class="headerlink" title="默认的作用域标注"></a>默认的作用域标注</h5><p>对 SpringFramework 有一些深入了解的小伙伴应该能意识到我接下来要说什么了：<strong><code>BeanDefinition</code></strong> 。所有 Bean 的定义信息都被 SpringFramework 封装到 <code>BeanDefinition</code> 中了，而作用域的定义就在 <code>BeanDefinition</code> 的抽象实现类 <strong><code>AbstractBeanDefinition</code></strong> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanMetadataAttributeAccessor</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BeanDefinition</span>, <span class="title">Cloneable</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCOPE_DEFAULT = <span class="string">""</span>;</span></pre></td></tr></table></figure><p>这里面一上来就声明了默认的作用域就是空字符串，不是 <code>singleton</code> 。</p><p>这个时候可能有的小伙伴就更迷惑了，这里面它都声明了单实例 Bean 是空字符串，那 <code>singleton</code> 还有个卵用呢？判断单实例 Bean 不是应该看作用域是否为 <code>singleton</code> 吗？</p><p>哎，说到这里了，那咱就看看 <code>BeanDefinition</code> 中是如何获取作用域的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getScope</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.scope;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>获取作用域的方式非常简单，这个没啥看的。但是！！！注意继续往下翻，紧跟着下面有一个方法叫 <strong><code>isSingleton</code></strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Return whether this a &lt;b&gt;Singleton&lt;/b&gt;, with a single shared instance</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * returned from all calls.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@see</span> #SCOPE_SINGLETON</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> SCOPE_SINGLETON.equals(<span class="keyword">this</span>.scope) || SCOPE_DEFAULT.equals(<span class="keyword">this</span>.scope);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看这里面的判断，它分为了两个部分：<strong>是否是 singleton ，或者是否为空串！</strong>那这就说得过去了吧，人家设置成空串，意义上也是单实例 Bean 。</p><h4 id="Bean的实例化"><a href="#Bean的实例化" class="headerlink" title="Bean的实例化"></a>Bean的实例化</h4><p>上面咱也知道了，默认情况下 Bean 是单实例的，那 SpringFramework 在 IOC 容器初始化的时候，是如何知道这些 Bean 是否是单实例的，同时初始化并保存的呢？下面咱跟进底层初始化逻辑中看一眼。</p><blockquote><p>本部分只粗略介绍 Bean 的初始化流程，详细的解析可以参照我的 SpringBoot 源码小册 14 章详细学习。</p></blockquote><p>在 <code>AbstractBeanFactory</code> 中，<code>getBean</code> 方法会调用到 <strong><code>doGetBean</code></strong> ，这个方法的篇幅非常长，这里只剪出框框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    Object bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 最开始先检查单实例对象缓存池中是否已经有对应的bean了</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    Object sharedInstance = getSingleton(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 检查 ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Create bean instance.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 单实例Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                    &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 原型Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// It's a prototype -&gt; create a new instance.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                    beforePrototypeCreation(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// 必定创建全新的对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">                    afterPrototypeCreation(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 自定义scope</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">                String scopeName = mbd.getScope();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (T) bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>仔细阅读这个框框流程，一上来它就要先检查单实例对象的缓存池中是否有现成的 Bean 了，没有再往下走。那咱说创建流程的话还是往下走，在 else 块的 try 部分，它会取出当前 Bean 的 <code>BeanDefinition</code> 来判断作用域：如果是 <strong>singleton 单实例</strong>的，就<strong>执行 <code>getSingleton</code> 方法创建单实例对象</strong>（底层走 lambda 表达式中的 <code>createBean</code> 方法）；如果是 <strong>prototype</strong> 原型 Bean ，就执行原型 Bean 的创建流程（直接创建）；如果这些都不是，那就可以认定为<strong>自定义 scope</strong> ，使用特殊的初始化流程。</p><p>所以由此看下来，单实例 Bean 的创建核心方法还是 <code>getSingleton</code> 了，那咱就进到这里面看一眼：（还是只有大框框的流程哈）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 检查</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                singletonObject = singletonFactory.getObject();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                newSingleton = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="comment">// catch finally ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                addSingleton(beanName, singletonObject);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> singletonObject;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>注意看这里面的设计：它会先去单实例对象缓存池中找是否已经有对应的 bean 了，如果没有，就执行创建 bean 的动作。在<strong>创建完成后</strong>，它还会<strong>将 bean 放入缓存池</strong>中，这样以后再取的时候就不会再二次创建了。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>所以这里面的核心逻辑也就可以总结出来了：</p><p><strong>SpringFramework 中实现的单例模式，是在 <code>BeanDefinition</code> 中默认配置 singleton 的作用域，在 IOC 容器初始化阶段，将 Bean 创建好，放入单实例对象缓存池（ <code>singletonObjects</code> ）中，实现 Bean 的单实例。</strong></p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>提起工厂模式，在 SpringFramework 中最容易联想到的就是 <code>FactoryBean</code> 了吧！但其实 SpringFramework 中不止这一个是工厂，还有很多种其他的，下面咱来列举。</p><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p><code>FactoryBean</code> 本身是一个接口，它本身就是一个创建对象的工厂。如果一个类实现了 <code>FactoryBean</code> 接口，则它本身将不再是一个普通的 bean 对象，不会在实际的业务逻辑中起作用，而是由创建的对象来起作用。</p><p><code>FactoryBean</code> 接口有三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回创建的对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回创建的对象的类型（即泛型类型）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    Class&lt;?&gt; getObjectType();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 创建的对象是单实例Bean还是原型Bean，默认单实例</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h4><p>这种方式很像咱在最开始学习<strong>简单工厂模式</strong>中看到的核心工厂，比方说下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 简单工厂</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calculator <span class="title">getCalculator</span><span class="params">(String operationType)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">switch</span> (operationType) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> AddCalculator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SubtractCalculator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">default</span>: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 静态工厂</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calculator <span class="title">getAddCalculator</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AddCalculator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在 SpringFramework 中使用静态工厂，就没有参数这个说法了，只需要声明工厂类和方法即可（所以上面的工厂中我额外写了一个方法）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"addCalculator"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.bean.CalculatorFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAddCalculator"</span>/&gt;</span></span></pre></td></tr></table></figure><p>这样注册后得到的 bean ，类型是 <code>AddCalculator</code> 。</p><h4 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h4><p>实例工厂的使用方式与静态工厂很像，只不过<strong>静态工厂本身不会注册到 IOC 容器中，但实例工厂会一起注册到 IOC 容器</strong>。</p><p>调整上面的代码，就可以实现实例工厂的 Bean 注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 工厂方法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Calculator <span class="title">getAddCalculator</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AddCalculator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"calculatorFactory"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.bean.CalculatorFactory"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"addCalculator"</span> <span class="attr">factory-bean</span>=<span class="string">"calculatorFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAddCalculator"</span>/&gt;</span></span></pre></td></tr></table></figure><h4 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h4><p>这个类型可能有些小伙伴会感觉有些陌生，所以我放到了最后写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>结构比 <code>FactoryBean</code> 简单，当然也可以简单地将其理解为 <code>FactoryBean</code> ，但又与其不同。<code>ObjectFactory</code> 一般情况下会<strong>作为一个 Bean 注入到其他 Bean 中</strong>，在需要用对应的 bean 时主动调用 <code>ObjectFactory</code> 的 <code>getObject</code> 方法<strong>获取真正需要的 Bean</strong> ；<code>FactoryBean</code> 的 <code>getObject</code> 方法是在 SpringFramework 初始化 Bean 时调用的，所以由此也可以知道两者的<strong>调用时机也不一样</strong>。</p><p>其实这个接口在上面看 <strong>Bean 的实例化过程</strong>中就遇到过了，在 <code>getSingleton</code> 的两参数方法中，第二个参数就是 <code>ObjectFactory</code> 类型，由它就可以调用 <code>createBean</code> 创建出单实例对象。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中的工厂模式包括内置的 <code>FactoryBean</code> 、<code>ObjectFactory</code> ，以及自定义声明的静态工厂、实例工厂。</strong></p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>咱都知道，SpringFramework 的两大核心：IOC 、AOP ，AOP 就是体现了代理模式的使用。不过如果只说 AOP 体现了代理模式，那这个也太没水准了，咱要回答的更多更全，才能让面试官意识到你真的有研究过，你真的很懂！</p><h4 id="AOP的底层实现"><a href="#AOP的底层实现" class="headerlink" title="AOP的底层实现"></a>AOP的底层实现</h4><p>SpringFramework 中对 Bean 进行 AOP 增强生成代理对象，核心是一个 <code>BeanPostProcessor</code> ：<strong><code>AnnotationAwareAspectJAutoProxyCreator</code></strong> ，这个名字很长，不过很好记：</p><ul><li>Annotation：注解式，</li><li>Aware：注入式</li><li>AspectJ：基于 AspectJ 的 AOP</li><li>AutoProxy：自动代理</li><li>Creator：创建器</li></ul><p>这样一拆分，是不是感觉容易理解多了呢？</p><p>它的核心作用方法是父类 <code>AbstractAutoProxyCreator</code> 的 <strong><code>postProcessAfterInitialization</code></strong> 方法，底层会调用 <code>wrapIfNessary</code> 方法创建代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 创建AOP代理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>至于再往底下，这个就麻烦大了，这里简单总结一下吧，详尽的代理对象创建可以参考 SpringBoot 源码小册的 19 章学习。</p><p><strong>被 AOP 增强的 Bean ，会在初始化阶段（此时对象已经创建）被 <code>AnnotationAwareAspectJAutoProxyCreator</code> 处理，整合该 Bean 可能被覆盖到的切面，最终根据 Bean 是否有接口实现，采用 jdk 动态代理或者 Cglib 动态代理构建生成代理对象。</strong></p><h4 id="代理对象的创建"><a href="#代理对象的创建" class="headerlink" title="代理对象的创建"></a>代理对象的创建</h4><p>上面的总结中提到了最终的动态代理创建，这里可以带小伙伴看一眼最底层你们熟悉的创建代理对象的源码。</p><p>jdk 动态代理的创建，在 <strong><code>JdkDynamicAopProxy</code></strong> 中，有一个 <code>getProxy</code> 方法，底层实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        logger.trace(<span class="string">"Creating JDK dynamic proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// jdk原生方法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看最后一句，是不是突然熟悉了！这个地方就可以在面试中拿出来吹一吹，这样面试官可能就真的认为你把这部分原理都搞明白了哦（狗头）。</p><p>Cglib 动态代理的创建，在 <code>CglibAopProxy</code> 的 <code>createProxyClassAndInstance</code> 方法中有创建代理对象的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    enhancer.setInterceptDuringConstruction(<span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    enhancer.setCallbacks(callbacks);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.constructorArgTypes != <span class="keyword">null</span> ?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            enhancer.create(<span class="keyword">this</span>.constructorArgTypes, <span class="keyword">this</span>.constructorArgs) :</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            enhancer.create());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看到这里的 <code>Enhancer#create()</code> 方法，是不是又是熟悉的一幕呢？所以由此也知道，框架也只是在咱学过的基础上层层包装增强罢了，最底层的还是不变的。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中的代理模式体现在 AOP 上，它通过后置处理器，整合切面（增强器 Advice ）的逻辑，将原有的 Bean （目标对象 Target ）使用 jdk 或者 Cglib 动态代理增强为代理 Bean 。</strong></p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>说起 SpringFramework 中实现的策略模式，其实刚刚就提到了：AOP 生成代理对象时，会<strong>根据原始 Bean 是否有接口实现，决定使用 jdk 动态代理还是 Cglib 动态代理</strong>，这就是典型的策略模式体现。</p><p>直接说原理吧，在 <code>DefaultAopProxyFactory</code> 中有策略模式的体现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                    <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 策略判断</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>中间的这个判断当前要代理的目标对象，类型是否是一个接口，或者目标对象是否为一个代理类。如果是二者之一，则可以直接使用 jdk 的动态代理即可，否则才会使用 Cglib 代理。</p><p>【篇幅限制，剩余 6 个设计模式的体现会放在下篇介绍 ~ 小伙伴们记得关注点赞呀，有源码学习需要的可以看我小册 ~ 奥利给】</p>]]></content>
    
    <summary type="html">
    
      本文的主题：Spring 中涉及到的设计模式，如何在面试中回答的尽可能全面、准确、有深度。
    
    </summary>
    
    
      <category term="SpringFramework" scheme="http://yoursite.com/categories/SpringFramework/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring的IOC，你真的能解释清楚吗？</title>
    <link href="http://yoursite.com/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/</id>
    <published>2020-05-18T04:50:55.000Z</published>
    <updated>2020-06-28T07:06:38.928Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，SpringFramework 作为 Java 企业级开发的老大哥，面试中也常被问到。虽说有些基础性的问题可能不那么特别被面试官和求职者重视，但如果真的问起来，能不能回答的准确、全面、有深度，还是很容易体现出水平的。</p><p>在接下来的一个系列中，我会慢慢盘点一些 Spring 中常见但不好回答全面的问题，跟小伙伴们分享。</p><p>本文主题：Spring 的 IOC 如何回答的尽可能全面、准确、有深度。</p><h2 id="问：什么是IOC？"><a href="#问：什么是IOC？" class="headerlink" title="问：什么是IOC？"></a>问：什么是IOC？</h2><p>这是一个看上去特别简单、感觉很无脑的问题，很多求职者在回答这个问题时会不加思考、快速回答出一个很简单但同时也没有什么含量的答案。</p><h4 id="草率的回答"><a href="#草率的回答" class="headerlink" title="草率的回答"></a>草率的回答</h4><ul><li>IOC 是控制反转，Inverse of Control 。</li></ul><p>试问一句，亲，你在做名词翻译吗？</p><p><img src="/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/%E8%A1%A8%E6%83%85%E5%8C%85-%EF%BC%9F%EF%BC%9F%EF%BC%9F.jpg" alt></p><p>就算真的是在做名词翻译，也不应该只是把这个简称的全称解释出来就完事吧，好歹的展开解释点东西也好吧，作为<strong>面试官不应该只想听到这么一点点</strong>吧。</p><h4 id="方向偏了"><a href="#方向偏了" class="headerlink" title="方向偏了"></a>方向偏了</h4><ul><li>IOC 是控制反转，它把对象间的依赖关系的维护权利交给了 Spring ，程序本身不再维护。</li></ul><p>这里面大体上把 IOC 的核心思想解释出来了：<strong>对象间的依赖关系的维护权利发生了转移</strong>，但是请小伙伴们注意，我们在问 IOC ，<strong>这个问题仅仅是问 IOC 本身，与具体的技术无关</strong>。<strong>IOC 不止有 Spring</strong> ，只是当下最强大的、使用最广的是 Spring 而已。</p><p>所以小伙伴们在<strong>回答理论、概念等问题时，不要直接在概念解释中提到具体的技术，技术都是概念和理论的落地实现，不止一种</strong>。单把一种拉出来，面试官可能会觉得：你是不是只知道这个？</p><h4 id="一种参考回答"><a href="#一种参考回答" class="headerlink" title="一种参考回答"></a>一种参考回答</h4><blockquote><p>该答案仅供参考，可根据自身的知识储备动态调整。</p></blockquote><p>IOC 全名<strong>控制反转</strong> Inverse of Control，它是一种<strong>编程原则</strong>，它的设计和架构可以实现<strong>组件间的解耦</strong>，核心思想是<strong>将控制权转移出去</strong>。</p><p>这里面提到了几个点：</p><ul><li>编程原则：它是一种<strong>理论</strong>，而非具体的某种技术落地</li><li>组件间的解耦：所谓<strong>耦合</strong>，就是上面提到的<strong>对象间的依赖关系</strong>；<strong>解耦</strong>，就是<strong>解除了对象间的依赖关系</strong>。<ul><li>提到解耦，有可能面试官会继续问“什么是解耦”，也有可能不会问 “为什么用 Spring ”了</li></ul></li><li>控制权的转移：IOC 为了实现解耦，将原有的对象间的<strong>主动依赖改为被动接收型依赖</strong>（由直接 new 变为 set ）</li></ul><h2 id="问：IOC与DI的区别"><a href="#问：IOC与DI的区别" class="headerlink" title="问：IOC与DI的区别"></a>问：IOC与DI的区别</h2><p>如果对 IOC 的实现不是特别了解，或者只是用 SpringFramework 用的太习惯了，亦或是刻板的学习 SpringFramework ，那这个答案通常会是这样的：</p><ul><li>IOC 就是 DI 。</li></ul><p>如果回答出这个答案，而面试官碰巧也跟你一样，那恭喜你“瞎猫碰到死耗子”了！因为这个回答真的<strong>大错特错</strong>啊，IOC 不止有 DI 的！</p><p>正确的回答应该是：</p><ul><li><strong>IOC 是一种思想、编程原则，DI 是 IOC 思想的一种实现方式。</strong></li><li><strong>IOC 的实现方式有依赖查找（ Dependency lookup ）和依赖注入（ Dependency Injection ）。</strong></li></ul><p>上面已经介绍过了，IOC 仅仅是一种思想，它的意图是想让对象间的依赖控制发生转换。用过 SpringFramework 的小伙伴都知道，你没有在哪个地方见过直接写 IOC 的代码，都是由一些实现方式来体现 IOC 的。</p><p>如果按照上面这样回答，可能会引来下面一个问题：</p><h3 id="依赖查找和依赖注入分别都是什么？如何区分它们？"><a href="#依赖查找和依赖注入分别都是什么？如何区分它们？" class="headerlink" title="依赖查找和依赖注入分别都是什么？如何区分它们？"></a>依赖查找和依赖注入分别都是什么？如何区分它们？</h3><p>针对这个问题，最好不要一上来就搬出代码解释，最好是先理论后代码。</p><p>一般情况下，对比依赖查找和依赖注入，通常可以从以下几个维度对比：</p><table><thead><tr><th></th><th>依赖查找</th><th>依赖注入</th></tr></thead><tbody><tr><td>实现方式</td><td>使用上下文（容器）主动获取</td><td>依赖上下文被动接收</td></tr><tr><td>作用目标</td><td>通常是方法体内的局部变量，也可以是对象成员</td><td>通常是对象成员</td></tr><tr><td>API依赖</td><td>依赖 IOC 框架的 API（必须操纵容器的 API ）</td><td>可以不依赖（暴露 setter 方法即可）</td></tr><tr><td></td><td>applicationContext.getBean(beanName)</td><td>public void setXXX() { … }</td></tr></tbody></table><h2 id="问：SpringFramework中实现的IOC有什么？"><a href="#问：SpringFramework中实现的IOC有什么？" class="headerlink" title="问：SpringFramework中实现的IOC有什么？"></a>问：SpringFramework中实现的IOC有什么？</h2><p>真的不会有小伙伴只能答出 <code>ApplicationContext</code> 吧，一开始学的时候应该知道还有个 <code>BeanFactory</code> 吧。这是 SpringFramework 中两个核心的 IOC 容器的抽象。<code>BeanFactory</code> 仅仅是提供了一个容器管理的基本能力，<code>ApplicationContext</code> 在此基础上做了更加完善、强大的扩展。具体的对比可以参照下表：</p><table><thead><tr><th align="left">Feature</th><th align="left"><code>BeanFactory</code></th><th align="left"><code>ApplicationContext</code></th></tr></thead><tbody><tr><td align="left">Bean instantiation/wiring —— Bean的实例化和属性注入</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Integrated lifecycle management —— 生命周期管理</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Automatic <code>BeanPostProcessor</code> registration —— Bean后置处理器的支持</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Automatic <code>BeanFactoryPostProcessor</code> registration —— BeanFactory后置处理器的支持</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Convenient <code>MessageSource</code> access (for internalization) —— 消息转换服务（国际化）</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Built-in <code>ApplicationEvent</code> publication mechanism —— 事件发布机制（事件驱动）</td><td align="left">No</td><td align="left">Yes</td></tr></tbody></table><p>下面提供一个比较完整的示例答案，小伙伴们可以根据自己的知识储备和理解，调整这里面的一些描述细节：</p><p><code>BeanFactory</code> 接口提供了一个<strong>抽象的配置和对象的管理机制</strong>，<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口，它<strong>简化了与 AOP 的整合、消息机制、事件机制</strong>，以及<strong>对 Web 环境的扩展</strong>（ <code>WebApplicationContext</code> 等），<code>BeanFactory</code> 是没有这些扩展的。</p><p><code>ApplicationContext</code> 主要扩展了以下功能：（括号内的部分是解释扩展功能的一些简单描述或者原理底层实现，能回答出来更好）</p><ul><li><strong>AOP的支持</strong>（ <code>AnnotationAwareAspectJAutoProxyCreator</code> 作用于 Bean 的初始化之后 ）</li><li><strong>配置元信息</strong>（ <code>BeanDefinition</code> 、<code>Environment</code> 、注解等 ）</li><li><strong>资源管理</strong>（ <code>Resource</code> 抽象 ）</li><li><strong>事件驱动机制</strong>（ <code>ApplicationEvent</code> 、<code>ApplicationListener</code> ）</li><li><strong>消息与国际化</strong>（ <code>LocaleResolver</code> ）</li><li><strong><code>Environment</code> 抽象</strong>（SpringFramework 3.1以后）</li></ul><h2 id="问：依赖注入的注入方式？有什么区别？"><a href="#问：依赖注入的注入方式？有什么区别？" class="headerlink" title="问：依赖注入的注入方式？有什么区别？"></a>问：依赖注入的注入方式？有什么区别？</h2><p>注意这个问题也是与 SpringFramework 无关的，注入的方式本身就应该是依赖注入的实现，至于框架的代码，那是人家对于这个方式的落地。</p><p>可从以下几个维度对比：</p><table><thead><tr><th>注入方式</th><th>被注入成员是否可变</th><th>是否依赖IOC框架的API</th><th>使用场景</th></tr></thead><tbody><tr><td>构造器注入</td><td>不可变</td><td>否（xml、编程式注入不依赖）</td><td>不可变的固定注入</td></tr><tr><td>参数注入</td><td>不可变</td><td>是（只能通过标注注解来侵入式注入）</td><td>通常用于不可变的固定注入</td></tr><tr><td>setter注入</td><td>可变</td><td>否（xml、编程式注入不依赖）</td><td>可选属性的注入</td></tr></tbody></table><p>基本上问这个问题的话，还可能会继续问另一个问题：</p><h3 id="你觉得哪种方式好？为什么？"><a href="#你觉得哪种方式好？为什么？" class="headerlink" title="你觉得哪种方式好？为什么？"></a>你觉得哪种方式好？为什么？</h3><p>“莽夫”应聘者一看终于来开放式问题了，赶紧开始自由发挥了：</p><blockquote><p>我觉得参数注入好，因为我写习惯了，给参数打注解多舒服啊！</p></blockquote><p>你是这么说了，面试官咋想：就这？就这？？？进而对你的印象可能就会有所减分了。</p><p>这种问题，除了要表述主观看法之外，更多的是要<strong>根据一些既有的论述来辅助你的观点</strong>，最好的论述那一定是官方文档了。</p><p>SpringFramework 的官方文档在不同的版本推荐的注入方式是不同的：</p><ul><li>SpringFramework <strong>4.0.2</strong> 及之前是推荐 setter 注入，理由是<strong>一个 Bean 有多个依赖时，构造器的参数列表会很长</strong>；而且如果 <strong>Bean 中依赖的属性不都是必需的话，注入会变得更麻烦</strong>；</li><li><strong>4.0.3</strong> 及以后官方推荐构造器注入，理由是<strong>构造器注入的依赖是不可变的、完全初始化好的，且可以保证不为 null</strong> ；</li><li>当然 <strong>4.0.3</strong> 及以后的官方文档中也说了，如果<strong>真的出现构造器参数列表过长的情况，可能是这个 Bean 承担的责任太多，应该考虑组件的责任拆解</strong>。</li></ul><h2 id="问：组件注入的注解有什么？有什么区别？"><a href="#问：组件注入的注解有什么？有什么区别？" class="headerlink" title="问：组件注入的注解有什么？有什么区别？"></a>问：组件注入的注解有什么？有什么区别？</h2><p>相信大多数小伙伴都能答出 <code>@Autowired</code> 和 <code>@Resource</code> 吧，如果答出这两个，那证明你应该用过，也会用。但你能回答出 <code>@Inject</code> ，证明你对这些注入的注解确实有了解。作为应聘者，在回答问题时一定是回答的<strong>尽可能全面</strong>为好，下面对这几种注解作一个对比：</p><table><thead><tr><th>注解</th><th>注入方式</th><th>是否支持@Primary</th><th>来源</th><th>Bean不存在时处理</th></tr></thead><tbody><tr><td>@Autowired</td><td>根据类型注入</td><td>是</td><td>SpringFramework原生注解</td><td>可指定 required=false 来避免注入失败</td></tr><tr><td>@Resource</td><td>根据名称注入</td><td>否</td><td>JSR250规范</td><td>容器中不存在指定Bean会抛出异常</td></tr><tr><td>@Inject</td><td>根据类型注入</td><td>是</td><td>JSR330规范 ( 需要导jar包 )</td><td>容器中不存在指定Bean会抛出异常</td></tr></tbody></table><p>跟上面差不多，如果问到了这个问题，那就有可能继续被问到下面一个问题：</p><h3 id="存在多个相同类型Bean时如何解决注入问题？"><a href="#存在多个相同类型Bean时如何解决注入问题？" class="headerlink" title="存在多个相同类型Bean时如何解决注入问题？"></a>存在多个相同类型Bean时如何解决注入问题？</h3><p>可能大多数小伙伴都能答出以下几种解决方案：</p><ul><li><code>@Resource</code> ：根据名称指定注入的 Bean</li><li><code>@Qualifier</code> ：配合 <code>@Autowired</code> 注解使用，如果被标注的成员 / 方法在根据类型注入时发现有多个相同类型的 Bean ，则会根据该注解声明的 name 寻找特定的 bean</li><li><code>@Primary</code> ：配合 <code>@Bean</code> 注解使用，如果有多个相同类型的 Bean 同时注册到 IOC 容器中，使用 <code>@Autowired</code> 、<code>@Inject</code> 注解时会注入标注 <code>@Primary</code> 注解的 bean</li></ul><p>其实你还可以提另外一种方案：把<strong>注入的字段名与 bean 的名称保持一致</strong>，这样也可以解决注入时报不唯一 Bean 的问题。</p><p>以上几个问题是关于 SpringFramework 与 IOC 部分的一些常见问题，倒是问题都不太陌生，但是小伙伴们想回答的全面、有深度，还是需要下下功夫的。希望小伙伴们能有所收获，在面试中流利回答，斩获 offer ！</p><hr><p>问题整理不易，不点个赞支持一下作者吗？（可怜巴巴）</p>]]></content>
    
    <summary type="html">
    
      一直以来，SpringFramework 作为 Java 企业级开发的老大哥，面试中也常被问到。本文主题：Spring 的 IOC 如何回答的尽可能全面、准确、有深度。
    
    </summary>
    
    
      <category term="SpringFramework" scheme="http://yoursite.com/categories/SpringFramework/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="IOC" scheme="http://yoursite.com/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式容器：嵌入式Tomcat的优化和配置</title>
    <link href="http://yoursite.com/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/</id>
    <published>2019-12-02T12:17:59.000Z</published>
    <updated>2020-06-28T07:07:39.607Z</updated>
    
    <content type="html"><![CDATA[<p>在以往的开发中我们可能会根据项目本身对 Tomcat 进行一些调整，以达到最大化利用 Tomcat 的目的。SpringBoot 使用嵌入式 Tomcat，再像之前那样做 Tomcat 性能调优就显得不那么现实了，为此我们需要了解如何在 SpringBoot 内部给嵌入式 Tomcat 做性能调优。本篇文章只做定<strong>性</strong>的解析，深入到<strong>量</strong>的控制本文不作详细探讨。</p><h2 id="0-调优前的准备"><a href="#0-调优前的准备" class="headerlink" title="0. 调优前的准备"></a>0. 调优前的准备</h2><p>为测试当前 SpringBoot 中嵌入式 Tomcat 的最大性能，需要一个压力测试工具来辅助我们测试性能，目前应用比较多的压测工具有 <strong>Bench</strong> 和 <strong>JMeter</strong> ，本文中使用 <code>Bench</code> 作为压测工具。</p><p>测试之前，咱先把工具准备好：</p><ul><li>Bench：<a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">https://www.apachelounge.com/download/</a></li><li>JMeter：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></li></ul><p>下载好之后，把这两个工具的环境变量都配置好，方便直接从控制台执行。</p><p>除此之外，把一开始的测试工程中加入一个测试的 <code>DemoController</code> ，用于接收请求压测（为模拟真实业务场景，会在 <code>DemoController</code> 中让线程随机阻塞 <code>100 - 500ms</code> ，以代替数据库连接和业务查询）。最后，把工程打成可执行jar包并启动，等待测试。</p><p>jar包启动的方式非常简单：<code>java -jar demo-0.0.1-SNAPSHOT.jar</code> </p><p>（本文在进行压测时的物理环境：Windows10 + Intel Core i7-8750H）</p><h2 id="1-使用Bench进行压测"><a href="#1-使用Bench进行压测" class="headerlink" title="1. 使用Bench进行压测"></a>1. 使用Bench进行压测</h2><p>在cmd中执行如下命令：</p><p><code>ab -n 10000 -c 500 http://localhost:8080/test</code></p><p>执行完成后会在控制台打印测试报告：（<strong>报告中的指标解释已标注在行尾</strong>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">This</span> <span class="string">is</span> <span class="string">ApacheBench,</span> <span class="string">Version</span> <span class="number">2.3</span> <span class="string">&lt;$Revision:</span> <span class="number">1843412</span> <span class="string">$&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">Copyright</span> <span class="number">1996</span> <span class="string">Adam</span> <span class="string">Twiss,</span> <span class="string">Zeus</span> <span class="string">Technology</span> <span class="string">Ltd,</span> <span class="string">http://www.zeustech.net/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="string">Licensed</span> <span class="string">to</span> <span class="string">The</span> <span class="string">Apache</span> <span class="string">Software</span> <span class="string">Foundation,</span> <span class="string">http://www.apache.org/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">Benchmarking</span> <span class="string">localhost</span> <span class="string">(be</span> <span class="string">patient)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">1000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">2000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">3000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">4000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">5000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">6000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">7000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">8000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">9000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">10000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="string">Finished</span> <span class="number">10000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Server Software:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Server Hostname:</span>        <span class="string">localhost</span> <span class="string">//</span> <span class="string">主机名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Server Port:</span>            <span class="number">8080</span>      <span class="string">//</span> <span class="string">端口号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Document Path:</span>          <span class="string">/test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Document Length:</span>        <span class="number">4</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">500</span>            <span class="string">//</span> <span class="string">并发量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">15.670</span> <span class="string">seconds</span> <span class="string">//</span> <span class="string">所有请求的总耗时</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">10000</span>          <span class="string">//</span> <span class="string">成功的请求数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">1360000</span> <span class="string">bytes</span>  <span class="string">//</span> <span class="string">总传输数据量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">40000</span> <span class="string">bytes</span>    <span class="string">//</span> <span class="string">总响应数据量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">638.17</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span> <span class="string">//</span> <span class="string">【重要】每秒执行的请求数量（吞吐量）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">783.493</span> <span class="string">[ms]</span> <span class="string">(mean)</span>   <span class="string">//</span> <span class="string">【重要】客户端平均响应时间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">1.567</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span> <span class="string">//</span> <span class="string">服务器平均请求等待时间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">84.76</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span> <span class="string">//</span> <span class="string">每秒传输的数据量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="string">Connection</span> <span class="string">Times</span> <span class="string">(ms)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">              <span class="string">min</span>  <span class="string">mean[+/-sd]</span> <span class="string">median</span>   <span class="string">max</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Connect:</span>        <span class="number">0</span>    <span class="number">0</span>   <span class="number">0.2</span>      <span class="number">0</span>       <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Processing:</span>   <span class="number">105</span>  <span class="number">738</span> <span class="number">135.1</span>    <span class="number">742</span>     <span class="number">993</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Waiting:</span>      <span class="number">105</span>  <span class="number">738</span> <span class="number">135.2</span>    <span class="number">742</span>     <span class="number">993</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total:</span>        <span class="number">105</span>  <span class="number">738</span> <span class="number">135.1</span>    <span class="number">742</span>     <span class="number">993</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="string">Percentage</span> <span class="string">of</span> <span class="string">the</span> <span class="string">requests</span> <span class="string">served</span> <span class="string">within</span> <span class="string">a</span> <span class="string">certain</span> <span class="string">time</span> <span class="string">(ms)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">  <span class="number">50</span><span class="string">%</span>    <span class="number">742</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">  <span class="number">66</span><span class="string">%</span>    <span class="number">810</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">  <span class="number">75</span><span class="string">%</span>    <span class="number">847</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">  <span class="number">80</span><span class="string">%</span>    <span class="number">868</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">  <span class="number">90</span><span class="string">%</span>    <span class="number">909</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">  <span class="number">95</span><span class="string">%</span>    <span class="number">931</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">  <span class="number">98</span><span class="string">%</span>    <span class="number">945</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">  <span class="number">99</span><span class="string">%</span>    <span class="number">952</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"> <span class="number">100</span><span class="string">%</span>    <span class="number">993</span> <span class="string">(longest</span> <span class="string">request)</span></span></pre></td></tr></table></figure><p>在测试报告中有两个重要的指标需要咱来关注：</p><ul><li><strong>Requests per second</strong>：每秒执行的请求数量（吞吐量）<ul><li>吞吐量越高，代表性能越好</li></ul></li><li><strong>Time per request</strong>：客户端平均响应时间<ul><li>响应时间越短，代表性能越好</li></ul></li></ul><p>在这里面测得的结果是 638.17 的吞吐量，783.493ms 的平均响应时间，这个响应时间比代码中控制的阻塞时间更长，说明 Tomcat 对500的并发已经有一些吃力了。</p><p>下面咱再用更大的并发量来测试效果：</p><p><code>ab -n 50000 -c 2000 http://localhost:8080/test</code></p><p>测得的结果（截取主要部分）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">75.689</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">660.60</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">3027.564</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">1.514</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">87.74</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>发现<strong>吞吐量没有什么太大的变化</strong>，但<strong>平均响应时间大幅提升，且大概为上面的4倍</strong>。可以看得出来，Tomcat 的处理速度已经远远跟不上请求到来的速度，需要进行性能调优。</p><h2 id="2-嵌入式Tomcat调优依据"><a href="#2-嵌入式Tomcat调优依据" class="headerlink" title="2. 嵌入式Tomcat调优依据"></a>2. 嵌入式Tomcat调优依据</h2><p>调优一定要有依据，咱根据现状和之前对 SpringBoot 的学习和原理剖析，应该知道配置大多都是两种形式：</p><ul><li>声明式配置：<code>application.properties</code> 或 <code>application.yml</code></li><li>编程式配置：<code>XXXConfigurer</code> 或 <code>XXXCustomizer</code></li></ul><p>其中，利用配置文件进行配置，最终会映射到 SpringBoot 中的一些 Properties 类中，例如 <code>server.port</code> 配置会映射到 <code>ServerProperties</code> 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"server"</span>, ignoreUnknownFields = <span class="keyword">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Integer port;</span></pre></td></tr></table></figure><p>那我们来大体分析一下对于 Tomcat 的声明式配置，都有哪些可以控制的部分：</p><h3 id="2-1-Tomcat的声明式配置"><a href="#2-1-Tomcat的声明式配置" class="headerlink" title="2.1 Tomcat的声明式配置"></a>2.1 Tomcat的声明式配置</h3><p>在 <code>ServerProperties</code> 类中，有一个 Tomcat 的静态内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Tomcat properties.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tomcat</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// ......</span></span></pre></td></tr></table></figure><p>这里面就是配置嵌入式 Tomcat 的可以供我们配置的映射配置类。咱来看里面的核心属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Maximum amount of worker threads.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 最大工作线程数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxThreads = <span class="number">200</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Minimum amount of worker threads.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 最小工作线程数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minSpareThreads = <span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Maximum number of connections that the server accepts and processes at any</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * given time. Once the limit has been reached, the operating system may still</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * accept connections based on the "acceptCount" property.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 服务器最大连接数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxConnections = <span class="number">10000</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Maximum queue length for incoming connection requests when all possible request</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * processing threads are in use.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 最大请求队列等待长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> acceptCount = <span class="number">100</span>;</span></pre></td></tr></table></figure><p>可以发现这里面的几个指标，分别控制连接数、线程数、等待数。</p><p>咱来分析为什么上面的吞吐量不够大：请求中的关键耗时动作是 <code>Thread.sheep</code> 卡线程，导致吞吐量变大。<code>Thread.sleep</code> 模拟了IO操作、数据库交互等<strong>非CPU高速计算的行为</strong>，在数据库交互时，CPU资源被浪费，导致无法处理后来的请求，出现资源利用率低的现象。为此，我们需要提高请求并发数，以此来提高CPU利用率。提高请求并发的方法在上面的几个参数中很明显是 <strong><code>maxThreads</code></strong> 。</p><h2 id="3-调整maxThreads"><a href="#3-调整maxThreads" class="headerlink" title="3. 调整maxThreads"></a>3. 调整maxThreads</h2><p>从源码中很明显看到默认的最大线程数是200，我们在 <code>application.properties</code> 中修改值为 500：</p><p><code>server.tomcat.max-threads=500</code></p><p>修改之后的测试：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">30.910</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">1617.61</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">1236.391</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">0.618</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">214.84</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>发现吞吐量有明显的提升，且吞吐量的放大倍数大概是前面线程数为 200 时的2.5倍。继续放大该值为 2000：</p><p><code>server.tomcat.max-threads=2000</code></p><p>重新测试效果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">12.050</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">4149.38</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">482.000</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">0.241</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">551.09</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>吞吐量又一次明显上升，但注意此时的吞吐量并没有扩大到上一次的 4 倍。继续放大该值为 10000：</p><p><code>server.tomcat.max-threads=10000</code></p><p>重新测试效果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">13.808</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">3621.22</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">552.300</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">0.276</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">480.94</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>发现吞吐量竟然下降了！为什么会出现这种现象呢？</p><h2 id="4-现象解释"><a href="#4-现象解释" class="headerlink" title="4. 现象解释"></a>4. 现象解释</h2><p>要解释这个原因，就不得不提到 CPU 的工作原理了。当CPU的<strong>核心线程数</strong>小于当前应用线程时，CPU为了保证所有应用线程都正常执行，它会<strong>在多个线程中来回切换</strong>，以保证每个线程都能获得CPU时间。在一个确定的时间点中，一个CPU只能处理一个线程。</p><p>所以这个现象就可以这样解释：当开启的 Tomcat 线程过多时，CPU会消耗大量时间在这些 Tomcat 线程中来回切换，导致真正处理业务请求的时间变少，最终导致整体应用处理速度变慢。</p><p>由此也可以推出另一种可能：如果业务逻辑中有大量CPU处理工作（如运算、处理数据等），则CPU需要更多的时间用于计算，此时若 Tomcat 线程过多，则处理速度会更慢。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>由上面的情况可以总结出以下结论：</p><ul><li>应用中大部分业务逻辑都是阻塞型处理（IO、数据库操作等），这种情况下CPU的压力较低，可以适当调大 <code>maxThreads</code> 的值大小。</li><li>应用中大部分业务逻辑都是数据处理和计算，这种情况下CPU的压力较大，应适当调小 <code>maxThreads</code> 的值大小。</li></ul>]]></content>
    
    <summary type="html">
    
      在以往的开发中我们可能会根据项目本身对 Tomcat 进行一些调整，以达到最大化利用 Tomcat 的目的。SpringBoot 使用嵌入式 Tomcat，再像之前那样做 Tomcat 性能调优就显得不那么现实了，为此本文解释如何在 SpringBoot 内部给嵌入式 Tomcat 做性能调优。
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
      <category term="嵌入式容器" scheme="http://yoursite.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
</feed>
