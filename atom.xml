<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LinkedBear的GitHub</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-23T06:01:04.730Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LinkedBear</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring的IOC，你真的能解释清楚吗？</title>
    <link href="http://yoursite.com/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/</id>
    <published>2020-05-18T04:50:55.000Z</published>
    <updated>2020-05-23T06:01:04.730Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，SpringFramework 作为 Java 企业级开发的老大哥，面试中也常被问到。虽说有些基础性的问题可能不那么特别被面试官和求职者重视，但如果真的问起来，能不能回答的准确、全面、有深度，还是很容易体现出水平的。</p><p>在接下来的一个系列中，我会慢慢盘点一些 Spring 中常见但不好回答全面的问题，跟小伙伴们分享。</p><p>本文主题：Spring 的 IOC 如何回答的尽可能全面、准确、有深度。</p><h2 id="问：什么是IOC？"><a href="#问：什么是IOC？" class="headerlink" title="问：什么是IOC？"></a>问：什么是IOC？</h2><p>这是一个看上去特别简单、感觉很无脑的问题，很多求职者在回答这个问题时会不加思考、快速回答出一个很简单但同时也没有什么含量的答案。</p><h4 id="草率的回答"><a href="#草率的回答" class="headerlink" title="草率的回答"></a>草率的回答</h4><ul><li>IOC 是控制反转，Inverse of Control 。</li></ul><p>试问一句，亲，你在做名词翻译吗？</p><p><img src="/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/%E8%A1%A8%E6%83%85%E5%8C%85-%EF%BC%9F%EF%BC%9F%EF%BC%9F.jpg" alt></p><p>就算真的是在做名词翻译，也不应该只是把这个简称的全称解释出来就完事吧，好歹的展开解释点东西也好吧，作为<strong>面试官不应该只想听到这么一点点</strong>吧。</p><h4 id="方向偏了"><a href="#方向偏了" class="headerlink" title="方向偏了"></a>方向偏了</h4><ul><li>IOC 是控制反转，它把对象间的依赖关系的维护权利交给了 Spring ，程序本身不再维护。</li></ul><p>这里面大体上把 IOC 的核心思想解释出来了：<strong>对象间的依赖关系的维护权利发生了转移</strong>，但是请小伙伴们注意，我们在问 IOC ，<strong>这个问题仅仅是问 IOC 本身，与具体的技术无关</strong>。<strong>IOC 不止有 Spring</strong> ，只是当下最强大的、使用最广的是 Spring 而已。</p><p>所以小伙伴们在<strong>回答理论、概念等问题时，不要直接在概念解释中提到具体的技术，技术都是概念和理论的落地实现，不止一种</strong>。单把一种拉出来，面试官可能会觉得：你是不是只知道这个？</p><h4 id="一种参考回答"><a href="#一种参考回答" class="headerlink" title="一种参考回答"></a>一种参考回答</h4><blockquote><p>该答案仅供参考，可根据自身的知识储备动态调整。</p></blockquote><p>IOC 全名<strong>控制反转</strong> Inverse of Control，它是一种<strong>编程原则</strong>，它的设计和架构可以实现<strong>组件间的解耦</strong>，核心思想是<strong>将控制权转移出去</strong>。</p><p>这里面提到了几个点：</p><ul><li>编程原则：它是一种<strong>理论</strong>，而非具体的某种技术落地</li><li>组件间的解耦：所谓<strong>耦合</strong>，就是上面提到的<strong>对象间的依赖关系</strong>；<strong>解耦</strong>，就是<strong>解除了对象间的依赖关系</strong>。<ul><li>提到解耦，有可能面试官会继续问“什么是解耦”，也有可能不会问 “为什么用 Spring ”了</li></ul></li><li>控制权的转移：IOC 为了实现解耦，将原有的对象间的<strong>主动依赖改为被动接收型依赖</strong>（由直接 new 变为 set ）</li></ul><h2 id="问：IOC与DI的区别"><a href="#问：IOC与DI的区别" class="headerlink" title="问：IOC与DI的区别"></a>问：IOC与DI的区别</h2><p>如果对 IOC 的实现不是特别了解，或者只是用 SpringFramework 用的太习惯了，亦或是刻板的学习 SpringFramework ，那这个答案通常会是这样的：</p><ul><li>IOC 就是 DI 。</li></ul><p>如果回答出这个答案，而面试官碰巧也跟你一样，那恭喜你“瞎猫碰到死耗子”了！因为这个回答真的<strong>大错特错</strong>啊，IOC 不止有 DI 的！</p><p>正确的回答应该是：</p><ul><li><strong>IOC 是一种思想、编程原则，DI 是 IOC 思想的一种实现方式。</strong></li><li><strong>IOC 的实现方式有依赖查找（ Dependency lookup ）和依赖注入（ Dependency Injection ）。</strong></li></ul><p>上面已经介绍过了，IOC 仅仅是一种思想，它的意图是想让对象间的依赖控制发生转换。用过 SpringFramework 的小伙伴都知道，你没有在哪个地方见过直接写 IOC 的代码，都是由一些实现方式来体现 IOC 的。</p><p>如果按照上面这样回答，可能会引来下面一个问题：</p><h3 id="依赖查找和依赖注入分别都是什么？如何区分它们？"><a href="#依赖查找和依赖注入分别都是什么？如何区分它们？" class="headerlink" title="依赖查找和依赖注入分别都是什么？如何区分它们？"></a>依赖查找和依赖注入分别都是什么？如何区分它们？</h3><p>针对这个问题，最好不要一上来就搬出代码解释，最好是先理论后代码。</p><p>一般情况下，对比依赖查找和依赖注入，通常可以从以下几个维度对比：</p><table><thead><tr><th></th><th>依赖查找</th><th>依赖注入</th></tr></thead><tbody><tr><td>实现方式</td><td>使用上下文（容器）主动获取</td><td>依赖上下文被动接收</td></tr><tr><td>作用目标</td><td>通常是方法体内的局部变量，也可以是对象成员</td><td>通常是对象成员</td></tr><tr><td>API依赖</td><td>依赖 IOC 框架的 API（必须操纵容器的 API ）</td><td>可以不依赖（暴露 setter 方法即可）</td></tr><tr><td></td><td>applicationContext.getBean(beanName)</td><td>public void setXXX() { … }</td></tr></tbody></table><h2 id="问：SpringFramework中实现的IOC有什么？"><a href="#问：SpringFramework中实现的IOC有什么？" class="headerlink" title="问：SpringFramework中实现的IOC有什么？"></a>问：SpringFramework中实现的IOC有什么？</h2><p>真的不会有小伙伴只能答出 <code>ApplicationContext</code> 吧，一开始学的时候应该知道还有个 <code>BeanFactory</code> 吧。这是 SpringFramework 中两个核心的 IOC 容器的抽象。<code>BeanFactory</code> 仅仅是提供了一个容器管理的基本能力，<code>ApplicationContext</code> 在此基础上做了更加完善、强大的扩展。具体的对比可以参照下表：</p><table><thead><tr><th align="left">Feature</th><th align="left"><code>BeanFactory</code></th><th align="left"><code>ApplicationContext</code></th></tr></thead><tbody><tr><td align="left">Bean instantiation/wiring —— Bean的实例化和属性注入</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Integrated lifecycle management —— 生命周期管理</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Automatic <code>BeanPostProcessor</code> registration —— Bean后置处理器的支持</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Automatic <code>BeanFactoryPostProcessor</code> registration —— BeanFactory后置处理器的支持</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Convenient <code>MessageSource</code> access (for internalization) —— 消息转换服务（国际化）</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Built-in <code>ApplicationEvent</code> publication mechanism —— 事件发布机制（事件驱动）</td><td align="left">No</td><td align="left">Yes</td></tr></tbody></table><p>下面提供一个比较完整的示例答案，小伙伴们可以根据自己的知识储备和理解，调整这里面的一些描述细节：</p><p><code>BeanFactory</code> 接口提供了一个<strong>抽象的配置和对象的管理机制</strong>，<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口，它<strong>简化了与 AOP 的整合、消息机制、事件机制</strong>，以及<strong>对 Web 环境的扩展</strong>（ <code>WebApplicationContext</code> 等），<code>BeanFactory</code> 是没有这些扩展的。</p><p><code>ApplicationContext</code> 主要扩展了以下功能：（括号内的部分是解释扩展功能的一些简单描述或者原理底层实现，能回答出来更好）</p><ul><li><strong>AOP的支持</strong>（ <code>AnnotationAwareAspectJAutoProxyCreator</code> 作用于 Bean 的初始化之后 ）</li><li><strong>配置元信息</strong>（ <code>BeanDefinition</code> 、<code>Environment</code> 、注解等 ）</li><li><strong>资源管理</strong>（ <code>Resource</code> 抽象 ）</li><li><strong>事件驱动机制</strong>（ <code>ApplicationEvent</code> 、<code>ApplicationListener</code> ）</li><li><strong>消息与国际化</strong>（ <code>LocaleResolver</code> ）</li><li><strong><code>Environment</code> 抽象</strong>（SpringFramework 3.1以后）</li></ul><h2 id="问：依赖注入的注入方式？有什么区别？"><a href="#问：依赖注入的注入方式？有什么区别？" class="headerlink" title="问：依赖注入的注入方式？有什么区别？"></a>问：依赖注入的注入方式？有什么区别？</h2><p>注意这个问题也是与 SpringFramework 无关的，注入的方式本身就应该是依赖注入的实现，至于框架的代码，那是人家对于这个方式的落地。</p><p>可从以下几个维度对比：</p><table><thead><tr><th>注入方式</th><th>被注入成员是否可变</th><th>是否依赖IOC框架的API</th><th>使用场景</th></tr></thead><tbody><tr><td>构造器注入</td><td>不可变</td><td>否（xml、编程式注入不依赖）</td><td>不可变的固定注入</td></tr><tr><td>参数注入</td><td>不可变</td><td>是（只能通过标注注解来侵入式注入）</td><td>通常用于不可变的固定注入</td></tr><tr><td>setter注入</td><td>可变</td><td>否（xml、编程式注入不依赖）</td><td>可选属性的注入</td></tr></tbody></table><p>基本上问这个问题的话，还可能会继续问另一个问题：</p><h3 id="你觉得哪种方式好？为什么？"><a href="#你觉得哪种方式好？为什么？" class="headerlink" title="你觉得哪种方式好？为什么？"></a>你觉得哪种方式好？为什么？</h3><p>“莽夫”应聘者一看终于来开放式问题了，赶紧开始自由发挥了：</p><blockquote><p>我觉得参数注入好，因为我写习惯了，给参数打注解多舒服啊！</p></blockquote><p>你是这么说了，面试官咋想：就这？就这？？？进而对你的印象可能就会有所减分了。</p><p>这种问题，除了要表述主观看法之外，更多的是要<strong>根据一些既有的论述来辅助你的观点</strong>，最好的论述那一定是官方文档了。</p><p>SpringFramework 的官方文档在不同的版本推荐的注入方式是不同的：</p><ul><li>SpringFramework <strong>4.0.2</strong> 及之前是推荐 setter 注入，理由是<strong>一个 Bean 有多个依赖时，构造器的参数列表会很长</strong>；而且如果 <strong>Bean 中依赖的属性不都是必需的话，注入会变得更麻烦</strong>；</li><li><strong>4.0.3</strong> 及以后官方推荐构造器注入，理由是<strong>构造器注入的依赖是不可变的、完全初始化好的，且可以保证不为 null</strong> ；</li><li>当然 <strong>4.0.3</strong> 及以后的官方文档中也说了，如果<strong>真的出现构造器参数列表过长的情况，可能是这个 Bean 承担的责任太多，应该考虑组件的责任拆解</strong>。</li></ul><h2 id="问：组件注入的注解有什么？有什么区别？"><a href="#问：组件注入的注解有什么？有什么区别？" class="headerlink" title="问：组件注入的注解有什么？有什么区别？"></a>问：组件注入的注解有什么？有什么区别？</h2><p>相信大多数小伙伴都能答出 <code>@Autowired</code> 和 <code>@Resource</code> 吧，如果答出这两个，那证明你应该用过，也会用。但你能回答出 <code>@Inject</code> ，证明你对这些注入的注解确实有了解。作为应聘者，在回答问题时一定是回答的<strong>尽可能全面</strong>为好，下面对这几种注解作一个对比：</p><table><thead><tr><th>注解</th><th>注入方式</th><th>是否支持@Primary</th><th>来源</th><th>Bean不存在时处理</th></tr></thead><tbody><tr><td>@Autowired</td><td>根据类型注入</td><td>是</td><td>SpringFramework原生注解</td><td>可指定 required=false 来避免注入失败</td></tr><tr><td>@Resource</td><td>根据名称注入</td><td>否</td><td>JSR250规范</td><td>容器中不存在指定Bean会抛出异常</td></tr><tr><td>@Inject</td><td>根据类型注入</td><td>是</td><td>JSR330规范 ( 需要导jar包 )</td><td>容器中不存在指定Bean会抛出异常</td></tr></tbody></table><p>跟上面差不多，如果问到了这个问题，那就有可能继续被问到下面一个问题：</p><h3 id="存在多个相同类型Bean时如何解决注入问题？"><a href="#存在多个相同类型Bean时如何解决注入问题？" class="headerlink" title="存在多个相同类型Bean时如何解决注入问题？"></a>存在多个相同类型Bean时如何解决注入问题？</h3><p>可能大多数小伙伴都能答出以下几种解决方案：</p><ul><li><code>@Resource</code> ：根据名称指定注入的 Bean</li><li><code>@Qualifier</code> ：配合 <code>@Autowired</code> 注解使用，如果被标注的成员 / 方法在根据类型注入时发现有多个相同类型的 Bean ，则会根据该注解声明的 name 寻找特定的 bean</li><li><code>@Primary</code> ：配合 <code>@Bean</code> 注解使用，如果有多个相同类型的 Bean 同时注册到 IOC 容器中，使用 <code>@Autowired</code> 、<code>@Inject</code> 注解时会注入标注 <code>@Primary</code> 注解的 bean</li></ul><p>其实你还可以提另外一种方案：把<strong>注入的字段名与 bean 的名称保持一致</strong>，这样也可以解决注入时报不唯一 Bean 的问题。</p><p>以上几个问题是关于 SpringFramework 与 IOC 部分的一些常见问题，倒是问题都不太陌生，但是小伙伴们想回答的全面、有深度，还是需要下下功夫的。希望小伙伴们能有所收获，在面试中流利回答，斩获 offer ！</p><hr><p>问题整理不易，不点个赞支持一下作者吗？（可怜巴巴）</p>]]></content>
    
    <summary type="html">
    
      一直以来，SpringFramework 作为 Java 企业级开发的老大哥，面试中也常被问到。本文主题：Spring 的 IOC 如何回答的尽可能全面、准确、有深度。
    
    </summary>
    
    
      <category term="SpringFramework" scheme="http://yoursite.com/categories/SpringFramework/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>服务发现-EurekaServer的初始化和启动原理</title>
    <link href="http://yoursite.com/2020/01/04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-EurekaServer%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-EurekaServer%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</id>
    <published>2020-01-04T11:50:55.000Z</published>
    <updated>2020-05-23T06:04:13.840Z</updated>
    
    <content type="html"><![CDATA[<p>刚学习 SpringCloud 的时候先要学习注册中心，也就是服务发现与治理。SpringCloudNetflix 的方案是使用 Eureka，咱也都很清楚了，下面咱先搭建一个只有 EurekaServer 的工程。</p><p>pom依赖只需要两个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure><p>启动类上标注 <code>@EnableEurekaServer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        SpringApplication.run(EurekaServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><code>application.yml</code> 中配置一些最基础的信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">application:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">instance:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka-server</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">client:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">service-url:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9000/eureka/</span></span></pre></td></tr></table></figure><p>之后运行主启动类，EurekaServer 便会运行在9000端口上。</p><p>如果不标注 <code>@EnableEurekaServer</code> 注解，即便导入依赖也不会启动 EurekaServer，说明真正打开 EurekaServer 的是 <code>@EnableEurekaServer</code> 注解。</p><h2 id="1-EnableEurekaServer"><a href="#1-EnableEurekaServer" class="headerlink" title="1. @EnableEurekaServer"></a>1. @EnableEurekaServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(EurekaServerMarkerConfiguration<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableEurekaServer</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>它的文档注释非常简单：</p><blockquote><p>Annotation to activate Eureka Server related configuration.</p><p>用于激活 EurekaServer 相关配置的注解。</p></blockquote><p>它被标注了一个 <code>@Import</code> 注解，导入的是一个 <code>EurekaServerMarkerConfiguration</code> 的配置类。</p><blockquote><p>如果小伙伴对 @Import 注解还不是很了解，可以移步我的 《<a href="https://juejin.im/book/5da3bc3d6fb9a04e35597a76" target="_blank" rel="noopener">SpringBoot源码解读与原理分析</a>》小册，先了解 SpringFramework 的基础。</p></blockquote><h2 id="2-EurekaServerMarkerConfiguration"><a href="#2-EurekaServerMarkerConfiguration" class="headerlink" title="2. EurekaServerMarkerConfiguration"></a>2. EurekaServerMarkerConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerMarkerConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Marker <span class="title">eurekaServerMarkerBean</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Marker();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Marker</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这段源码看上去莫名其妙的，它是一个配置类，然后它定义了一个 <code>Marker</code> 的内部类，又注册了一个Bean，但这光秃秃的，也没点别的逻辑，它到底想干啥？果然还是得靠文档注释：</p><blockquote><p>Responsible for adding in a marker bean to activate EurekaServerAutoConfiguration.</p><p>负责添加标记Bean来激活 <code>EurekaServerAutoConfiguration</code> 。</p></blockquote><p>好吧，原来它的作用是<strong>给IOC容器中添加一个标记，代表要启用 <code>EurekaServerAutoConfiguration</code> 的自动配置类</strong>。</p><p>那咱就移步 <code>EurekaServerAutoConfiguration</code> 来看它的定义了。</p><h2 id="3-EurekaServerAutoConfiguration"><a href="#3-EurekaServerAutoConfiguration" class="headerlink" title="3. EurekaServerAutoConfiguration"></a>3. EurekaServerAutoConfiguration</h2><p>看到 AutoConfiguration 结尾的类，咱马上要想到：这个类肯定在 <code>spring.factories</code> 文件标注好了，不然没法生效。</p><p>果然，在 <code>spring-cloud-netflix-eureka-server</code> 的 jar 包中发现了一个 <code>spring.factories</code> 文件，而文件内部的声明就是如此的简单：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration</span></span></pre></td></tr></table></figure><p>没得跑，来看它的定义和声明吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(EurekaServerInitializerConfiguration<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class">@<span class="title">ConditionalOnBean</span>(<span class="title">EurekaServerMarkerConfiguration</span>.<span class="title">Marker</span>.<span class="title">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(</span>&#123; EurekaDashboardProperties<span class="class">.<span class="keyword">class</span>,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">InstanceRegistryProperties</span>.<span class="title">class</span> &#125;)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">@PropertySource("classpath:/eureka/server.properties")</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span></span></pre></td></tr></table></figure><p>注意看 <code>@ConditionalOnBean</code> 的条件：必须IOC容器中有一个 <code>EurekaServerMarkerConfiguration.Marker</code> 类型的 Bean，该配置类才会生效！（原来它是这样做自动配置开关的）</p><p>注意到它继承了 <code>WebMvcConfigurerAdapter</code> ，但全篇没有找到跟 <code>WebMvcConfigurer</code> 相关的部分，也没重写对应的方法。那它这是几个意思？这个时候咱要了解一个小背景：</p><blockquote><p>在 SpringFramework5.0+ 后，因为接口可以直接声明 default 方法，所以 <code>WebMvcConfigurerAdapter</code> 被废弃（被标注 <code>@Deprecated</code>），替代方案是直接实现 <code>WebMvcConfigurer</code> 接口。</p></blockquote><p>那既然是这样， 它还继承着这个适配器类，那咱可以大概猜测：它应该是旧版本的遗留。</p><p>回到正题，咱看 <code>EurekaServerAutoConfiguration</code> 的类定义声明上还有什么值得注意的。除了上面说的，那就只剩下一个了：它导入了一个 <code>EurekaServerInitializerConfiguration</code> 。</p><h2 id="4-EurekaServerInitializerConfiguration"><a href="#4-EurekaServerInitializerConfiguration" class="headerlink" title="4. EurekaServerInitializerConfiguration"></a>4. EurekaServerInitializerConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerInitializerConfiguration</span> <span class="keyword">implements</span> <span class="title">ServletContextAware</span>, <span class="title">SmartLifecycle</span>, <span class="title">Ordered</span></span></span></pre></td></tr></table></figure><p>注意它实现了 <code>SmartLifecycle</code> 接口，之前咱在《SpringBoot源码解读与原理分析》原理小册中提到过（第16篇 12.2.2章节），如果小伙伴们对这部分不了解，可以移步我的 《<a href="https://juejin.im/book/5da3bc3d6fb9a04e35597a76" target="_blank" rel="noopener">SpringBoot源码解读与原理分析</a>》小册，这里咱直接说，它的核心方法是 <code>start</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> is this class even needed now?</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 初始化、启动 EurekaServer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                eurekaServerBootstrap.contextInitialized(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                        EurekaServerInitializerConfiguration.<span class="keyword">this</span>.servletContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                log.info(<span class="string">"Started Eureka Server"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 发布Eureka已注册的事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                publish(<span class="keyword">new</span> EurekaRegistryAvailableEvent(getEurekaServerConfig()));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 修改 EurekaServer 的运行状态</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                EurekaServerInitializerConfiguration.<span class="keyword">this</span>.running = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 发布Eureka已启动的事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                publish(<span class="keyword">new</span> EurekaServerStartedEvent(getEurekaServerConfig()));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;).start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>（至此应该进一步意识到为什么上面 <code>EurekaServerAutoConfiguration</code> 继承了一个过时的类，<code>Runnable</code> 都没换成 Lambda 表达式。。。当然也跟 Eureka 1.x 不继续更新有关吧）</p><p>这个 <code>start</code> 方法只干了一件事，起一个新的线程来启动 EurekaServer 。这里面核心的 <strong>run</strong> 方法执行了这么几件事，都已经标注在源码中了。</p><p>这里面最重要的步骤就是第一步：<strong>初始化、启动 EurekaServer</strong> 。</p><p>在继续展开这部分源码之前，要带小伙伴了解一点前置知识。</p><p>EurekaServer 本身应该是一个完整的 Servlet 应用，在原生的 EurekaServer 中，<code>EurekaServerBootstrap</code> 这个类会实现 <code>ServletContextListener</code> 接口（Servlet3.0规范）来引导启动 EurekaServer 。SpringBoot 应用一般使用嵌入式 Web 容器，没有所谓 Servlet3.0 规范作用的机会了，所以需要另外的启动方式，于是 SpringCloud 在整合这部分时，借助了IOC容器中支持的 <code>LifeCycle</code> 机制，来以此触发 EurekaServer 的启动。</p><h3 id="4-0-eurekaServerBootstrap-contextInitialized：初始化、启动EurekaServer"><a href="#4-0-eurekaServerBootstrap-contextInitialized：初始化、启动EurekaServer" class="headerlink" title="4.0 eurekaServerBootstrap.contextInitialized：初始化、启动EurekaServer"></a>4.0 eurekaServerBootstrap.contextInitialized：初始化、启动EurekaServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContext context)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        initEurekaEnvironment();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        initEurekaServerContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        context.setAttribute(EurekaServerContext<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">this</span>.<span class="title">serverContext</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里面又分为两个部分，依此来看：</p><h3 id="4-1-initEurekaEnvironment：初始化Eureka的运行环境"><a href="#4-1-initEurekaEnvironment：初始化Eureka的运行环境" class="headerlink" title="4.1 initEurekaEnvironment：初始化Eureka的运行环境"></a>4.1 initEurekaEnvironment：初始化Eureka的运行环境</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST = <span class="string">"test"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT = <span class="string">"default"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    log.info(<span class="string">"Setting the eureka configuration.."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Eureka的数据中心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    String dataCenter = ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            .getString(EUREKA_DATACENTER);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (dataCenter == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        log.info(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                <span class="string">"Eureka data center value eureka.datacenter is not set, defaulting to default"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Eureka运行环境</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    String environment = ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            .getString(EUREKA_ENVIRONMENT);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        log.info(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                <span class="string">"Eureka environment value eureka.environment is not set, defaulting to test"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, environment);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里面的逻辑咱乍一看，貌似都长得差不多啊，都是 <strong>获取 → 判断 → 设置</strong> ，而且它们都有对应的默认值（源码中已标注）。至于这部分是干嘛的呢，咱不得不关注一下 <code>setProperty</code> 方法中的两个常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_DATACENTER = <span class="string">"archaius.deployment.datacenter"</span>;</span></pre></td></tr></table></figure><p>配置项的前缀是 <code>archaius</code> ，它是 Netflix 旗下的一个配置管理组件（提到这里，是不是产生了一种感觉：它会不会跟 SpringCloudConfig 有关系？然而并不是，当引入 SpringCloudConfig 时，archaius 并不会带进来），这个组件可以实现更强大的动态配置，它的基底是 <strong>Apache</strong> 的 <code>commons-configuration</code> ：</p><p>![](服务发现-EurekaServer的初始化和启动原理/3. archaius的底层依赖是commons-configuration.png)</p><p>对于这个组件，小册不展开研究了，小伙伴们只需要知道有这么回事就可以了，下面的才是重点。</p><h3 id="4-2-initEurekaServerContext：初始化EurekaServer的运行上下文"><a href="#4-2-initEurekaServerContext：初始化EurekaServer的运行上下文" class="headerlink" title="4.2 initEurekaServerContext：初始化EurekaServer的运行上下文"></a>4.2 initEurekaServerContext：初始化EurekaServer的运行上下文</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// For backward compatibility  兼容低版本Eureka</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    JsonXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            XStream.PRIORITY_VERY_HIGH);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    XmlXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            XStream.PRIORITY_VERY_HIGH);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (isAws(<span class="keyword">this</span>.applicationInfoManager.getInfo())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.awsBinder = <span class="keyword">new</span> AwsBinderDelegate(<span class="keyword">this</span>.eurekaServerConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">this</span>.eurekaClientConfig, <span class="keyword">this</span>.registry, <span class="keyword">this</span>.applicationInfoManager);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.awsBinder.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 注册EurekaServerContextHolder，通过它可以很方便的获取EurekaServerContext</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    EurekaServerContextHolder.initialize(<span class="keyword">this</span>.serverContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    log.info(<span class="string">"Initialized server context"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Copy registry from neighboring eureka node</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Eureka复制集群节点注册表</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> registryCount = <span class="keyword">this</span>.registry.syncUp();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.registry.openForTraffic(<span class="keyword">this</span>.applicationInfoManager, registryCount);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Register all monitoring statistics.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    EurekaMonitors.registerAllStats();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>前面的一大段都是为了低版本兼容而做的一些额外工作，咱不关心这些。中间又是注册了一个 注册<code>EurekaServerContextHolder</code> 的组件，通过它可以直接获取 <code>EurekaServerContext</code> （它的内部使用简单的单例实现，实现非常简单，小伙伴可自行查看）。</p><p>注意最后几行，倒数第二个单行注释的内容：</p><blockquote><p>Copy registry from neighboring eureka node。</p><p>从相邻的eureka节点复制注册表。</p></blockquote><p>节点复制注册表？这很明显是为了 Eureka 集群而设计的！由此可知 Eureka 集群能保证后起来的节点也不会出问题，是这里同步了注册表啊！这一步的操作非常复杂，咱后续另开一篇解释。</p><p>除了这部分之外，<code>EurekaServerInitializerConfiguration</code> 已经没有要配置的组件，回到 <code>EurekaServerAutoConfiguration</code> 中。</p><h2 id="5-EurekaServerAutoConfiguration中配置的核心组件"><a href="#5-EurekaServerAutoConfiguration中配置的核心组件" class="headerlink" title="5. EurekaServerAutoConfiguration中配置的核心组件"></a>5. EurekaServerAutoConfiguration中配置的核心组件</h2><h3 id="5-1-EurekaController"><a href="#5-1-EurekaController" class="headerlink" title="5.1 EurekaController"></a>5.1 EurekaController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"eureka.dashboard"</span>, name = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaController <span class="title">eurekaController</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EurekaController(<span class="keyword">this</span>.applicationInfoManager);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>呦，一看这是个 Controller ，有木有立马想到自己写的那些 Controller ？赶紧点进去瞅一眼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;eureka.dashboard.path:/&#125;"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaController</span></span></span></pre></td></tr></table></figure><p>哇塞果然是我们熟悉的 SpringWebMvc 的内容！既然是一个 Controller ，那它肯定能给咱定义了一些处理方法，不然咱咋看到的 Eureka 控制台呢？翻看源码，它这里面定义了两个处理方法，分别是： <code>status</code> - 获取当前 EurekaServer 的状态（即控制台）、<code>lastn</code> - 获取当前 EurekaServer 上服务注册动态历史记录。这部分咱不展开描述了，有兴趣的小伙伴们可以深入这个类来研究。</p><h3 id="5-2-PeerAwareInstanceRegistry"><a href="#5-2-PeerAwareInstanceRegistry" class="headerlink" title="5.2 PeerAwareInstanceRegistry"></a>5.2 PeerAwareInstanceRegistry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PeerAwareInstanceRegistry <span class="title">peerAwareInstanceRegistry</span><span class="params">(ServerCodecs serverCodecs)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.eurekaClient.getApplications(); <span class="comment">// force initialization</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InstanceRegistry(<span class="keyword">this</span>.eurekaServerConfig, <span class="keyword">this</span>.eurekaClientConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            serverCodecs, <span class="keyword">this</span>.eurekaClient,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.instanceRegistryProperties.getExpectedNumberOfClientsSendingRenews(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.instanceRegistryProperties.getDefaultOpenForTrafficCount());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个 <code>PeerAwareInstanceRegistry</code> 很重要，它是 <strong>EurekaServer 集群中节点之间同步微服务实例注册表的核心组件</strong>（这里默认小伙伴已经对 EurekaServer 的集群配置及相关基础都了解了）。集群节点同步注册表的内容咱会另起一篇研究，这里咱只是看一下这个类的继承结构，方面后续看到时不至于不认识：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceRegistry</span> <span class="keyword">extends</span> <span class="title">PeerAwareInstanceRegistryImpl</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">PeerAwareInstanceRegistryImpl</span> <span class="keyword">extends</span> <span class="title">AbstractInstanceRegistry</span> <span class="keyword">implements</span> <span class="title">PeerAwareInstanceRegistry</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">AbstractInstanceRegistry</span> <span class="keyword">implements</span> <span class="title">InstanceRegistry</span></span></span></pre></td></tr></table></figure><p>这里面继承的两个类 <code>PeerAwareInstanceRegistryImpl</code> 、<code>AbstractInstanceRegistry</code> ，它们将会在后续研究节点同步时有重要作用，包括里面涉及的功能会在后面的组件（<code>EurekaServerContext</code> 等）发挥功能时带着一起解释。</p><h3 id="5-3-PeerEurekaNodes"><a href="#5-3-PeerEurekaNodes" class="headerlink" title="5.3 PeerEurekaNodes"></a>5.3 PeerEurekaNodes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PeerEurekaNodes <span class="title">peerEurekaNodes</span><span class="params">(PeerAwareInstanceRegistry registry, ServerCodecs serverCodecs,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        ReplicationClientAdditionalFilters replicationClientAdditionalFilters)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RefreshablePeerEurekaNodes(registry, <span class="keyword">this</span>.eurekaServerConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.eurekaClientConfig, serverCodecs, <span class="keyword">this</span>.applicationInfoManager,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            replicationClientAdditionalFilters);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个 <code>PeerEurekaNodes</code> 可以理解成<strong>微服务实例的节点集合</strong>。换言之，一个 <code>PeerEurekaNode</code> 就是一个微服务节点实例的包装，<code>PeerEurekaNodes</code> 就是这组 <code>PeerEurekaNode</code> 的集合，这种节点是可以被 EurekaServer 集群中的各个注册中心节点共享的（<code>PeerAwareInstanceRegistry</code>）。翻开 PeerEurekaNodes 的结构，可以发现它的结构中有这么几样东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</span></pre></td></tr></table></figure><ul><li><code>PeerAwareInstanceRegistry</code> ：集群间节点同步的核心组件</li><li><code>List&lt;PeerEurekaNode&gt;</code> ：节点集合</li><li><code>peerEurekaNodeUrls</code> ：所有节点所在url</li><li><code>ScheduledExecutorService</code> ：执行定时任务的线程池</li></ul><p>另外 <code>PeerEurekaNodes</code> 还提供了一个 <code>start</code> 和 <code>shutdown</code> 方法：</p><h4 id="5-3-1-start"><a href="#5-3-1-start" class="headerlink" title="5.3.1 start"></a>5.3.1 start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    taskExecutor = Executors.newSingleThreadScheduledExecutor(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">new</span> ThreadFactory() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                    Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                    thread.setDaemon(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">return</span> thread;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        updatePeerEurekaNodes(resolvePeerUrls());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                    updatePeerEurekaNodes(resolvePeerUrls());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        taskExecutor.scheduleWithFixedDelay(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                peersUpdateTask,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                TimeUnit.MILLISECONDS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ...... log ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可以发现 start 方法的核心是<strong>借助线程池完成定时任务</strong>。定时任务的内容是中间那一段实现了 <code>Runnable</code> 接口的匿名内部类，它会执行一个 <code>updatePeerEurekaNodes</code> 方法来更新集群节点。下面定时任务的执行时间，借助IDEA跳转到 <code>EurekaServerConfigBean</code> 中发现默认的配置是 10 分钟，即<strong>每隔10分钟会同步一次集群节点</strong>。至于 <code>updatePeerEurekaNodes</code> 的具体实现，咱同样放到后面跟节点同步放在一起来解析。</p><h4 id="5-3-2-shutdown"><a href="#5-3-2-shutdown" class="headerlink" title="5.3.2 shutdown"></a>5.3.2 shutdown</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    taskExecutor.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    List&lt;PeerEurekaNode&gt; toRemove = <span class="keyword">this</span>.peerEurekaNodes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = Collections.emptyList();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.peerEurekaNodeUrls = Collections.emptySet();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (PeerEurekaNode node : toRemove) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        node.shutDown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个方法的内容比较简单，它会把线程池的定时任务停掉，并移除掉当前所有的服务节点信息。它被调用的时机是下面要解析的 <code>EurekaServerContext</code> 。</p><h3 id="5-4-EurekaServerContext"><a href="#5-4-EurekaServerContext" class="headerlink" title="5.4 EurekaServerContext"></a>5.4 EurekaServerContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaServerContext <span class="title">eurekaServerContext</span><span class="params">(ServerCodecs serverCodecs,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        PeerAwareInstanceRegistry registry, PeerEurekaNodes peerEurekaNodes)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultEurekaServerContext(<span class="keyword">this</span>.eurekaServerConfig, serverCodecs,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            registry, peerEurekaNodes, <span class="keyword">this</span>.applicationInfoManager);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>它创建了一个 <code>DefaultEurekaServerContext</code> ，文档注释原文翻译：</p><blockquote><p>Represent the local server context and exposes getters to components of the local server such as the registry.</p><p>表示本地服务器上下文，并将 getter 方法暴露给本地服务器的组件（例如注册表）。</p></blockquote><p>可以大概的意识到，它确实跟 SpringFramework 的 <code>ApplicationContext</code> 差不太多哈，可以这么简单地理解吧，咱还是看看里面比较特殊的内容。</p><p>进入到 <code>DefaultEurekaServerContext</code> 中，果然发现了两个特殊的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Initializing ..."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    peerEurekaNodes.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        registry.init(peerEurekaNodes);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Initialized"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Shutting down ..."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    registry.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    peerEurekaNodes.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Shut down"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>果然，是 <code>EurekaServerContext</code> 的初始化，带动 <code>PeerEurekaNodes</code> 的初始化，<code>EurekaServerContext</code> 的销毁带动 <code>PeerEurekaNodes</code> 的销毁。除了带动 <code>PeerEurekaNodes</code> 之前，还有一个 <code>PeerAwareInstanceRegistry</code> 也带动初始化了，看一眼它的 <code>init</code> 方法吧：</p><h4 id="5-4-1-PeerAwareInstanceRegistry-init"><a href="#5-4-1-PeerAwareInstanceRegistry-init" class="headerlink" title="5.4.1 PeerAwareInstanceRegistry#init"></a>5.4.1 PeerAwareInstanceRegistry#init</h4><p>关键部分注释已标注在源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(PeerEurekaNodes peerEurekaNodes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 5.4.1.1 启动续订租约的频率统计器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.numberOfReplicationsLastMin.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = peerEurekaNodes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    initializedResponseCache();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 5.4.1.2 开启续订租约最低阈值检查的定时任务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    scheduleRenewalThresholdUpdateTask();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 5.4.1.3 初始化远程分区注册中心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    initRemoteRegionRegistry();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Monitors.registerObject(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        logger.warn(<span class="string">"Cannot register the JMX monitor for the InstanceRegistry :"</span>, e);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>源码标注了三个关键的环节，一一来看：</p><h5 id="5-4-1-1-numberOfReplicationsLastMin-start-：启动续订租约的频率统计器"><a href="#5-4-1-1-numberOfReplicationsLastMin-start-：启动续订租约的频率统计器" class="headerlink" title="5.4.1.1 numberOfReplicationsLastMin.start()：启动续订租约的频率统计器"></a>5.4.1.1 numberOfReplicationsLastMin.start()：启动续订租约的频率统计器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong currentBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sampleInterval;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!isActive) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// Zero out the current bucket.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                    lastBucket.set(currentBucket.getAndSet(<span class="number">0</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                    logger.error(<span class="string">"Cannot reset the Measured Rate"</span>, e);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;, sampleInterval, sampleInterval);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        isActive = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个方法实现不难理解，它会隔一段时间重置 <code>lastBucket</code> 和 <code>currentBucket</code> 的值为0，那时间间隔是多少呢？翻看整个类，发现只有构造方法可以设置时间间隔：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MeasuredRate</span><span class="params">(<span class="keyword">long</span> sampleInterval)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.sampleInterval = sampleInterval;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.timer = <span class="keyword">new</span> Timer(<span class="string">"Eureka-MeasureRateTimer"</span>, <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.isActive = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>借助IDEA，发现设置 <code>sampleInterval</code> 的值有两处，但值都是一样的：<code>new MeasuredRate(1000 * 60 * 1);</code> ，也就是<strong>1分钟重置一次</strong>。可关键的问题是，它这个操作是干嘛呢？为啥非得一分钟统计一次续约次数呢？实际上，这个计算次数会体现在 Eureka 的控制台，以及配合 <strong>Servo</strong> 完成<strong>续约次数监控</strong>（说白了，咱这看着没啥用，微服务监控和治理还是管用的，不然为什么 Eureka 被称为<strong>服务发现与治理</strong>的框架呢）。</p><h5 id="5-4-1-2-scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务"><a href="#5-4-1-2-scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务" class="headerlink" title="5.4.1.2 scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务"></a>5.4.1.2 scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> renewalThresholdUpdateIntervalMs = <span class="number">15</span> * MINUTES;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleRenewalThresholdUpdateTask</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                       <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                           updateRenewalThreshold();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                       &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                   &#125;, serverConfig.getRenewalThresholdUpdateIntervalMs(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            serverConfig.getRenewalThresholdUpdateIntervalMs());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>又是一个定时任务，配置项中的默认时间间隔可以发现是15分钟。那定时任务中执行的核心方法是 <code>updateRenewalThreshold</code> 方法，跳转过去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRenewalThreshold</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        Applications apps = eurekaClient.getApplications();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isRegisterable(instance)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    ++count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Update threshold only if the threshold is greater than the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// current expected threshold or if self preservation is disabled.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((count) &gt; (serverConfig.getRenewalPercentThreshold() * expectedNumberOfClientsSendingRenews)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                    || (!<span class="keyword">this</span>.isSelfPreservationModeEnabled())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">this</span>.expectedNumberOfClientsSendingRenews = count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                updateRenewsPerMinThreshold();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        logger.info(<span class="string">"Current renewal threshold is : &#123;&#125;"</span>, numberOfRenewsPerMinThreshold);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>上面的 for 循环很明显是检查当前已经注册到本地的服务实例是否还保持连接，由于该方法一定会返回 true （可翻看该部分实现，全部都是 <code>return true</code>），故上面统计的 count 就是所有的微服务实例数量。</p><p>下面的同步代码块中，它会检查统计好的数量是否比预期的多，如果统计好的服务实例数比预期的数量多，证明出现了<strong>新的服务注册</strong>，要替换下一次统计的期望数量值，以及重新计算接下来心跳的数量统计。心跳的数量统计方法 <code>updateRenewsPerMinThreshold()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> expectedClientRenewalIntervalSeconds = <span class="number">30</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> renewalPercentThreshold = <span class="number">0.85</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateRenewsPerMinThreshold</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfClientsSendingRenews</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            * (<span class="number">60.0</span> / serverConfig.getExpectedClientRenewalIntervalSeconds())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            * serverConfig.getRenewalPercentThreshold());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可以看出来它的计算数是：<strong>每隔30秒发一次心跳</strong>（一分钟心跳两次），而且必须所有的服务实例的心跳总数要达到前面计算数量的85%才算整体微服务正常，其实这也就是 <strong>EurekaServer 的自我保护机制</strong>。</p><h5 id="5-4-1-3-initRemoteRegionRegistry：初始化远程分区注册中心"><a href="#5-4-1-3-initRemoteRegionRegistry：初始化远程分区注册中心" class="headerlink" title="5.4.1.3 initRemoteRegionRegistry：初始化远程分区注册中心"></a>5.4.1.3 initRemoteRegionRegistry：初始化远程分区注册中心</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initRemoteRegionRegistry</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Map&lt;String, String&gt; remoteRegionUrlsWithName = serverConfig.getRemoteRegionUrlsWithName();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!remoteRegionUrlsWithName.isEmpty()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        allKnownRemoteRegions = <span class="keyword">new</span> String[remoteRegionUrlsWithName.size()];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> remoteRegionArrayIndex = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; remoteRegionUrlWithName : remoteRegionUrlsWithName.entrySet()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            RemoteRegionRegistry remoteRegionRegistry = <span class="keyword">new</span> RemoteRegionRegistry(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    serverConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                    clientConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                    serverCodecs,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    remoteRegionUrlWithName.getKey(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">new</span> URL(remoteRegionUrlWithName.getValue()));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            regionNameVSRemoteRegistry.put(remoteRegionUrlWithName.getKey(), remoteRegionRegistry);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            allKnownRemoteRegions[remoteRegionArrayIndex++] = remoteRegionUrlWithName.getKey();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Finished initializing remote region registries. All known remote regions: &#123;&#125;"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            (Object) allKnownRemoteRegions);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里面提到了一个概念：<code>RemoteRegionRegistry</code> ，它的文档注释原文翻译：</p><blockquote><p>Handles all registry operations that needs to be done on a eureka service running in an other region. The primary operations include fetching registry information from remote region and fetching delta information on a periodic basis.</p><p>处理在其他区域中运行的eureka服务上需要完成的所有注册表操作。主要操作包括从远程区域中获取注册表信息以及定期获取增量信息。</p></blockquote><p>文档注释的解释看着似懂非懂，它没有把这个类的作用完全解释清楚。实际上这里涉及到 Eureka 的服务分区，这个咱留到后面解释 Eureka 的高级特性时再聊。</p><h4 id="5-4-2-PeerAwareInstanceRegistry-shutdown"><a href="#5-4-2-PeerAwareInstanceRegistry-shutdown" class="headerlink" title="5.4.2 PeerAwareInstanceRegistry#shutdown"></a>5.4.2 PeerAwareInstanceRegistry#shutdown</h4><p>当 <code>EurekaServerContext</code> 被销毁时，会回调 <code>@PreDestory</code> 标注的 <code>shutdown</code> 方法，而这个方法又调到 <code>PeerAwareInstanceRegistry</code> 的 <code>shutdown</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        DefaultMonitorRegistry.getInstance().unregister(Monitors.newObjectMonitor(<span class="keyword">this</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch .......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        peerEurekaNodes.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch .......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    numberOfReplicationsLastMin.stop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">super</span>.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里它干的事情不算麻烦，它首先利用 <code>DefaultMonitorRegistry</code> 做了一个注销操作，<code>DefaultMonitorRegistry</code> 这个组件本身来源于 <strong>servo</strong> 包，它是做监控使用，那自然能猜出来这部分是<strong>关闭监控</strong>。接下来它会把那些微服务节点实例全部注销，停止计数器监控，最后回调父类的 <code>shutdown</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    deltaRetentionTimer.cancel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    evictionTimer.cancel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    renewsLastMin.stop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可以发现也是跟监控相关的组件停止，不再赘述。</p><h3 id="5-5-EurekaServerBootstrap"><a href="#5-5-EurekaServerBootstrap" class="headerlink" title="5.5 EurekaServerBootstrap"></a>5.5 EurekaServerBootstrap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaServerBootstrap <span class="title">eurekaServerBootstrap</span><span class="params">(PeerAwareInstanceRegistry registry,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        EurekaServerContext serverContext)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EurekaServerBootstrap(<span class="keyword">this</span>.applicationInfoManager,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.eurekaClientConfig, <span class="keyword">this</span>.eurekaServerConfig, registry,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            serverContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个咱上面已经提过了，有了 <code>EurekaServerBootstrap</code> 才能引导启动 <code>EurekaServer</code> 。</p><h3 id="5-6-ServletContainer"><a href="#5-6-ServletContainer" class="headerlink" title="5.6 ServletContainer"></a>5.6 ServletContainer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">jerseyFilterRegistration</span><span class="params">(javax.ws.rs.core.Application eurekaJerseyApp)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    bean.setFilter(<span class="keyword">new</span> ServletContainer(eurekaJerseyApp));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    bean.setOrder(Ordered.LOWEST_PRECEDENCE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    bean.setUrlPatterns(Collections.singletonList(EurekaConstants.DEFAULT_PREFIX + <span class="string">"/*"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>它注册的 <code>FilterRegistrationBean</code> 我在之前的《<a href="https://juejin.im/book/5da3bc3d6fb9a04e35597a76" target="_blank" rel="noopener">SpringBoot源码解读与原理分析</a>》中有提过（第6章4.1.2节），这里咱直接说核心的 <code>Filter</code> 是 <code>ServletContainer</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.jersey.spi.container.servlet;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContainer</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> <span class="keyword">implements</span> <span class="title">Filter</span></span></span></pre></td></tr></table></figure><p>注意它所在的包，里面有一个很关键的词：<strong>jersey</strong> ，它是一个类似于 SpringWebMvc 的框架，由于 Eureka 本身也是一个 Servlet 应用，只是它使用的 Web 层框架不是 SpringWebMvc 而是 Jersey 而已，Jersey 在 Eureka 的远程请求、心跳包发送等环节起到至关重要的作用，后续咱会详细解释。</p><h3 id="5-7-Application"><a href="#5-7-Application" class="headerlink" title="5.7 Application"></a>5.7 Application</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> javax.ws.rs.core.<span class="function">Application <span class="title">jerseyApplication</span><span class="params">(Environment environment,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        ResourceLoader resourceLoader)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个类的创建咱不是很关心，瞅一眼这个类的子类，发现全部都是来自 <strong>Jersey</strong> 的：</p><p>![](服务发现-EurekaServer的初始化和启动原理/3. Application下面的子类全部都是jersey的.png)</p><p>而且上面的 <code>ServletContainer</code> 中正好也用到了这个 <code>Application</code> ，那大概也明白它是配合上面的过滤器使用，后续咱会跟上面的 <strong>Jersey</strong> 一起解释。</p><h3 id="5-8-HttpTraceFilter"><a href="#5-8-HttpTraceFilter" class="headerlink" title="5.8 HttpTraceFilter"></a>5.8 HttpTraceFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">traceFilterRegistration</span><span class="params">(@Qualifier(<span class="string">"httpTraceFilter"</span>)</span> Filter filter) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    bean.setFilter(filter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    bean.setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">10</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>它注册了一个名为 <code>httpTraceFilter</code> 的过滤器，借助IDEA发现这个过滤器来自 <code>HttpTraceAutoConfiguration</code> 的内部类 <code>ServletTraceFilterConfiguration</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletTraceFilterConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> HttpTraceFilter <span class="title">httpTraceFilter</span><span class="params">(HttpTraceRepository repository, HttpExchangeTracer tracer)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpTraceFilter(repository, tracer);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个过滤器的作用也很容易猜想，<strong>trace</strong> 的概念咱从日志系统里也接触过，它打印的内容非常非常多，且涵盖了上面的几乎所有级别。这个类的文档注释也恰好印证了我们的猜想：</p><blockquote><p>Servlet Filter that logs all requests to an HttpTraceRepository.</p><p>记录所有请求日志的Servlet过滤器。</p></blockquote><h2 id="6-EurekaServerConfigBeanConfiguration"><a href="#6-EurekaServerConfigBeanConfiguration" class="headerlink" title="6. EurekaServerConfigBeanConfiguration"></a>6. EurekaServerConfigBeanConfiguration</h2><p><code>EurekaServerAutoConfiguration</code> 还有一个内部的配置类：<code>EurekaServerConfigBeanConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerConfigBeanConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> EurekaServerConfig <span class="title">eurekaServerConfig</span><span class="params">(EurekaClientConfig clientConfig)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        EurekaServerConfigBean server = <span class="keyword">new</span> EurekaServerConfigBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Set a sensible default if we are supposed to replicate</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            server.setRegistrySyncRetries(<span class="number">5</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> server;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>它就是注册了默认的 EurekaServer 的配置模型，这个模型类里的配置咱上面也看到一些了，后面的部分咱还会接触它，先有一个印象即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><code>@EnableEurekaServer</code> 注解会激活 EurekaServer 的自动配置，核心是向IOC容器注册一个 <code>Marker</code> 的内部类。</li><li><code>EurekaServerInitializerConfiguration</code> 负责 EurekaServer 的初始化，初始化的过程包括本身初始化、运行环境初始化、运行上下文的初始化。</li><li><code>EurekaServerAutoConfiguration</code> 注册的核心组件包括展示控制台的 Controller 、微服务节点实例的模型和管理组件、<code>EurekaServerContext</code>、<code>EurekaServerBootstrap</code>（启动引导类）、两个过滤器。</li></ol>]]></content>
    
    <summary type="html">
    
      刚学习 SpringCloud 的时候先要学习注册中心，也就是服务发现与治理。SpringCloudNetflix 的方案是使用 Eureka。本文将详细解析 EurekaServer 的初始化内容，以及 EurekaServer 的启动流程。
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/categories/SpringCloud/"/>
    
    
      <category term="EurekaServer" scheme="http://yoursite.com/tags/EurekaServer/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式容器：嵌入式Tomcat的优化和配置</title>
    <link href="http://yoursite.com/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/</id>
    <published>2019-12-02T12:17:59.000Z</published>
    <updated>2019-12-02T12:21:25.547Z</updated>
    
    <content type="html"><![CDATA[<p>在以往的开发中我们可能会根据项目本身对 Tomcat 进行一些调整，以达到最大化利用 Tomcat 的目的。SpringBoot 使用嵌入式 Tomcat，再像之前那样做 Tomcat 性能调优就显得不那么现实了，为此我们需要了解如何在 SpringBoot 内部给嵌入式 Tomcat 做性能调优。本篇文章只做定<strong>性</strong>的解析，深入到<strong>量</strong>的控制本文不作详细探讨。</p><h2 id="0-调优前的准备"><a href="#0-调优前的准备" class="headerlink" title="0. 调优前的准备"></a>0. 调优前的准备</h2><p>为测试当前 SpringBoot 中嵌入式 Tomcat 的最大性能，需要一个压力测试工具来辅助我们测试性能，目前应用比较多的压测工具有 <strong>Bench</strong> 和 <strong>JMeter</strong> ，本文中使用 <code>Bench</code> 作为压测工具。</p><p>测试之前，咱先把工具准备好：</p><ul><li>Bench：<a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">https://www.apachelounge.com/download/</a></li><li>JMeter：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></li></ul><p>下载好之后，把这两个工具的环境变量都配置好，方便直接从控制台执行。</p><p>除此之外，把一开始的测试工程中加入一个测试的 <code>DemoController</code> ，用于接收请求压测（为模拟真实业务场景，会在 <code>DemoController</code> 中让线程随机阻塞 <code>100 - 500ms</code> ，以代替数据库连接和业务查询）。最后，把工程打成可执行jar包并启动，等待测试。</p><p>jar包启动的方式非常简单：<code>java -jar demo-0.0.1-SNAPSHOT.jar</code> </p><p>（本文在进行压测时的物理环境：Windows10 + Intel Core i7-8750H）</p><h2 id="1-使用Bench进行压测"><a href="#1-使用Bench进行压测" class="headerlink" title="1. 使用Bench进行压测"></a>1. 使用Bench进行压测</h2><p>在cmd中执行如下命令：</p><p><code>ab -n 10000 -c 500 http://localhost:8080/test</code></p><p>执行完成后会在控制台打印测试报告：（<strong>报告中的指标解释已标注在行尾</strong>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">This</span> <span class="string">is</span> <span class="string">ApacheBench,</span> <span class="string">Version</span> <span class="number">2.3</span> <span class="string">&lt;$Revision:</span> <span class="number">1843412</span> <span class="string">$&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">Copyright</span> <span class="number">1996</span> <span class="string">Adam</span> <span class="string">Twiss,</span> <span class="string">Zeus</span> <span class="string">Technology</span> <span class="string">Ltd,</span> <span class="string">http://www.zeustech.net/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="string">Licensed</span> <span class="string">to</span> <span class="string">The</span> <span class="string">Apache</span> <span class="string">Software</span> <span class="string">Foundation,</span> <span class="string">http://www.apache.org/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">Benchmarking</span> <span class="string">localhost</span> <span class="string">(be</span> <span class="string">patient)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">1000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">2000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">3000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">4000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">5000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">6000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">7000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">8000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">9000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">10000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="string">Finished</span> <span class="number">10000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Server Software:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Server Hostname:</span>        <span class="string">localhost</span> <span class="string">//</span> <span class="string">主机名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Server Port:</span>            <span class="number">8080</span>      <span class="string">//</span> <span class="string">端口号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Document Path:</span>          <span class="string">/test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Document Length:</span>        <span class="number">4</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">500</span>            <span class="string">//</span> <span class="string">并发量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">15.670</span> <span class="string">seconds</span> <span class="string">//</span> <span class="string">所有请求的总耗时</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">10000</span>          <span class="string">//</span> <span class="string">成功的请求数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">1360000</span> <span class="string">bytes</span>  <span class="string">//</span> <span class="string">总传输数据量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">40000</span> <span class="string">bytes</span>    <span class="string">//</span> <span class="string">总响应数据量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">638.17</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span> <span class="string">//</span> <span class="string">【重要】每秒执行的请求数量（吞吐量）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">783.493</span> <span class="string">[ms]</span> <span class="string">(mean)</span>   <span class="string">//</span> <span class="string">【重要】客户端平均响应时间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">1.567</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span> <span class="string">//</span> <span class="string">服务器平均请求等待时间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">84.76</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span> <span class="string">//</span> <span class="string">每秒传输的数据量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="string">Connection</span> <span class="string">Times</span> <span class="string">(ms)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">              <span class="string">min</span>  <span class="string">mean[+/-sd]</span> <span class="string">median</span>   <span class="string">max</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Connect:</span>        <span class="number">0</span>    <span class="number">0</span>   <span class="number">0.2</span>      <span class="number">0</span>       <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Processing:</span>   <span class="number">105</span>  <span class="number">738</span> <span class="number">135.1</span>    <span class="number">742</span>     <span class="number">993</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Waiting:</span>      <span class="number">105</span>  <span class="number">738</span> <span class="number">135.2</span>    <span class="number">742</span>     <span class="number">993</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total:</span>        <span class="number">105</span>  <span class="number">738</span> <span class="number">135.1</span>    <span class="number">742</span>     <span class="number">993</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="string">Percentage</span> <span class="string">of</span> <span class="string">the</span> <span class="string">requests</span> <span class="string">served</span> <span class="string">within</span> <span class="string">a</span> <span class="string">certain</span> <span class="string">time</span> <span class="string">(ms)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">  <span class="number">50</span><span class="string">%</span>    <span class="number">742</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">  <span class="number">66</span><span class="string">%</span>    <span class="number">810</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">  <span class="number">75</span><span class="string">%</span>    <span class="number">847</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">  <span class="number">80</span><span class="string">%</span>    <span class="number">868</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">  <span class="number">90</span><span class="string">%</span>    <span class="number">909</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">  <span class="number">95</span><span class="string">%</span>    <span class="number">931</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">  <span class="number">98</span><span class="string">%</span>    <span class="number">945</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">  <span class="number">99</span><span class="string">%</span>    <span class="number">952</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"> <span class="number">100</span><span class="string">%</span>    <span class="number">993</span> <span class="string">(longest</span> <span class="string">request)</span></span></pre></td></tr></table></figure><p>在测试报告中有两个重要的指标需要咱来关注：</p><ul><li><strong>Requests per second</strong>：每秒执行的请求数量（吞吐量）<ul><li>吞吐量越高，代表性能越好</li></ul></li><li><strong>Time per request</strong>：客户端平均响应时间<ul><li>响应时间越短，代表性能越好</li></ul></li></ul><p>在这里面测得的结果是 638.17 的吞吐量，783.493ms 的平均响应时间，这个响应时间比代码中控制的阻塞时间更长，说明 Tomcat 对500的并发已经有一些吃力了。</p><p>下面咱再用更大的并发量来测试效果：</p><p><code>ab -n 50000 -c 2000 http://localhost:8080/test</code></p><p>测得的结果（截取主要部分）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">75.689</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">660.60</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">3027.564</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">1.514</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">87.74</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>发现<strong>吞吐量没有什么太大的变化</strong>，但<strong>平均响应时间大幅提升，且大概为上面的4倍</strong>。可以看得出来，Tomcat 的处理速度已经远远跟不上请求到来的速度，需要进行性能调优。</p><h2 id="2-嵌入式Tomcat调优依据"><a href="#2-嵌入式Tomcat调优依据" class="headerlink" title="2. 嵌入式Tomcat调优依据"></a>2. 嵌入式Tomcat调优依据</h2><p>调优一定要有依据，咱根据现状和之前对 SpringBoot 的学习和原理剖析，应该知道配置大多都是两种形式：</p><ul><li>声明式配置：<code>application.properties</code> 或 <code>application.yml</code></li><li>编程式配置：<code>XXXConfigurer</code> 或 <code>XXXCustomizer</code></li></ul><p>其中，利用配置文件进行配置，最终会映射到 SpringBoot 中的一些 Properties 类中，例如 <code>server.port</code> 配置会映射到 <code>ServerProperties</code> 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"server"</span>, ignoreUnknownFields = <span class="keyword">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Integer port;</span></pre></td></tr></table></figure><p>那我们来大体分析一下对于 Tomcat 的声明式配置，都有哪些可以控制的部分：</p><h3 id="2-1-Tomcat的声明式配置"><a href="#2-1-Tomcat的声明式配置" class="headerlink" title="2.1 Tomcat的声明式配置"></a>2.1 Tomcat的声明式配置</h3><p>在 <code>ServerProperties</code> 类中，有一个 Tomcat 的静态内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Tomcat properties.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tomcat</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// ......</span></span></pre></td></tr></table></figure><p>这里面就是配置嵌入式 Tomcat 的可以供我们配置的映射配置类。咱来看里面的核心属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Maximum amount of worker threads.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 最大工作线程数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxThreads = <span class="number">200</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Minimum amount of worker threads.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 最小工作线程数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minSpareThreads = <span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Maximum number of connections that the server accepts and processes at any</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * given time. Once the limit has been reached, the operating system may still</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * accept connections based on the "acceptCount" property.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 服务器最大连接数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxConnections = <span class="number">10000</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Maximum queue length for incoming connection requests when all possible request</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * processing threads are in use.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 最大请求队列等待长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> acceptCount = <span class="number">100</span>;</span></pre></td></tr></table></figure><p>可以发现这里面的几个指标，分别控制连接数、线程数、等待数。</p><p>咱来分析为什么上面的吞吐量不够大：请求中的关键耗时动作是 <code>Thread.sheep</code> 卡线程，导致吞吐量变大。<code>Thread.sleep</code> 模拟了IO操作、数据库交互等<strong>非CPU高速计算的行为</strong>，在数据库交互时，CPU资源被浪费，导致无法处理后来的请求，出现资源利用率低的现象。为此，我们需要提高请求并发数，以此来提高CPU利用率。提高请求并发的方法在上面的几个参数中很明显是 <strong><code>maxThreads</code></strong> 。</p><h2 id="3-调整maxThreads"><a href="#3-调整maxThreads" class="headerlink" title="3. 调整maxThreads"></a>3. 调整maxThreads</h2><p>从源码中很明显看到默认的最大线程数是200，我们在 <code>application.properties</code> 中修改值为 500：</p><p><code>server.tomcat.max-threads=500</code></p><p>修改之后的测试：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">30.910</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">1617.61</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">1236.391</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">0.618</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">214.84</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>发现吞吐量有明显的提升，且吞吐量的放大倍数大概是前面线程数为 200 时的2.5倍。继续放大该值为 2000：</p><p><code>server.tomcat.max-threads=2000</code></p><p>重新测试效果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">12.050</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">4149.38</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">482.000</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">0.241</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">551.09</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>吞吐量又一次明显上升，但注意此时的吞吐量并没有扩大到上一次的 4 倍。继续放大该值为 10000：</p><p><code>server.tomcat.max-threads=10000</code></p><p>重新测试效果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">13.808</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">3621.22</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">552.300</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">0.276</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">480.94</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>发现吞吐量竟然下降了！为什么会出现这种现象呢？</p><h2 id="4-现象解释"><a href="#4-现象解释" class="headerlink" title="4. 现象解释"></a>4. 现象解释</h2><p>要解释这个原因，就不得不提到 CPU 的工作原理了。当CPU的<strong>核心线程数</strong>小于当前应用线程时，CPU为了保证所有应用线程都正常执行，它会<strong>在多个线程中来回切换</strong>，以保证每个线程都能获得CPU时间。在一个确定的时间点中，一个CPU只能处理一个线程。</p><p>所以这个现象就可以这样解释：当开启的 Tomcat 线程过多时，CPU会消耗大量时间在这些 Tomcat 线程中来回切换，导致真正处理业务请求的时间变少，最终导致整体应用处理速度变慢。</p><p>由此也可以推出另一种可能：如果业务逻辑中有大量CPU处理工作（如运算、处理数据等），则CPU需要更多的时间用于计算，此时若 Tomcat 线程过多，则处理速度会更慢。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>由上面的情况可以总结出以下结论：</p><ul><li>应用中大部分业务逻辑都是阻塞型处理（IO、数据库操作等），这种情况下CPU的压力较低，可以适当调大 <code>maxThreads</code> 的值大小。</li><li>应用中大部分业务逻辑都是数据处理和计算，这种情况下CPU的压力较大，应适当调小 <code>maxThreads</code> 的值大小。</li></ul>]]></content>
    
    <summary type="html">
    
      在以往的开发中我们可能会根据项目本身对 Tomcat 进行一些调整，以达到最大化利用 Tomcat 的目的。SpringBoot 使用嵌入式 Tomcat，再像之前那样做 Tomcat 性能调优就显得不那么现实了，为此本文解释如何在 SpringBoot 内部给嵌入式 Tomcat 做性能调优。
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="Tomcat, 嵌入式容器, SpringBoot" scheme="http://yoursite.com/tags/Tomcat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8-SpringBoot/"/>
    
  </entry>
  
</feed>
