{"meta":{"title":"LinkedBear的GitHub","subtitle":"","description":"LinkedBear的GitHub博客","author":"LinkedBear","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-09-15T09:52:50.000Z","updated":"2020-09-15T09:09:34.862Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一个平凡的码畜我不是什么有身份的人，在圈子里也没什么动静。我只是一个默默研究框架源码以及其中内部原理的草根研究者，闷头翻源码是我喜欢的事情，同样也是我的乐趣。平常工作中，我通常扮演偏架构和偏基础的组件研发，也不是什么很牛的组件贡献者。 机缘巧合的小册我有一个关系很好的小圈子，那些伙计鼓励我写一本 SpringBoot 的小册（毕竟那是我研究最多的框架，没有之一），机缘巧合之下，我联系到了掘金平台，从此开始了我的创作路。小册发布后评价都还不错，感谢小伙伴们的认可和对我的支持，目前也有几本小册的产出了，后续我还会有更多的产出。 寻找我的方式讲真，我也没什么名气，也没有太多的精力去运营公众号等自媒体，所以目前来讲能找到我的办法，可能只有借助掘金小册、微信群的通道了。。。后续如果真的我慢慢做大了，那寻找我也会变得容易的多。"},{"title":"juejin","date":"2019-12-02T12:49:54.000Z","updated":"2020-09-15T09:08:28.789Z","comments":true,"path":"juejin/index.html","permalink":"http://yoursite.com/juejin/index.html","excerpt":"","text":"掘金小册的创作由来我有一个关系很好的小圈子，那些伙计鼓励我写一本 SpringBoot 的小册（毕竟那是我研究最多的框架，没有之一），机缘巧合之下，我联系到了掘金平台，从此开始了我的创作路。小册发布后评价都还不错，感谢小伙伴们的认可和对我的支持，我也会在后续有更多的产出。 SpringBoot 小册SpringBoot 的小册虽说是第一本小册，里面的内容还是很多的，对 SpringFramework 和 SpringBoot 有深入理解的想法的小伙伴，你可以去读几篇体会一下，如果感觉你喜欢或者你需要的话，不妨买来看看(滑稽)，虽说不贵，但内容绝对超值（已得到多名小伙伴的反馈）。 跳转戳 → https://juejin.im/book/6844733814560784397 SpringCloudNetflix小册时隔半年，SpringCloud 的小册也终于发行了，上篇讲的都是 SpringCloudNetflix 下的解决方案集，小册延续 SpringBoot 的风格，详细解析源码和内部的设计实现原理，相信对于想系统了解 SpringCloud 原理的小伙伴来讲，这是一个不错的帮助。 跳转戳 → https://juejin.im/book/6844733831069564941 从 0 开始深入学习 Spring 小册一直以来，Spring 作为 Java 界最最受欢迎的框架（没有之一），它的地位无疑是极高的。无论是之前流行的 SSH ，到后来的 SSM ，再到现在的分布式、微服务、云原生，底层的技术栈无一不用 Spring ，且 Spring 本身有着强大的整合能力，它配合构建的开发生态也是最庞大的。可以这么说，Spring 早已成为 Java 开发的主流标准，掌握 Spring 框架，对平时的开发，甚至是进攻大厂、获得更好地职业前景，都是非常关键的一部分。 小册以 SpringFramework 的入门为起点，逐步带你学习 SpringFramework 的进阶、高级，和底层的原理，不需要小伙伴有前置的框架学习和使用经验，只需要最起码的 JavaSE 知识、JavaWeb 知识即可。当然，如果小伙伴已经有 SpringFramework 的使用经验，但还想深层次学习更高级的知识，小册也会给你讲解更深入的特性和用法。总之，这本小册的受众群体非常大，想学的小伙伴一定要去看看呀！ 这本小册目前还在连载中，八十多个章节的小册估计小伙伴也没怎么见过吧，信我一句话，买它就对了！（滑稽） 跳转戳 → https://juejin.im/book/6857911863016390663 后续计划SpringCloud 的小册还没有完结，Netflix 系列的源码解读完成后还有 Alibaba 系列，下一个阶段我会考虑继续出 SpringCloudAlibaba 的小册。不过由于 SpringCloudAlibaba 中的好多组件都是开箱即用，所以小册不会像 Netflix 系列的组件那样特别深入的研究，而是更倾向于实战中的使用。敬请期待 ~"}],"posts":[{"title":"【不懂就问】MyBatis的一级缓存竟然还会引来麻烦？","slug":"【不懂就问】MyBatis的一级缓存竟然还会引来麻烦？","date":"2020-06-28T11:48:16.000Z","updated":"2020-06-28T11:49:08.025Z","comments":true,"path":"2020/06/28/【不懂就问】MyBatis的一级缓存竟然还会引来麻烦？/","link":"","permalink":"http://yoursite.com/2020/06/28/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91MyBatis%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AB%9F%E7%84%B6%E8%BF%98%E4%BC%9A%E5%BC%95%E6%9D%A5%E9%BA%BB%E7%83%A6%EF%BC%9F/","excerpt":"","text":"【“不懂就问”，是一个新的系列，主要整理我的小册群里遇到的一些比较有意思的 / 有难度的 / 容易被讨论起来的问题，并给出问题的解析和方案等等。喜欢的小伙伴们可以点赞关注我鸭 ~ ~ 学习源码可以看看我的小册 ~ ~】 端午假期相信不少小伙伴都在偷偷学习吧（说好了放假一起玩耍呢，结果又背着我学习），这不，刚过了端午，我的一个沙雕程序猿圈子里就有人讨论起来问题了，这个问题聊起来好像挺麻烦，但实际上问题是很简单的，下面咱来讨论下这个问题。 原问题MyBatis 一级缓存与 SpringFramework 的声明式事务有冲突吗？在 Service 中开启事务，连续查询两次同样的数据，结果两次查询的结果不一致。 —— 使用 Mapper 的 selectById 查出来实体，然后修改实体的属性值，然后再 selectById 一下查出来实体，对比一下之前查出来的，发现查出来的是刚才修改过的实体，不是从数据库查出来的。 —— 如果不开启事务，则两次请求查询的结果是相同的，控制台打印了两次 SQL 。 初步分析讲道理，看到这个问题，我一下子就猜到是 MyBatis 一级缓存重复读取的问题了。 MyBatis 的一级缓存默认开启，属于 SqlSession 作用范围。在事务开启的期间，同样的数据库查询请求只会查询一次数据库，之后重复查询会从一级缓存中获取。当不开启事务时，同样的多次数据库查询都会发送数据库请求。 上面的都属于基础知识了，不多解释。重点是，他修改的实体是直接从 MyBatis 的一级缓存中查询出来的。咱都知道，查询出来的这些实体肯定属于对象，拿到的是对象的引用，咱在 Service 里修改了，一级缓存中相应的也就会被影响。由此可见，这个问题的核心原因也就很容易找到了。 问题复现为了展示这个问题，咱还是简单复现一下场景吧。 工程搭建咱使用 SpringBoot + mybatis-spring-boot-starter 快速构建出工程，此处 SpringBoot 版本为 2.2.8 ，mybatis-spring-boot-starter 的版本为 2.1.2 。 pom核心的 pom 依赖有 3 个： 1&lt;dependency&gt;2 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;3 &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;4&lt;/dependency&gt;56&lt;dependency&gt;7 &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;8 &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;9 &lt;version&gt;2.1.2&lt;/version&gt;10&lt;/dependency&gt;1112&lt;dependency&gt;13 &lt;groupId&gt;com.h2database&lt;/groupId&gt;14 &lt;artifactId&gt;h2&lt;/artifactId&gt;15 &lt;version&gt;1.4.199&lt;/version&gt;16&lt;/dependency&gt; 数据库配置数据库咱们依然选用 h2 作为快速问题复现的数据库，只需要在 application.properties 中添加如下配置，即可初始化一个 h2 数据库。顺便的，咱把 MyBatis 的配置也简单配置好： 1spring.datasource.driver-class-name=org.h2.Driver2spring.datasource.url=jdbc:h2:mem:mybatis-transaction-cache3spring.datasource.username=sa4spring.datasource.password=sa5spring.datasource.platform=h267spring.datasource.schema=classpath:sql/schema.sql8spring.datasource.data=classpath:sql/data.sql910spring.h2.console.settings.web-allow-others=true11spring.h2.console.path=/h212spring.h2.console.enabled=true1314mybatis.type-aliases-package=com.linkedbear.demo.entity15mybatis.mapper-locations=classpath:mapper/*.xml 初始化数据库上面咱使用了 datasource 的 schema 和 data 初始化数据库，那自然的就应该有这两个 .sql 文件。 schema.sql ： 1create table if not exists sys_department (2 id varchar(32) not null primary key,3 name varchar(32) not null4); data.sql ： 1insert into sys_department (id, name) values ('idaaa', 'testaaa');2insert into sys_department (id, name) values ('idbbb', 'testbbb');3insert into sys_department (id, name) values ('idccc', 'testccc');4insert into sys_department (id, name) values ('idddd', 'testddd'); 编写测试代码咱使用一个最简单的单表模型，快速复现场景。 entity新建一个 Department 类，并声明 id 和 name 属性： 1public class Department &#123;2 3 private String id;4 private String name;5 6 // getter setter toString ......7&#125; mapperMyBatis 的接口动态代理方式可以快速声明查询的 statement ，咱只需要声明一个 findById 即可： 1@Mapper2public interface DepartmentMapper &#123;3 Department findById(String id);4&#125; mapper.xml对应的，接口需要 xml 作为照应：（此处并没有使用注解式 Mapper ） 1&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;2&lt;!DOCTYPE mapper3 PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"4 \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;5&lt;mapper namespace=\"com.linkedbear.demo.mapper.DepartmentMapper\"&gt;6 &lt;select id=\"findById\" parameterType=\"string\" resultType=\"department\"&gt;7 select * from sys_department where id = #&#123;id&#125;8 &lt;/select&gt;9&lt;/mapper&gt; serviceService 中注入 Mapper ，并编写一个需要事务的 update 方法，模拟更新动作： 1@Service2public class DepartmentService &#123;3 4 @Autowired5 DepartmentMapper departmentMapper;6 7 @Transactional(rollbackFor = Exception.class)8 public Department update(Department department) &#123;9 Department temp = departmentMapper.findById(department.getId());10 temp.setName(department.getName());11 Department temp2 = departmentMapper.findById(department.getId());12 System.out.println(\"两次查询的结果是否是同一个对象：\" + temp == temp2);13 return temp;14 &#125;15&#125; controllerController 中注入 Service ，并调用 Service 的 update 方法来触发测试： 1@RestController2public class DepartmentController &#123;3 4 @Autowired5 DepartmentService departmentService;6 7 @GetMapping(\"/department/&#123;id&#125;\")8 public Department findById(@PathVariable(\"id\") String id) &#123;9 Department department = new Department();10 department.setId(id);11 department.setName(UUID.randomUUID().toString().replaceAll(\"-\", \"\"));12 return departmentService.update(department);13 &#125;14&#125; 主启动类主启动类中不需要什么特别的内容，只需要记得开启事务就好： 1@EnableTransactionManagement2@SpringBootApplication3public class MyBatisTransactionCacheApplication &#123;4 5 public static void main(String[] args) &#123;6 SpringApplication.run(MyBatisTransactionCacheApplication.class, args);7 &#125;8&#125; 运行测试以 Debug 方式运行 SpringBoot 的主启动类，在浏览器中输入 http://localhost:8080/h2 输入刚才在 application.properties 中声明的配置，即可打开 h2 数据库的管理台。 执行 SELECT * FROM SYS_DEPARTMENT ，可以发现数据已经成功初始化了： 下面测试效果，在浏览器中输入 http://localhost:8080/department/idaaa ，控制台中打印的结果为 true ，证明 MyBatis 的一级缓存生效，两次查询最终得到的实体类对象一致。 解决方案对于这个问题的解决方案，其实说白了，就是关闭一级缓存。最常见的几种方案列举一下： 全局关闭：设置 mybatis.configuration.local-cache-scope=statement 指定 mapper 关闭：在 mapper.xml 的指定 statement 上标注 flushCache=&quot;true&quot; 另类的办法：在 statement 的 SQL 上添加一串随机数（过于非主流。。。） select * from sys_department where #{random} = #{random} 原理扩展其实到这里，问题就已经解决了，但先不要着急，思考一个问题：为什么声明了 local-cache-scope 为 statement ，或者mapper 的 statement 标签中设置 flushCache=true ，一级缓存就被禁用了呢？下面咱来了解下这背后的原理。 一级缓存失效的原理在 DepartmentService 中，执行 mapper.findById 的动作，最终会进入到 DefaultSqlSession 的 selectOne 中： 1public &lt;T&gt; T selectOne(String statement) &#123;2 return this.selectOne(statement, null);3&#125;45@Override6public &lt;T&gt; T selectOne(String statement, Object parameter) &#123;7 // Popular vote was to return null on 0 results and throw exception on too many.8 List&lt;T&gt; list = this.selectList(statement, parameter);9 if (list.size() == 1) &#123;10 return list.get(0);11 &#125; else if (list.size() &gt; 1) &#123;12 throw new TooManyResultsException(\"Expected one result (or null) to be returned by selectOne(), but found: \" + list.size());13 &#125; else &#123;14 return null;15 &#125;16&#125; 可见 selectOne 的底层是调用的 selectList ，之后 get(0) 取出第一条数据返回。 selectList 的底层会有两个步骤：获取 MappedStatement → 执行查询，如下代码中的 try 部分： 1public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;2 try &#123;3 MappedStatement ms = configuration.getMappedStatement(statement);4 return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);5 &#125; catch (Exception e) &#123;6 throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e);7 &#125; finally &#123;8 ErrorContext.instance().reset();9 &#125;10&#125; 执行 query 方法，来到 BaseExecutor 中，它会执行三个步骤：获取预编译的 SQL → 创建缓存键 → 真正查询。 1public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, 2 RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;3 BoundSql boundSql = ms.getBoundSql(parameter);4 CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);5 return query(ms, parameter, rowBounds, resultHandler, key, boundSql);6&#125; 这里面的缓存键是有一定设计的，它的结构可以简单的看成 “ statementId + SQL + 参数 ” 的形式，根据这三个要素，就可以唯一的确定出一个查询结果。 到了这里面的 query 方法，它就带着这个缓存键，执行真正的查询动作了，如下面的这段长源码：（注意看源码中的注释） 1public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, 2 ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;3 ErrorContext.instance().resource(ms.getResource()).activity(\"executing a query\").object(ms.getId());4 if (closed) &#123;5 throw new ExecutorException(\"Executor was closed.\");6 &#125;7 // 如果statement有设置flushCache=\"true\"，则查询之前先清理一级缓存8 if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;9 clearLocalCache();10 &#125;11 List&lt;E&gt; list;12 try &#123;13 queryStack++;14 // 先检查一级缓存15 list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;16 if (list != null) &#123;17 // 如果一级缓存中有，则直接取出18 handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);19 &#125; else &#123;20 // 一级缓存没有，则查询数据库21 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);22 &#125;23 &#125; finally &#123;24 queryStack--;25 &#125;26 if (queryStack == 0) &#123;27 for (DeferredLoad deferredLoad : deferredLoads) &#123;28 deferredLoad.load();29 &#125;30 // issue #60131 deferredLoads.clear();32 // 如果全局配置中有设置local-cache-scope=statement，则清除一级缓存33 if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;34 // issue #48235 clearLocalCache();36 &#125;37 &#125;38 return list;39&#125; 上面的注释中，可以发现，只要上面的三个解决方案，任选一个配置，则一级缓存就会失效，分别分析下： 全局设置 local-cache-scope=statement ，则查询之后即便放入了一级缓存，但存放完立马就给清了，下一次还是要查数据库； statement 设置 flushCache=&quot;true&quot; ，则查询之前先清空一级缓存，还是得查数据库； 设置随机数，如果随机数的上限足够大，那随机到相同数的概率就足够低，也能类似的看成不同的数据库请求，那缓存的 key 都不一样，自然就不会匹配到缓存。 本文涉及到的所有源码可以从 GitHub 中找到：github.com/LinkedBear/juejin-posts-sources 【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】","categories":[{"name":"不懂就问","slug":"不懂就问","permalink":"http://yoursite.com/categories/%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE/"}],"tags":[{"name":"声明式事务","slug":"声明式事务","permalink":"http://yoursite.com/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"一级缓存","slug":"一级缓存","permalink":"http://yoursite.com/tags/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98/"}]},{"title":"【不懂就问】SpringFramework中的注解声明式事务怎么被Shiro搞失效了","slug":"【不懂就问】SpringFramework中的注解声明式事务怎么被Shiro搞失效了","date":"2020-06-24T05:30:16.000Z","updated":"2020-06-28T07:06:05.100Z","comments":true,"path":"2020/06/24/【不懂就问】SpringFramework中的注解声明式事务怎么被Shiro搞失效了/","link":"","permalink":"http://yoursite.com/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/","excerpt":"","text":"【“不懂就问”，是一个新的系列，主要整理我的小册群里遇到的一些比较有意思的 / 有难度的 / 容易被讨论起来的问题，并给出问题的解析和方案等等。喜欢的小伙伴们可以点赞关注我鸭 ~ ~ 学习源码可以看看我的小册 ~ ~】 近期我在 SpringBoot 的小册交流群里碰见一个问题，感觉蛮有意思的，拿出来跟小伙伴们分享一下。 原问题那位小伙伴的项目中，有一部分 Service 的注解事务一直不起作用，但也只是一部分起作用，也有一部分是好的。而且更奇怪的是，如果他把一个事务不起作用的 ServiceImpl 代码完整的抄一遍到新的复制类里头，那个类居然是有事务的！ 初步分析咱回想一下，按常理来讲，SpringFramework 中的事务不生效，大概有这么几种情况： @Transactional 注解标注在非 public 方法上 @Transactional 注解标注在接口上，但实现类使用 Cglib 代理 @Transactional 注解标注抛出 Exception ，默认不捕捉 service 方法中自行 try-catch 了异常但没有再抛出 RuntimeException 原生 SSM 开发中，父子容器一起包扫描，会导致子容器先扫描到 service 并注册到子容器中但不加载事务，之后虽然父容器也扫描到 service 但因为子容器中的 controller 已经注入了没有事务代理的 service ，会导致事务失效 声明式事务的配置必须由父 IOC 容器加载，SpringWebMvc 的子 IOC 容器加载不生效 除此之外，如果使用的关系型数据库是 MySQL ，还要关注是否为 InnoDB 引擎（ MyISAM 不支持事务）。 结果小伙伴一通分析，发现这上面罗列的情况都没有出现，排查难度进一步加大。 新的关注点隔了大概半天吧，那位小伙伴突然发现了一点问题：他们的项目使用了 Shiro 作为权限校验框架，而且那些事务失效的 Service 刚好就是被 Shiro 中自定义 Realm 依赖的 Service ！有了这个线索，下面排查起来就容易一些了。 问题复现咱也自己搞一套，看看是不是像他说的那样吧！ 工程搭建为了快速复现这个问题，咱使用 SpringBoot + shiro-spring-boot-web-starter 构建。( SpringBoot 版本只要在 2.x 就可以，本文测试功能选用 2.2.8 ) pom关键的依赖有下面 4 个： 1&lt;dependency&gt;2 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;3 &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;4&lt;/dependency&gt;56&lt;dependency&gt;7 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;8 &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;9&lt;/dependency&gt;10&lt;dependency&gt;11 &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;12 &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt;13 &lt;version&gt;1.5.3&lt;/version&gt;14&lt;/dependency&gt;1516&lt;dependency&gt;17 &lt;groupId&gt;com.h2database&lt;/groupId&gt;18 &lt;artifactId&gt;h2&lt;/artifactId&gt;19 &lt;version&gt;1.4.199&lt;/version&gt;20&lt;/dependency&gt; RealmShiro 的自定义策略核心就是 Realm ，咱也不整那些花里胡哨的，直接糊弄下算了。 1public class CustomRealm extends AuthorizingRealm &#123;2 3 @Override4 protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;5 if (token.getPrincipal() == null) &#123;6 return null;7 &#125;8 String name = token.getPrincipal().toString();9 // 请求数据库查询是否存在用户，这里省略10 return new SimpleAuthenticationInfo(name, \"123456\", getName());11 &#125;12 13 @Override14 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;15 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();16 // 请求数据库/缓存加载用户的权限，这里暂时使用一组假数据17 authorizationInfo.addStringPermissions(Arrays.asList(\"aa\", \"bb\", \"cc\"));18 return authorizationInfo;19 &#125;20&#125; 配置类只声明 Realm 还不够，需要定义几个 Bean 来补充必需的组件才行。 1@Configuration2public class ShiroConfiguration &#123;3 4 // 自定义Realm注册5 @Bean6 public CustomRealm authorizer() &#123;7 return new CustomRealm();8 &#125;9 10 // 动态代理创建器（上面没有导入AOP）11 @Bean12 public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() &#123;13 DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();14 advisorAutoProxyCreator.setProxyTargetClass(true);15 return advisorAutoProxyCreator;16 &#125;17 18 // 过滤器定义，此处选择全部放行，方便调试19 @Bean20 public ShiroFilterChainDefinition filterChainDefinition() &#123;21 DefaultShiroFilterChainDefinition filterChainDefinition = new DefaultShiroFilterChainDefinition();22 filterChainDefinition.addPathDefinition(\"/**\", \"anon\");23 return filterChainDefinition;24 &#125;25&#125; 数据库配置快速搭建临时测试的、结构很简单的数据库，选择 h2 内存数据库更为合适。 application.properties 中配置 h2 的数据源及初始化数据库的 SQL ： 1spring.datasource.driver-class-name=org.h2.Driver2spring.datasource.url=jdbc:h2:mem:shiro-test3spring.datasource.username=sa4spring.datasource.password=sa5spring.datasource.platform=h267spring.datasource.schema=classpath:sql/schema.sql8spring.datasource.data=classpath:sql/data.sql910spring.h2.console.settings.web-allow-others=true11spring.h2.console.path=/h212spring.h2.console.enabled=true resources 目录下创建 sql 文件夹，并创建两个 .sql 文件，分别声明数据库表的结构和数据： 1create table if not exists sys_department (2 id varchar(32) not null primary key,3 name varchar(32) not null4);56---78insert into sys_department (id, name) values ('idaaa', 'testaaa');9insert into sys_department (id, name) values ('idbbb', 'testbbb');10insert into sys_department (id, name) values ('idccc', 'testccc');11insert into sys_department (id, name) values ('idddd', 'testddd'); 编写测试代码下面就可以按照三层架构来写一些很简单的测试代码了。 DemoDao这里咱就不整合 MyBatis / Hibernate 了，直接使用原生的 JdbcTemplate 就可以： 1@Repository2public class DemoDao &#123;3 4 @Autowired5 JdbcTemplate jdbcTemplate;6 7 public List&lt;Map&lt;String, Object&gt;&gt; findAll() &#123;8 return jdbcTemplate.query(\"select * from sys_department\", new ColumnMapRowMapper());9 &#125;10 11 public int save(String name) &#123;12 return jdbcTemplate.update(\"insert into sys_department (id, name) values (?, ?)\",13 UUID.randomUUID().toString().replaceAll(\"-\", \"\"), name);14 &#125;15 16 public int update(String id, String name) &#123;17 return jdbcTemplate.update(\"update sys_department set name = ? where id = ?\", name, id);18 &#125;19&#125; DemoService + DemoService2声明一个会触发抛出运行时异常的方法，并标注 @Transactional 注解： 1@Service2public class DemoService &#123;3 4 @Autowired5 DemoDao demoDao;6 7 @Transactional(rollbackFor = Exception.class)8 public void doTransaction() &#123;9 demoDao.save(\"aaaaaaaa\");10 int i = 1 / 0;11 demoDao.update(\"18\", \"ccc\");12 &#125;13&#125; DemoService2 同样的代码，仅仅是类名不同，代码不再贴出。 DemoControllerController 里面同时依赖这两个 Service ： 1@RestController2public class DemoController &#123;3 4 @Autowired5 DemoService demoService;6 7 @Autowired8 DemoService2 demoService2;9 10 @GetMapping(\"/doTransaction\")11 public String doTransaction() &#123;12 demoService.doTransaction();13 return \"doTransaction\";14 &#125;15 16 @GetMapping(\"/doTransaction2\")17 public String doTransaction2() &#123;18 demoService2.doTransaction();19 return \"doTransaction2\";20 &#125;21&#125; Realm依赖Service最后，让自定义的 Realm 依赖咱刚写的 DemoService ： 1public class CustomRealm extends AuthorizingRealm &#123;2 3 @Autowired4 DemoService demoService;5 // ...... 运行测试运行 SpringBoot 的主启动类，在浏览器输入 http://localhost:8080/h2 输入刚才在 properties 文件中声明的配置，即可打开 h2 数据库的管理台。 执行 SELECT * FROM SYS_DEPARTMENT ，可以发现数据已经成功初始化了： 下面测试事务，在浏览器输入 localhost:8080/doTransaction ，浏览器自然会报除零异常，但刷新数据库，会发现数据库真的多了一条 insert 过去的数据！请求 /doTransaction2 则不会插入新的数据。 到这里，问题就真的发生了，下面要想办法解决这个问题才行。 问题排查既然两个 Service 在代码上完全一致，只是一个被 Realm 依赖了，一个没有依赖而已，那总不能是这两个 Service 本来就不一样吧！ 检查两个Service对象将断点打在 /doTransaction 对应的方法上，Debug 重新启动工程，待断点落下后，发现被 Realm 依赖的 DemoService 不是代理对象，而没有被 Realm 依赖的 DemoService2 经过事务的增强，成为了一个代理对象： 所以由此就可以看到问题所在了吧！上面的那个 DemoService 都没经过事务代理，凭什么能支持事务呢？？？ 检查Service的创建时机既然两个 Service 都不是一个样的，那咱就看看这俩对象都啥时候创建的吧！给 DemoService 上显式的添加上无参构造方法，方便过会 Debug ： 1@Service2public class DemoService &#123;3 4 public DemoService() &#123;5 System.out.println(\"DemoService constructor run ......\");6 &#125; 重新以 Debug 运行，等断点打在构造方法中，观察方法调用栈： 看上去还比较正常吧，但如果往下拉到底，这问题就太严重了： 哦，合着我这个 DemoService 在 refresh 方法的后置处理器注册步骤就已经创建好了啊！小伙伴们要知道，SpringFramework 中 ApplicationContext 的初始化流程，一定是先把后置处理器都注册好了，再创建单实例 Bean 。但是这里很明显是后置处理器还没完全处理完，就引发单实例 Bean 的创建了！ 问题解决问题终于找明白了，咋解决呢？其实网上有的是现成的文章了： spring boot shiro 事务无效 shiro导致springboot事务不起效解决办法 spring + shiro 配置中部分事务失效分析及解决方案 总的来看，解决方案的核心在于：如何让 Realm 创建时不立即依赖创建 DemoService ，所以就有两种解决方案了：要么延迟初始化 DemoService ，要么把自定义的 Realm 和 SecurityManager 放在一个额外的空间，利用监听器机制创建它们 。具体的实现可以参照上面文章的写法，这里就不赘述了。 原理扩展解决问题之后，如果能从这里面了解到一点更深入的原理知识，想必那是最好不过了。下面就这个问题出现的原因，以及上面 @Lazy 方案的原理，咱都深入解析一下。 Shiro提早创建Realm的原因既然上面看到了方法调用栈中，DemoService 被自定义 Realm 依赖后在 ApplicationContext 的 refresh 阶段的 registerBeanPostProcessors 中就已经被触发创建，可它为什么非要搞这一出呢？自定义 Realm 放到 finishBeanFactoryInitialization 中统一创建不好吗？下面咱通过 Debug 研究问题的成因。 Debug运行DemoService 中的断点不要去掉，重新 Debug 让断点停在那里，翻到最底下的调用栈，查看那个正在创建的 BeanPostProcessor ，发现它的名称是 shiroEventBusAwareBeanPostProcessor ： Shiro的后置处理器创建翻开创建 shiroEventBusAwareBeanPostProcessor 的位置，在 ShiroBeanAutoConfiguration 中，它又依赖了一个 EventBus ： 1@Bean2@ConditionalOnMissingBean3@Override4public ShiroEventBusBeanPostProcessor shiroEventBusAwareBeanPostProcessor() &#123;5 return super.shiroEventBusAwareBeanPostProcessor();6&#125;78protected ShiroEventBusBeanPostProcessor shiroEventBusAwareBeanPostProcessor() &#123;9 return new ShiroEventBusBeanPostProcessor(eventBus());10&#125; 顺着方法调用栈往上爬，找到下一个 doCreateBean ，发现确实有创建 eventBus 的部分： 再往上爬，发现这上面有一个 wrapIfNecessary 方法的调用，很明显这是要搞 AOP 增强了啊： AOP 的增强需要先获取到增强器，继续往上爬方法调用，在 findAdvisorBeans 方法中找到了两个适配的增强器： 上面的是 Shiro 的授权相关的增强器，下面是 SpringFramework 中的事务控制增强器。 触发AOP增强器的创建根据迭代顺序，先取出下面的事务控制增强器 TransactionAdvisor ，由于获取到增强器的 Bean 也是需要走统一的 getBean 方法，所以在方法调用栈中，咱又一次看到了 getBean 方法，继续往下创建。 由于在 SpringFramework 中，使用 @Configuration + @Bean 声明的 Bean ，都是要先把配置类初始化好，才能创建 Bean 。所以继续往上爬调用栈时，会发现它并没有接着创建 Shiro 的增强器 authorizationAttributeSourceAdvisor ，而是先初始化了声明有 TransactionAttributeSourceAdvisor 的配置类 ProxyTransactionManagementConfiguration ： 再往上走，发现又出现了一次 wrapIfNecessary 方法，说明配置类也会被 AOP 增强。那就重复一遍上面的步骤，继续遇到这两个增强器。 这个时候可能有小伙伴产生疑问了：这次创建就是因为上面的 TransactionAttributeSourceAdvisor 创建才跟过来的，这次还要再创建，这是闹哪出呢？放心，咱都想到这个问题了，人家写 SpringFramework 的大佬们能想不到吗？所以在创建之前，它加了一个判断： 1if (this.beanFactory.isCurrentlyInCreation(name)) &#123;2 // 如果当前bean正在创建，则跳过3 if (logger.isTraceEnabled()) &#123;4 logger.trace(\"Skipping currently created advisor '\" + name + \"'\");5 &#125;6&#125;7else &#123;8 try &#123;9 advisors.add(this.beanFactory.getBean(name, Advisor.class));10 &#125; 这里巧妙的利用了 singletonsCurrentlyInCreation 这个集合，判断了当前增强器是否在创建，这样就不会出现重复创建无限死循环的问题了。 singletonsCurrentlyInCreation 的存放是在 getSingleton 方法调用时就已经放进去了，所以能很稳妥的记录下当前正在创建的所有 Bean ，防止死循环重复创建。 Shiro增强器的创建上面的事务控制增强器跳过去了，那就可以创建 Shiro 的增强器了： 这次没有再出现那些幺蛾子，但是这个增强器本身依赖一个 SecurityManager ： 那就继续创建呗，创建 SecurityManager 的过程中又出现了新的依赖： 这个 authorizer ，就是咱上面在 ShiroConfiguration 中注册的自定义 Realm 。 看到这里了，后续的步骤想必不用我说小伙伴们也能自己想到了吧：Realm 的创建又需要依赖 DemoService ，而 DemoService 在创建时由于事务控制增强器还没有创建好，所以无法代理 DemoService ，最终注入到 Realm 的 DemoService 就是不带事务的。 小结捋一捋整个流程哈，整个创建过程经历了以下几个层级的依赖创建： ApplicationContext 的 refresh 方法要创建 BeanPostProcessor ShiroEventBusBeanPostProcessor 的创建需要依赖 EventBus EventBus 创建时需要被 AOP 增强，触发 AOP 增强器的创建逻辑 此时 AOP 增强器有 2 个，分别是事务控制增强器，和 Shiro 的增强器 首先创建事务控制的 AOP 增强器 TransactionAttributeSourceAdvisor ，由于它定义在配置类中，又触发配置类的创建 配置类创建时也要被 AOP 增强，再一次触发 AOP 增强器的创建逻辑 此时事务控制增强器正在被创建，所以被跳过了 触发 Shiro 增强器的创建，而 Shiro 增强器又依赖 SecurityManager SecurityManager 又依赖 authorizer ，也就是自定义的 Realm 自定义 Realm 依赖 DemoService ，触发 DemoService 的创建 DemoService 创建后要被事务 AOP 增强，但此时事务控制增强器还没有完全创建好，所以无法代理，导致 DemoService 不带事务 @Lazy解决该问题的原理上面解决方案的第三篇文章，他提到可以用 @Lazy 注解解决问题，我在翻文章时有人说不能用（他把 @Lazy 注解标注到 DemoService 类上了），讲道理可能是他不会用才这么说的（￣へ￣）。其实用 @Lazy 注解是完全可行的，不过标注的位置要对，真正要标注的位置是自定义 Realm 的 DemoService 成员上： 1@Autowired2@Lazy3DemoService demoService; 下面咱解释下为什么 @Lazy 标注在自定义 Realm 的依赖上好用，标注在 DemoService 类上不好用。 测试-@Lazy标注在DemoService上将 @Lazy 注解标注到 DemoService 的类上： 1@Service2@Lazy3public class DemoService 重新 Debug ，发现断点落在 DemoService 的构造方法时，refresh 的动作仍然停在 registerBeanPostProcessors 步骤，说明将 @Lazy 标注在 DemoService 上是不可行的，这也就是上面我提的那个文章里说 @Lazy 不可行。 测试-@Lazy标注在自定义Realm的依赖上去掉上面 DemoService 类上的 @Lazy ，在自定义 Realm 的 DemoService 依赖上标注，重新 Debug，观察断点停下时 refresh 执行的步骤： 可以发现已经到了可以正常初始化单实例 Bean 的时机了，此时创建的 DemoService 就不会有问题了。 放行断点，待应用启动完成后，浏览器再发送 /doTransaction 的请求，发现这次事务已经生效了。 到这里，就验证了 @Lazy 的正确使用方法。 但是！！！不要着急！下面咱再扩展一点原理哈 ~ ~ ~ 想一下，此时这个 DemoService 是啥玩意触发创建的？ 答案很明显是 DemoController ，因为 Controller 还依赖着 Service 呢。 测试-@Lazy标注Realm+Controller继续测试，把自定义 Realm 和 DemoController 两个类的 DemoService 依赖都标注上 @Lazy ，重新 Debug ，待断点停下后，想一下此时 DemoService 又是谁触发它创建的呢？ 答案也不难猜，是 IOC 容器本身创建的，因为 DemoService 所有被依赖的关系都延迟加载了，但 IOC 容器本身还要预先创建好所有的单实例 Bean ，所以 DemoService 还是在 IOC 容器启动的过程中创建了。 测试-@Lazy全标注继续，这次把 DemoService 上也标注上 @Lazy ，重新 Debug ，这次应用没有落在断点上直接启动了，说明 IOC 容器本身发现 DemoService 也可以延迟创建，就跳过去了，所以 IOC 容器初始化的全过程中 DemoService 都没有创建。 小结总结一下 @Lazy 的使用规则和对应的原理： @Lazy 标注在 Bean 的类上：告诉 IOC 容器，在容器初始化阶段不要实例化我 @Lazy 标注在其他 Bean 的依赖上：告诉 IOC 容器，在创建这个标注了 @Lazy 的 Bean 时，不要立即处理我标注的这个依赖 本文涉及到的所有源码可以从 GitHub 中找到：https://github.com/LinkedBear/juejin-posts-sources 【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】","categories":[{"name":"不懂就问","slug":"不懂就问","permalink":"http://yoursite.com/categories/%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"},{"name":"声明式事务","slug":"声明式事务","permalink":"http://yoursite.com/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"}]},{"title":"Spring中使用的设计模式，你都能说全吗？[下]","slug":"Spring中使用的设计模式，你都能说全吗？[下]","date":"2020-06-13T05:16:55.000Z","updated":"2020-06-28T07:07:04.448Z","comments":true,"path":"2020/06/13/Spring中使用的设计模式，你都能说全吗？[下]/","link":"","permalink":"http://yoursite.com/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8B]/","excerpt":"","text":"这是 Spring 面试题系列的第二篇 【Spring 中的设计模式】 下半部分， 本篇只回答一个问题： Spring 中使用了哪些设计模式？分别都是如何实现的？回顾一下上一篇的概述，从整体上讲，SpringFramework 中使用了 11 种设计模式： 单例模式+原型模式 工厂模式 代理模式 策略模式 模板方法模式 观察者模式 适配器模式 装饰者模式 外观模式 委派模式（不属于GoF23） 这一篇咱把下面的 6 个设计模式也详细解析一下。 喜欢本文的小伙伴不要忘记点赞呀 ~ ~ ~ 三克油！！！ 模板方法模式模板方法模式，在 SpringFramework 中使用的那是相当的多啊！即便是初学 SpringFramework ，在学习到 jdbc 部分，也应该接触过一个模板方法模式的体现，就是 JdbcTemplate 的回调机制：（贴两个比较常见的经典方法） 1public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;2 return result(query(sql, new RowMapperResultSetExtractor&lt;&gt;(rowMapper)));3&#125;45public List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql) throws DataAccessException &#123;6 return query(sql, getColumnMapRowMapper());7&#125; 在调用时，只需要一句话就够了： 1List&lt;Map&lt;String, Object&gt;&gt; datas = jdbcTemplate.queryForList(\"select * from user\"); 小伙伴们可能会一脸懵，这么个方法就体现模板方法模式了吗？我也看不出来啊？莫慌，下面咱先回顾下原生 jdbc 的操作步骤，慢慢自然就明白了。 原生jdbc使用步骤原生的 jdbc 操作需要以下这么多步骤： 1// 注册驱动2Class.forName(\"com.mysql.jdbc.Driver\");3// 获取连接4Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"root\", \"123456\");5// 编写SQL获取预处理对象6PreparedStatement statement = connection.prepareStatement(\"select * from user\");7// 执行SQL获取结果集8ResultSet resultSet = statement.executeQuery();9// 封装结果数据10List&lt;Map&lt;String, Object&gt;&gt; datas = new ArrayList&lt;&gt;();11while (resultSet.next()) &#123;12 Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();13 data.put(\"id\", resultSet.getString(\"id\"));14 data.put(\"name\", resultSet.getString(\"name\"));15 datas.add(data);16&#125;17// 关闭连接18resultSet.close();19statement.close();20connection.close();21// 返回/输出数据22System.out.println(datas); 但是，这里面的操作有很多是重复的，所以这一段代码可以抽取为几个方法： 1// 获取连接2public Connection getConnection() throws Exception &#123;3 Class.forName(\"com.mysql.jdbc.Driver\");4 return DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"root\", \"123456\");5&#125;67// 封装数据8public List&lt;Map&lt;String, Object&gt;&gt; encapsulate(ResultSet resultSet) throws SQLException &#123;9 List&lt;Map&lt;String, Object&gt;&gt; datas = new ArrayList&lt;&gt;();10 while (resultSet.next()) &#123;11 Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();12 data.put(\"id\", resultSet.getString(\"id\"));13 data.put(\"name\", resultSet.getString(\"name\"));14 datas.add(data);15 &#125;16 return datas;17&#125;1819// 关闭连接20public void close(Connection connection, PreparedStatement statement, ResultSet resultSet) throws SQLException &#123;21 resultSet.close();22 statement.close();23 connection.close();24&#125; 如此下来，主干代码就只剩下这些了： 1public void query() throws Exception &#123;2 Connection connection = getConnection();3 // 编写SQL获取预处理对象4 PreparedStatement statement = connection.prepareStatement(\"select * from user\");5 // 执行SQL获取结果集6 ResultSet resultSet = statement.executeQuery();7 // 封装结果数据8 List&lt;Map&lt;String, Object&gt;&gt; datas = encapsulate(resultSet);9 close(connection, statement, resultSet);10 // 返回/输出数据11 System.out.println(datas);12&#125; 那最后稍微调整一下，就可以成为一个通用的方法： 1public List&lt;Map&lt;String, Object&gt;&gt; query(String sql, List&lt;Object&gt; params) throws Exception &#123;2 Connection connection = getConnection();3 // 编写SQL获取预处理对象4 PreparedStatement statement = connection.prepareStatement(sql);5 // 填充占位符参数6 for (int i = 0; i &lt; params.size(); i++) &#123;7 statement.setObject(i + 1, params.get(i));8 &#125;9 // 执行SQL获取结果集10 ResultSet resultSet = statement.executeQuery();11 // 封装结果数据12 List&lt;Map&lt;String, Object&gt;&gt; datas = encapsulate(resultSet);13 close(connection, statement, resultSet);14 // 返回数据15 return datas;16&#125; 目前这个方法已经可以通用了，不过只能返回 Map ，如果想返回模型类对象怎么办呢？这样咱就可以扩展一个自定义结果集封装的方法，让调用者自己决定如何封装。再次改动的代码可以像如下优化： 1public &lt;T&gt; List&lt;T&gt; query(String sql, List&lt;Object&gt; params, Function&lt;ResultSet, List&lt;T&gt;&gt; encapsulate) throws Exception &#123;2 Connection connection = getConnection();3 // 编写SQL获取预处理对象4 PreparedStatement statement = connection.prepareStatement(sql);5 // 填充占位符参数6 for (int i = 0; i &lt; params.size(); i++) &#123;7 statement.setObject(i + 1, params.get(i));8 &#125;9 // 执行SQL获取结果集10 ResultSet resultSet = statement.executeQuery();11 // 封装结果数据（借助Function接口实现结果集封装）12 List&lt;T&gt; datas = encapsulate.apply(resultSet);13 close(connection, statement, resultSet);14 // 返回数据15 return datas;16&#125; 看最后一个参数，我让方法的调用者传一个 Function&lt;ResultSet, List&lt;T&gt;&gt; 类型的自定义处理逻辑，这样返回的数据究竟是什么类型我也就不用管了，完全由调用者自己决定。 到这里，模板方法模式就得以体现了，整个查询的动作我只需要让方法调用者传 SQL 、SQL 中可能出现的参数，以及自定义的结果集封装逻辑，其余的动作都不需要方法调用者关注。 可是，这跟 JdbcTemplate 又有什么关系呢？？？ JdbcTemplate中体现的模板方法我上面不是摘出来一个 JdbcTemplate 的方法嘛： 1public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;2 return result(query(sql, new RowMapperResultSetExtractor&lt;&gt;(rowMapper)));3&#125; 咱点进去看 query 方法的实现： 1public &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;2 // assert logger ......34 class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;5 @Override6 @Nullable7 public T doInStatement(Statement stmt) throws SQLException &#123;8 ResultSet rs = null;9 try &#123;10 rs = stmt.executeQuery(sql);11 return rse.extractData(rs);12 &#125;13 finally &#123;14 JdbcUtils.closeResultSet(rs);15 &#125;16 &#125;17 @Override18 public String getSql() &#123;19 return sql;20 &#125;21 &#125;2223 return execute(new QueryStatementCallback());24&#125; 注意看方法参数列表的最后一个：ResultSetExtractor ，它是一个函数式接口，而且它只有一个方法，就是根据结果集返回泛型类型的数据： 1@FunctionalInterface2public interface ResultSetExtractor&lt;T&gt; &#123;3 @Nullable4 T extractData(ResultSet rs) throws SQLException, DataAccessException;5&#125; 是不是这个设计跟我上面演示的思路基本一致了？这就是 JdbcTemplate 中体现的模板方法模式。 除了这些 xxxTemplate 中有体现，其实在 SpringFramework 中的最底层 IOC 容器模型，BeanFactory 和 ApplicationContext ，以及 SpringWebMvc 中的 HandlerMapping 、HandlerAdapter 等等，都有很多模板方法模式的体现。下面咱也举两个例子来体会。 ApplicationContext中体现的模板方法说到 ApplicationContext ，最经典的方法莫过于 AbstractApplicationContext 中的 refresh ：（只截取很少的一部分） 1public void refresh() throws BeansException, IllegalStateException &#123;2 synchronized (this.startupShutdownMonitor) &#123;3 // ......4 try &#123;5 // ......6 // Initialize other special beans in specific context subclasses.7 onRefresh();8 // ......9 &#125; // catch finally ......10 &#125;11&#125; 在这个方法中有一个动作是 onRefresh 方法，点进去发现它是一个空方法： 1/**2 * Template method which can be overridden to add context-specific refresh work.3 * Called on initialization of special beans, before instantiation of singletons.4 * &lt;p&gt;This implementation is empty.5 * @throws BeansException in case of errors6 * @see #refresh()7 */8protected void onRefresh() throws BeansException &#123;9 // For subclasses: do nothing by default.10&#125; 注意看文档注释的前两个单词：Template method ！！！文档注释已经告诉咱这是一个模板方法了！而且方法体中也说了，它默认不做任何事情，留给子类扩展使用。由此咱就可以了解 ApplicationContext 中最经典的模板方法模式设计之一了。 HandlerMapping中体现的模板方法在 DispatcherServlet 接收到客户端的请求，要进行实际处理时，需要先根据 uri 寻找能匹配的 HandlerMapping ，这一步它会委托 HandlerMapping 帮忙找（这里面涉及到委派了，下面会讲到），而这个寻找 HandlerMapping 的动作在 AbstractHandlerMapping 的 getHandler 方法中： 1public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;2 Object handler = getHandlerInternal(request);3 if (handler == null) &#123;4 handler = getDefaultHandler();5 &#125;6 // ......7&#125; 这里面第一句就会调另一个 getHandlerInternal 方法，而这个方法在 AbstractHandlerMapping 中是自己定义的抽象方法： 1protected abstract Object getHandlerInternal(HttpServletRequest request) throws Exception; 这就是非常经典的模板方法模式的体现了：父类 / 抽象类把逻辑步骤都定义出来，具体的动作让子类实现。 小结SpringFramework 中体现的模板方法模式非常多，包括各种 Template （ JdbcTemplate 、HibernateTemplate 、RedisTemplate 等），以及核心源码内部设计的模板方法（如 AbstractApplicationContext 中的 refresh 套 onRefresh 、AbstractHandlerMapping 中的 getHandler 套 getHandlerInternal 等），它设计的核心思想是父类 / 抽象类把逻辑步骤都定义出来，具体的动作让子类实现。 观察者模式观察者模式，也被称为发布订阅模式，其实它还有一个叫法：监听器模式。那说到监听器，是不是就立马想起来 SpringFramework 中的 ApplicationListener 了？对了，就这么回事，其实都不用展开讲，小伙伴们也能答得出来了。不过，想回答的漂亮，还需要额外知道一点点东西。 观察者模式的核心咱都知道，观察者模式的两大核心是：观察者、被观察主题。对应到 SpringFramework 中的概念分别是：事件、监听器。 不过我个人比较喜欢把 SpringFramework 的事件驱动核心概念划分为 4 个：事件源、事件、广播器、监听器。 事件源：发布事件的对象 事件：事件源发布的信息 广播器：事件真正广播给监听器的对象【即 ApplicationContext 】 ApplicationContext 接口有实现 ApplicationEventPublisher 接口，具备事件广播器的发布事件的能力 监听器：监听事件的对象 在 SpringFramework 中，事件源想要发布事件，需要注入事件广播器，通过事件广播器来广播事件。 SpringFramework使用监听器以下是一个最简单的监听器使用实例： 事件模型1public class ServiceEvent extends ApplicationEvent &#123;2 3 public ServiceEvent(Object source) &#123;4 super(source);5 &#125;6&#125; 事件源1@Service2public class EventService implements ApplicationContextAware &#123;3 4 private ApplicationContext ctx;5 6 public void publish() &#123;7 ctx.publishEvent(new ServiceEvent(this));8 &#125;9 10 @Override11 public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123;12 this.ctx = ctx;13 &#125;14&#125; 监听器1@Component2public class MyListener implements ApplicationListener&lt;ServiceEvent&gt; &#123;3 4 @Override5 public void onApplicationEvent(ServiceEvent event) &#123;6 System.out.println(\"监听到ServiceEvent事件：\" + event);7 &#125;8&#125; 小结SpringFramework 中实现的观察者模式就是事件驱动机制，可以通过自定义监听器，监听不同的事件，完成不同的业务处理。 适配器模式了解 SpringWebMvc 中 DispatcherServlet 的工作原理，应该对 HandlerAdapter 不陌生，它就是辅助执行 Controller 中具体方法的适配器。如果只答这一句当然够用，不过回答的再细致点，那自然是更好的。 DispatcherServlet委派HandlerAdapter在 DispatcherServlet 的 doDispatch 方法中，有一句代码是根据 HandlerMapping 中的 Handler 获取 HandlerAdapter ： 1HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); 这个 Handler 就是目标 Controller 中的目标方法，在适配的过程中它会寻找现有的所有 HandlerAdapter 是否能支持执行这个 Handler ，根据 RequestMappingHandlerMapping 的命名，自然也能猜得出来，真正负责执行目标 Controller 中方法的是 RequestMappingHandlerAdapter 。 HandlerAdapter执行Handler在 RequestMappingHandlerAdapter 中，执行目标 Controller 中方法的核心方法是 handle ： 1public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)2 throws Exception &#123;3 return handleInternal(request, response, (HandlerMethod) handler);4&#125; 看到了 handleInternal ，是不是又想到了模板方法？没错，就是这个设计。 在底层，核心的执行 Handler 的逻辑其实就是反射： 1protected Object doInvoke(Object... args) throws Exception &#123;2 ReflectionUtils.makeAccessible(getBridgedMethod());3 try &#123;4 // method.invoke5 return getBridgedMethod().invoke(getBean(), args);6 &#125; // catch ......7&#125; 由此可知，HandlerAdapter 的执行其实也没有很神秘，最终还是玩的反射而已。 小结SpringFramework 中的适配器模式，体现之一是 HandlerAdapter 辅助执行目标 Controller 中的方法，底层是借助反射执行。 装饰者模式装饰者跟代理、适配器都有些相似，不过装饰者更强调的是在原有的基础上附加额外的动作 / 方法 / 特性，而代理模式有控制内部对象访问的意思。 SpringFramework 中体现的装饰者模式，在核心源码中并没有体现，不过在缓存模块 spring-cache 中倒是有一个体现：TransactionAwareCacheDecorator 。 Bean的包装了解过 Bean 的创建流程，应该知道最底层的创建动作发生在 AbstractAutowireCapableBeanFactory 的 doCreateBean 中，而这里面第一波动作就把 BeanWrapper 都创建好了： 1protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)2 throws BeanCreationException &#123;3 // Instantiate the bean.4 BeanWrapper instanceWrapper = null;5 // ......6 if (instanceWrapper == null) &#123;7 instanceWrapper = createBeanInstance(beanName, mbd, args);8 &#125; 注意看，它创建的动作是 createBeanInstance ，意为“创建 bean 实例”，那就可以理解为：bean 对象已经在这个动作下实例化好了。深入这个方法，最终可以在 createBeanInstance 方法的最后一句 return 中看到 bean 实例的创建，以及 BeanWrapper 的包装： 1protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;2 // ......3 return instantiateBean(beanName, mbd);4&#125;56protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;7 try &#123;8 Object beanInstance;9 // 实例化对象......10 BeanWrapper bw = new BeanWrapperImpl(beanInstance);11 initBeanWrapper(bw);12 return bw;13 &#125; // catch ......14&#125; 看到下面的代码中，它把 bean 的实例对象包装为一个 BeanWrapper ，形成装饰者。 SpringCache的核心设计SpringCache 主做的是应用业务层级的缓存，它与 JSR107 有一定关系但又不同（Spring 自己实现了一套缓存，就是这个 SpringCache ）。 用一张简单的图解释 SpringCache 的核心，大概可以这样理解： 一个 CacheManager 中包含多个 Cache ，一个 Cache 可以简单理解为一个 Map&lt;String, T&gt; 。 从 Cache 接口的设计，也能看出来就是 Map 的思路：（核心方法） 1@Nullable2ValueWrapper get(Object key);34void put(Object key, @Nullable Object value); Cache的装饰者体现TransactionAwareCacheDecorator 作为装饰者，那肯定要实现 Cache 接口，并且组合一个 Cache 的对象： 1public class TransactionAwareCacheDecorator implements Cache &#123;23 private final Cache targetCache; 这里面，真正体现装饰者的位置是在 put 方法中： 1public void put(final Object key, @Nullable final Object value) &#123;2 if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;3 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() &#123;4 @Override5 public void afterCommit() &#123;6 TransactionAwareCacheDecorator.this.targetCache.put(key, value);7 &#125;8 &#125;);9 &#125;10 else &#123;11 this.targetCache.put(key, value);12 &#125;13&#125; 可以发现，它会在 put 之前，检查当前线程中是否存在已经开启的事务：如果存在事务，则会将 put 操作注册到事务结束后。 小结SpringFramework 中实现的装饰者模式，体现之一是在 SpringCache 缓存的存放逻辑中，如果执行缓存时的线程中存在事务，则缓存的保存会在事务结束后再执行。 外观模式外观模式算是比较简单的模式，它强调的是统一入口，内部组合。一个经典的体现是在 IOC 解析 Bean 的定义信息时使用的 BeanDefinitionLoader 。 在 BeanDefinitionLoader 中，它组合了 4 种不同类型的解析器： 1class BeanDefinitionLoader &#123;2 // 注解式Bean定义解析器3 private final AnnotatedBeanDefinitionReader annotatedReader;4 // xml文件的Bean定义解析器5 private final XmlBeanDefinitionReader xmlReader;6 // Groovy的Bean定义解析器7 private BeanDefinitionReader groovyReader;8 // 类路径的Bean定义扫描器9 private final ClassPathBeanDefinitionScanner scanner; 尽管组合的解析器很多，但最终暴露出来的方法是同样的名：load 。 1private int load(Class&lt;?&gt; source) &#123; /* ... */ &#125;2private int load(GroovyBeanDefinitionSource source) &#123; /* ... */ &#125;3private int load(Resource source) &#123; /* ... */ &#125;4private int load(Package source) &#123; /* ... */ &#125;5private int load(CharSequence source) &#123; /* ... */ &#125; 由此可以体现出很经典的外观模式。 委派模式委派模式本不属于 GoF23 中的设计模式，不过既然咱在前面也反复提到过几次，这里咱还是摘出来说两句。 在 DispatcherServlet 的核心工作流程中，委派模式体现在 HandlerMapping 、HandlerAdapter 、ViewResolver 接受 DispatcherServlet 的委派，如下面的整体流程图： 到这里，SpringFramework 中使用的设计模式就差不多整理完了，想要回答的尽可能全面、准确、有深度，小伙伴们要好好理解这些模式的设计、思想，以及 SpringFramework 中的源码实现，这样在被面试官问到才会更加游刃有余。 【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】","categories":[{"name":"SpringFramework","slug":"SpringFramework","permalink":"http://yoursite.com/categories/SpringFramework/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Spring中使用的设计模式，你都能说全吗？[上]","slug":"Spring中使用的设计模式，你都能说全吗？[上]","date":"2020-06-09T05:16:55.000Z","updated":"2020-06-28T07:06:53.647Z","comments":true,"path":"2020/06/09/Spring中使用的设计模式，你都能说全吗？[上]/","link":"","permalink":"http://yoursite.com/2020/06/09/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8A]/","excerpt":"","text":"这是 Spring 面试题系列的第二篇，本文的主题：Spring 中涉及到的设计模式，如何在面试中回答的尽可能全面、准确、有深度。 本篇只回答一个问题： Spring 中使用了哪些设计模式？分别都是如何实现的？首先作一个概述，从整体上讲，SpringFramework 中使用了 11 种设计模式： 单例模式+原型模式 工厂模式 代理模式 策略模式 模板方法模式 观察者模式 适配器模式 装饰者模式 外观模式 委派模式（不属于GoF23） 当然，如果只是这么回答，面试官会怎么想：你这。。。不会是在背答案吧！随便揪出一个来细问，可能就翻皮水了 ~ ~ 所以咱不光要知道用了啥，而且还要知道如何用的，在哪里用的，这样才能用自己真正的技术储备征服面试官。 下面咱详细的介绍 11 种设计模式的设计场景和原理。 由于 11 种设计模式全部展开篇幅过长，会分成两篇专栏介绍。 单例模式+原型模式SpringFramework 的 IOC 容器中放了很多很多的 Bean ，默认情况下，Bean 的作用域（ Scope ）是 singleton ，就是单实例的；如果显式声明作用域为 prototype ，那 Bean 的作用域就会变为每次获取都是一个新的，即原型 Bean 。这个知识点本应该在 SpringFramework 最基础阶段就应该知道的，咱也不多啰嗦。关键的问题是，如果我定义的 Bean 声明了 prototype ，那 SpringFramework 肯定知道我要搞原型 Bean ；但我定义 Bean 的时候没声明 Scope ，它怎么就给我默认成单实例的呢？ 下面咱先从最熟悉的 Bean 注册场景出发。（原型模式相对简单，内容已穿插在解释单例模式之中） Bean的注册xml方式注册Bean1&lt;bean class=\"com.example.demo.bean.Person\" scope=\"singleton\"/&gt; 这是最最简单的 Bean 的注册了，这里面如果显式声明了 scope=&quot;singleton&quot; 后，IDE 会报黄（警告）： 很明显它提示了默认值就是 singleton ，咱没必要再主动声明了。这个提示是 IDEA 智能识别的，咱不好找出处，不过咱可以点进去这个 scope ，看一眼 xsd 中的注释： 1&lt;xsd:attribute name=\"scope\" type=\"xsd:string\"&gt;2 &lt;xsd:annotation&gt;3 &lt;xsd:documentation&gt;&lt;![CDATA[4 The scope of this bean: typically \"singleton\" (one shared instance,5 which will be returned by all calls to getBean with the given id), ...... 很明显文档注释的第一句就说了：通常它是 singleton 的。 注解驱动注册Bean注解驱动的方式，都是使用一个 @Scope 注解来声明作用域的： 1@Scope2@Component3public class Person &#123;4 5&#125; 点开 @Scope 注解看源码，可以发现只标注 @Scope 注解，不声明作用域，默认值是空字符串（不是 singleton ）： 1public @interface Scope &#123;23 @AliasFor(\"scopeName\")4 String value() default \"\"; 这个地方可能就会有疑惑了，它声明的是空字符串，可是在 xml 中我配置的是 singleton 啊，这怎么不一样呢？莫慌，下面咱来解析这其中的原因。 默认的作用域标注对 SpringFramework 有一些深入了解的小伙伴应该能意识到我接下来要说什么了：BeanDefinition 。所有 Bean 的定义信息都被 SpringFramework 封装到 BeanDefinition 中了，而作用域的定义就在 BeanDefinition 的抽象实现类 AbstractBeanDefinition 中： 1public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor2 implements BeanDefinition, Cloneable &#123;34 public static final String SCOPE_DEFAULT = \"\"; 这里面一上来就声明了默认的作用域就是空字符串，不是 singleton 。 这个时候可能有的小伙伴就更迷惑了，这里面它都声明了单实例 Bean 是空字符串，那 singleton 还有个卵用呢？判断单实例 Bean 不是应该看作用域是否为 singleton 吗？ 哎，说到这里了，那咱就看看 BeanDefinition 中是如何获取作用域的： 1public String getScope() &#123;2 return this.scope;3&#125; 获取作用域的方式非常简单，这个没啥看的。但是！！！注意继续往下翻，紧跟着下面有一个方法叫 isSingleton ： 1/**2 * Return whether this a &lt;b&gt;Singleton&lt;/b&gt;, with a single shared instance3 * returned from all calls.4 * @see #SCOPE_SINGLETON5 */6@Override7public boolean isSingleton() &#123;8 return SCOPE_SINGLETON.equals(this.scope) || SCOPE_DEFAULT.equals(this.scope);9&#125; 看这里面的判断，它分为了两个部分：是否是 singleton ，或者是否为空串！那这就说得过去了吧，人家设置成空串，意义上也是单实例 Bean 。 Bean的实例化上面咱也知道了，默认情况下 Bean 是单实例的，那 SpringFramework 在 IOC 容器初始化的时候，是如何知道这些 Bean 是否是单实例的，同时初始化并保存的呢？下面咱跟进底层初始化逻辑中看一眼。 本部分只粗略介绍 Bean 的初始化流程，详细的解析可以参照我的 SpringBoot 源码小册 14 章详细学习。 在 AbstractBeanFactory 中，getBean 方法会调用到 doGetBean ，这个方法的篇幅非常长，这里只剪出框框： 1protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,2 @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123;3 final String beanName = transformedBeanName(name);4 Object bean;56 // Eagerly check singleton cache for manually registered singletons.7 // 最开始先检查单实例对象缓存池中是否已经有对应的bean了8 Object sharedInstance = getSingleton(beanName);9 // ......10 else &#123;11 // ......12 try &#123;13 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);14 // 检查 ......1516 // Create bean instance.17 if (mbd.isSingleton()) &#123;18 // 单实例Bean19 sharedInstance = getSingleton(beanName, () -&gt; &#123;20 try &#123;21 return createBean(beanName, mbd, args);22 &#125; // catch ......23 &#125;);24 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);25 &#125;2627 else if (mbd.isPrototype()) &#123;28 // 原型Bean29 // It's a prototype -&gt; create a new instance.30 Object prototypeInstance = null;31 try &#123;32 beforePrototypeCreation(beanName);33 // 必定创建全新的对象34 prototypeInstance = createBean(beanName, mbd, args);35 &#125;36 finally &#123;37 afterPrototypeCreation(beanName);38 &#125;39 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);40 &#125;4142 else &#123;43 // 自定义scope44 String scopeName = mbd.getScope();45 final Scope scope = this.scopes.get(scopeName);46 // ......47 &#125;48 &#125; // catch ......49 &#125;50 // ......51 return (T) bean;52&#125; 仔细阅读这个框框流程，一上来它就要先检查单实例对象的缓存池中是否有现成的 Bean 了，没有再往下走。那咱说创建流程的话还是往下走，在 else 块的 try 部分，它会取出当前 Bean 的 BeanDefinition 来判断作用域：如果是 singleton 单实例的，就执行 getSingleton 方法创建单实例对象（底层走 lambda 表达式中的 createBean 方法）；如果是 prototype 原型 Bean ，就执行原型 Bean 的创建流程（直接创建）；如果这些都不是，那就可以认定为自定义 scope ，使用特殊的初始化流程。 所以由此看下来，单实例 Bean 的创建核心方法还是 getSingleton 了，那咱就进到这里面看一眼：（还是只有大框框的流程哈） 1private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);23public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;4 Assert.notNull(beanName, \"Bean name must not be null\");5 synchronized (this.singletonObjects) &#123;6 Object singletonObject = this.singletonObjects.get(beanName);7 if (singletonObject == null) &#123;8 // 检查9 try &#123;10 singletonObject = singletonFactory.getObject();11 newSingleton = true;12 &#125; // catch finally ......13 if (newSingleton) &#123;14 addSingleton(beanName, singletonObject);15 &#125;16 &#125;17 return singletonObject;18 &#125;19&#125; 注意看这里面的设计：它会先去单实例对象缓存池中找是否已经有对应的 bean 了，如果没有，就执行创建 bean 的动作。在创建完成后，它还会将 bean 放入缓存池中，这样以后再取的时候就不会再二次创建了。 小结所以这里面的核心逻辑也就可以总结出来了： SpringFramework 中实现的单例模式，是在 BeanDefinition 中默认配置 singleton 的作用域，在 IOC 容器初始化阶段，将 Bean 创建好，放入单实例对象缓存池（ singletonObjects ）中，实现 Bean 的单实例。 工厂模式提起工厂模式，在 SpringFramework 中最容易联想到的就是 FactoryBean 了吧！但其实 SpringFramework 中不止这一个是工厂，还有很多种其他的，下面咱来列举。 FactoryBeanFactoryBean 本身是一个接口，它本身就是一个创建对象的工厂。如果一个类实现了 FactoryBean 接口，则它本身将不再是一个普通的 bean 对象，不会在实际的业务逻辑中起作用，而是由创建的对象来起作用。 FactoryBean 接口有三个方法： 1public interface FactoryBean&lt;T&gt; &#123;2 // 返回创建的对象3 @Nullable4 T getObject() throws Exception;56 // 返回创建的对象的类型（即泛型类型）7 @Nullable8 Class&lt;?&gt; getObjectType();910 // 创建的对象是单实例Bean还是原型Bean，默认单实例11 default boolean isSingleton() &#123;12 return true;13 &#125;14&#125; 静态工厂这种方式很像咱在最开始学习简单工厂模式中看到的核心工厂，比方说下面这样： 1public class CalculatorFactory &#123;2 // 简单工厂3 public static Calculator getCalculator(String operationType) &#123;4 switch (operationType) &#123;5 case \"+\": 6 return new AddCalculator();7 case \"-\":8 return new SubtractCalculator();9 default: 10 return null;11 &#125;12 &#125;13 14 // 静态工厂15 public static Calculator getAddCalculator() &#123;16 return new AddCalculator();17 &#125;18&#125; 在 SpringFramework 中使用静态工厂，就没有参数这个说法了，只需要声明工厂类和方法即可（所以上面的工厂中我额外写了一个方法）： 1&lt;bean id=\"addCalculator\" class=\"com.example.demo.bean.CalculatorFactory\" factory-method=\"getAddCalculator\"/&gt; 这样注册后得到的 bean ，类型是 AddCalculator 。 实例工厂实例工厂的使用方式与静态工厂很像，只不过静态工厂本身不会注册到 IOC 容器中，但实例工厂会一起注册到 IOC 容器。 调整上面的代码，就可以实现实例工厂的 Bean 注册： 1public class CalculatorFactory &#123;2 // 工厂方法3 public Calculator getAddCalculator() &#123;4 return new AddCalculator();5 &#125;6&#125; 1&lt;bean id=\"calculatorFactory\" class=\"com.example.demo.bean.CalculatorFactory\"/&gt;2&lt;bean id=\"addCalculator\" factory-bean=\"calculatorFactory\" factory-method=\"getAddCalculator\"/&gt; ObjectFactory这个类型可能有些小伙伴会感觉有些陌生，所以我放到了最后写。 1@FunctionalInterface2public interface ObjectFactory&lt;T&gt; &#123;3 T getObject() throws BeansException;4&#125; 结构比 FactoryBean 简单，当然也可以简单地将其理解为 FactoryBean ，但又与其不同。ObjectFactory 一般情况下会作为一个 Bean 注入到其他 Bean 中，在需要用对应的 bean 时主动调用 ObjectFactory 的 getObject 方法获取真正需要的 Bean ；FactoryBean 的 getObject 方法是在 SpringFramework 初始化 Bean 时调用的，所以由此也可以知道两者的调用时机也不一样。 其实这个接口在上面看 Bean 的实例化过程中就遇到过了，在 getSingleton 的两参数方法中，第二个参数就是 ObjectFactory 类型，由它就可以调用 createBean 创建出单实例对象。 小结SpringFramework 中的工厂模式包括内置的 FactoryBean 、ObjectFactory ，以及自定义声明的静态工厂、实例工厂。 代理模式咱都知道，SpringFramework 的两大核心：IOC 、AOP ，AOP 就是体现了代理模式的使用。不过如果只说 AOP 体现了代理模式，那这个也太没水准了，咱要回答的更多更全，才能让面试官意识到你真的有研究过，你真的很懂！ AOP的底层实现SpringFramework 中对 Bean 进行 AOP 增强生成代理对象，核心是一个 BeanPostProcessor ：AnnotationAwareAspectJAutoProxyCreator ，这个名字很长，不过很好记： Annotation：注解式， Aware：注入式 AspectJ：基于 AspectJ 的 AOP AutoProxy：自动代理 Creator：创建器 这样一拆分，是不是感觉容易理解多了呢？ 它的核心作用方法是父类 AbstractAutoProxyCreator 的 postProcessAfterInitialization 方法，底层会调用 wrapIfNessary 方法创建代理对象： 1public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) &#123;2 if (bean != null) &#123;3 Object cacheKey = getCacheKey(bean.getClass(), beanName);4 if (this.earlyProxyReferences.remove(cacheKey) != bean) &#123;5 // 创建AOP代理对象6 return wrapIfNecessary(bean, beanName, cacheKey);7 &#125;8 &#125;9 return bean;10&#125; 至于再往底下，这个就麻烦大了，这里简单总结一下吧，详尽的代理对象创建可以参考 SpringBoot 源码小册的 19 章学习。 被 AOP 增强的 Bean ，会在初始化阶段（此时对象已经创建）被 AnnotationAwareAspectJAutoProxyCreator 处理，整合该 Bean 可能被覆盖到的切面，最终根据 Bean 是否有接口实现，采用 jdk 动态代理或者 Cglib 动态代理构建生成代理对象。 代理对象的创建上面的总结中提到了最终的动态代理创建，这里可以带小伙伴看一眼最底层你们熟悉的创建代理对象的源码。 jdk 动态代理的创建，在 JdkDynamicAopProxy 中，有一个 getProxy 方法，底层实现如下： 1public Object getProxy(@Nullable ClassLoader classLoader) &#123;2 if (logger.isTraceEnabled()) &#123;3 logger.trace(\"Creating JDK dynamic proxy: \" + this.advised.getTargetSource());4 &#125;5 Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);6 findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);7 // jdk原生方法8 return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);9&#125; 看最后一句，是不是突然熟悉了！这个地方就可以在面试中拿出来吹一吹，这样面试官可能就真的认为你把这部分原理都搞明白了哦（狗头）。 Cglib 动态代理的创建，在 CglibAopProxy 的 createProxyClassAndInstance 方法中有创建代理对象的实现： 1protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) &#123;2 enhancer.setInterceptDuringConstruction(false);3 enhancer.setCallbacks(callbacks);4 return (this.constructorArgs != null &amp;&amp; this.constructorArgTypes != null ?5 enhancer.create(this.constructorArgTypes, this.constructorArgs) :6 enhancer.create());7&#125; 看到这里的 Enhancer#create() 方法，是不是又是熟悉的一幕呢？所以由此也知道，框架也只是在咱学过的基础上层层包装增强罢了，最底层的还是不变的。 小结SpringFramework 中的代理模式体现在 AOP 上，它通过后置处理器，整合切面（增强器 Advice ）的逻辑，将原有的 Bean （目标对象 Target ）使用 jdk 或者 Cglib 动态代理增强为代理 Bean 。 策略模式说起 SpringFramework 中实现的策略模式，其实刚刚就提到了：AOP 生成代理对象时，会根据原始 Bean 是否有接口实现，决定使用 jdk 动态代理还是 Cglib 动态代理，这就是典型的策略模式体现。 直接说原理吧，在 DefaultAopProxyFactory 中有策略模式的体现： 1public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;2 if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;3 Class&lt;?&gt; targetClass = config.getTargetClass();4 if (targetClass == null) &#123;5 throw new AopConfigException(\"TargetSource cannot determine target class: \" +6 \"Either an interface or a target is required for proxy creation.\");7 &#125;8 // 策略判断9 if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;10 return new JdkDynamicAopProxy(config);11 &#125;12 return new ObjenesisCglibAopProxy(config);13 &#125;14 else &#123;15 return new JdkDynamicAopProxy(config);16 &#125;17&#125; 中间的这个判断当前要代理的目标对象，类型是否是一个接口，或者目标对象是否为一个代理类。如果是二者之一，则可以直接使用 jdk 的动态代理即可，否则才会使用 Cglib 代理。 【篇幅限制，剩余 6 个设计模式的体现会放在下篇介绍 ~ 小伙伴们记得关注点赞呀，有源码学习需要的可以看我小册 ~ 奥利给】","categories":[{"name":"SpringFramework","slug":"SpringFramework","permalink":"http://yoursite.com/categories/SpringFramework/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Spring的IOC，你真的能解释清楚吗？","slug":"Spring的IOC，你真的能解释清楚吗？","date":"2020-05-18T04:50:55.000Z","updated":"2020-06-28T07:06:38.928Z","comments":true,"path":"2020/05/18/Spring的IOC，你真的能解释清楚吗？/","link":"","permalink":"http://yoursite.com/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/","excerpt":"","text":"一直以来，SpringFramework 作为 Java 企业级开发的老大哥，面试中也常被问到。虽说有些基础性的问题可能不那么特别被面试官和求职者重视，但如果真的问起来，能不能回答的准确、全面、有深度，还是很容易体现出水平的。 在接下来的一个系列中，我会慢慢盘点一些 Spring 中常见但不好回答全面的问题，跟小伙伴们分享。 本文主题：Spring 的 IOC 如何回答的尽可能全面、准确、有深度。 问：什么是IOC？这是一个看上去特别简单、感觉很无脑的问题，很多求职者在回答这个问题时会不加思考、快速回答出一个很简单但同时也没有什么含量的答案。 草率的回答 IOC 是控制反转，Inverse of Control 。 试问一句，亲，你在做名词翻译吗？ 就算真的是在做名词翻译，也不应该只是把这个简称的全称解释出来就完事吧，好歹的展开解释点东西也好吧，作为面试官不应该只想听到这么一点点吧。 方向偏了 IOC 是控制反转，它把对象间的依赖关系的维护权利交给了 Spring ，程序本身不再维护。 这里面大体上把 IOC 的核心思想解释出来了：对象间的依赖关系的维护权利发生了转移，但是请小伙伴们注意，我们在问 IOC ，这个问题仅仅是问 IOC 本身，与具体的技术无关。IOC 不止有 Spring ，只是当下最强大的、使用最广的是 Spring 而已。 所以小伙伴们在回答理论、概念等问题时，不要直接在概念解释中提到具体的技术，技术都是概念和理论的落地实现，不止一种。单把一种拉出来，面试官可能会觉得：你是不是只知道这个？ 一种参考回答 该答案仅供参考，可根据自身的知识储备动态调整。 IOC 全名控制反转 Inverse of Control，它是一种编程原则，它的设计和架构可以实现组件间的解耦，核心思想是将控制权转移出去。 这里面提到了几个点： 编程原则：它是一种理论，而非具体的某种技术落地 组件间的解耦：所谓耦合，就是上面提到的对象间的依赖关系；解耦，就是解除了对象间的依赖关系。 提到解耦，有可能面试官会继续问“什么是解耦”，也有可能不会问 “为什么用 Spring ”了 控制权的转移：IOC 为了实现解耦，将原有的对象间的主动依赖改为被动接收型依赖（由直接 new 变为 set ） 问：IOC与DI的区别如果对 IOC 的实现不是特别了解，或者只是用 SpringFramework 用的太习惯了，亦或是刻板的学习 SpringFramework ，那这个答案通常会是这样的： IOC 就是 DI 。 如果回答出这个答案，而面试官碰巧也跟你一样，那恭喜你“瞎猫碰到死耗子”了！因为这个回答真的大错特错啊，IOC 不止有 DI 的！ 正确的回答应该是： IOC 是一种思想、编程原则，DI 是 IOC 思想的一种实现方式。 IOC 的实现方式有依赖查找（ Dependency lookup ）和依赖注入（ Dependency Injection ）。 上面已经介绍过了，IOC 仅仅是一种思想，它的意图是想让对象间的依赖控制发生转换。用过 SpringFramework 的小伙伴都知道，你没有在哪个地方见过直接写 IOC 的代码，都是由一些实现方式来体现 IOC 的。 如果按照上面这样回答，可能会引来下面一个问题： 依赖查找和依赖注入分别都是什么？如何区分它们？针对这个问题，最好不要一上来就搬出代码解释，最好是先理论后代码。 一般情况下，对比依赖查找和依赖注入，通常可以从以下几个维度对比： 依赖查找 依赖注入 实现方式 使用上下文（容器）主动获取 依赖上下文被动接收 作用目标 通常是方法体内的局部变量，也可以是对象成员 通常是对象成员 API依赖 依赖 IOC 框架的 API（必须操纵容器的 API ） 可以不依赖（暴露 setter 方法即可） applicationContext.getBean(beanName) public void setXXX() { … } 问：SpringFramework中实现的IOC有什么？真的不会有小伙伴只能答出 ApplicationContext 吧，一开始学的时候应该知道还有个 BeanFactory 吧。这是 SpringFramework 中两个核心的 IOC 容器的抽象。BeanFactory 仅仅是提供了一个容器管理的基本能力，ApplicationContext 在此基础上做了更加完善、强大的扩展。具体的对比可以参照下表： Feature BeanFactory ApplicationContext Bean instantiation/wiring —— Bean的实例化和属性注入 Yes Yes Integrated lifecycle management —— 生命周期管理 No Yes Automatic BeanPostProcessor registration —— Bean后置处理器的支持 No Yes Automatic BeanFactoryPostProcessor registration —— BeanFactory后置处理器的支持 No Yes Convenient MessageSource access (for internalization) —— 消息转换服务（国际化） No Yes Built-in ApplicationEvent publication mechanism —— 事件发布机制（事件驱动） No Yes 下面提供一个比较完整的示例答案，小伙伴们可以根据自己的知识储备和理解，调整这里面的一些描述细节： BeanFactory 接口提供了一个抽象的配置和对象的管理机制，ApplicationContext 是 BeanFactory 的子接口，它简化了与 AOP 的整合、消息机制、事件机制，以及对 Web 环境的扩展（ WebApplicationContext 等），BeanFactory 是没有这些扩展的。 ApplicationContext 主要扩展了以下功能：（括号内的部分是解释扩展功能的一些简单描述或者原理底层实现，能回答出来更好） AOP的支持（ AnnotationAwareAspectJAutoProxyCreator 作用于 Bean 的初始化之后 ） 配置元信息（ BeanDefinition 、Environment 、注解等 ） 资源管理（ Resource 抽象 ） 事件驱动机制（ ApplicationEvent 、ApplicationListener ） 消息与国际化（ LocaleResolver ） Environment 抽象（SpringFramework 3.1以后） 问：依赖注入的注入方式？有什么区别？注意这个问题也是与 SpringFramework 无关的，注入的方式本身就应该是依赖注入的实现，至于框架的代码，那是人家对于这个方式的落地。 可从以下几个维度对比： 注入方式 被注入成员是否可变 是否依赖IOC框架的API 使用场景 构造器注入 不可变 否（xml、编程式注入不依赖） 不可变的固定注入 参数注入 不可变 是（只能通过标注注解来侵入式注入） 通常用于不可变的固定注入 setter注入 可变 否（xml、编程式注入不依赖） 可选属性的注入 基本上问这个问题的话，还可能会继续问另一个问题： 你觉得哪种方式好？为什么？“莽夫”应聘者一看终于来开放式问题了，赶紧开始自由发挥了： 我觉得参数注入好，因为我写习惯了，给参数打注解多舒服啊！ 你是这么说了，面试官咋想：就这？就这？？？进而对你的印象可能就会有所减分了。 这种问题，除了要表述主观看法之外，更多的是要根据一些既有的论述来辅助你的观点，最好的论述那一定是官方文档了。 SpringFramework 的官方文档在不同的版本推荐的注入方式是不同的： SpringFramework 4.0.2 及之前是推荐 setter 注入，理由是一个 Bean 有多个依赖时，构造器的参数列表会很长；而且如果 Bean 中依赖的属性不都是必需的话，注入会变得更麻烦； 4.0.3 及以后官方推荐构造器注入，理由是构造器注入的依赖是不可变的、完全初始化好的，且可以保证不为 null ； 当然 4.0.3 及以后的官方文档中也说了，如果真的出现构造器参数列表过长的情况，可能是这个 Bean 承担的责任太多，应该考虑组件的责任拆解。 问：组件注入的注解有什么？有什么区别？相信大多数小伙伴都能答出 @Autowired 和 @Resource 吧，如果答出这两个，那证明你应该用过，也会用。但你能回答出 @Inject ，证明你对这些注入的注解确实有了解。作为应聘者，在回答问题时一定是回答的尽可能全面为好，下面对这几种注解作一个对比： 注解 注入方式 是否支持@Primary 来源 Bean不存在时处理 @Autowired 根据类型注入 是 SpringFramework原生注解 可指定 required=false 来避免注入失败 @Resource 根据名称注入 否 JSR250规范 容器中不存在指定Bean会抛出异常 @Inject 根据类型注入 是 JSR330规范 ( 需要导jar包 ) 容器中不存在指定Bean会抛出异常 跟上面差不多，如果问到了这个问题，那就有可能继续被问到下面一个问题： 存在多个相同类型Bean时如何解决注入问题？可能大多数小伙伴都能答出以下几种解决方案： @Resource ：根据名称指定注入的 Bean @Qualifier ：配合 @Autowired 注解使用，如果被标注的成员 / 方法在根据类型注入时发现有多个相同类型的 Bean ，则会根据该注解声明的 name 寻找特定的 bean @Primary ：配合 @Bean 注解使用，如果有多个相同类型的 Bean 同时注册到 IOC 容器中，使用 @Autowired 、@Inject 注解时会注入标注 @Primary 注解的 bean 其实你还可以提另外一种方案：把注入的字段名与 bean 的名称保持一致，这样也可以解决注入时报不唯一 Bean 的问题。 以上几个问题是关于 SpringFramework 与 IOC 部分的一些常见问题，倒是问题都不太陌生，但是小伙伴们想回答的全面、有深度，还是需要下下功夫的。希望小伙伴们能有所收获，在面试中流利回答，斩获 offer ！ 问题整理不易，不点个赞支持一下作者吗？（可怜巴巴）","categories":[{"name":"SpringFramework","slug":"SpringFramework","permalink":"http://yoursite.com/categories/SpringFramework/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"IOC","slug":"IOC","permalink":"http://yoursite.com/tags/IOC/"}]},{"title":"服务发现-EurekaServer的初始化和启动原理","slug":"服务发现-EurekaServer的初始化和启动原理","date":"2020-01-04T11:50:55.000Z","updated":"2020-06-28T07:07:20.742Z","comments":true,"path":"2020/01/04/服务发现-EurekaServer的初始化和启动原理/","link":"","permalink":"http://yoursite.com/2020/01/04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-EurekaServer%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/","excerpt":"","text":"刚学习 SpringCloud 的时候先要学习注册中心，也就是服务发现与治理。SpringCloudNetflix 的方案是使用 Eureka，咱也都很清楚了，下面咱先搭建一个只有 EurekaServer 的工程。 pom依赖只需要两个： 1&lt;dependency&gt;2 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;3 &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;4&lt;/dependency&gt;5&lt;dependency&gt;6 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;7 &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;8&lt;/dependency&gt; 启动类上标注 @EnableEurekaServer： 1@EnableEurekaServer2@SpringBootApplication3public class EurekaServerApplication &#123;4 public static void main(String[] args) &#123;5 SpringApplication.run(EurekaServerApplication.class, args);6 &#125;7&#125; application.yml 中配置一些最基础的信息： 1server:2 port: 900034spring:5 application:6 name: eureka-server78eureka:9 instance:10 hostname: eureka-server11 client:12 register-with-eureka: false13 fetch-registry: false14 service-url:15 defaultZone: http://localhost:9000/eureka/ 之后运行主启动类，EurekaServer 便会运行在9000端口上。 如果不标注 @EnableEurekaServer 注解，即便导入依赖也不会启动 EurekaServer，说明真正打开 EurekaServer 的是 @EnableEurekaServer 注解。 1. @EnableEurekaServer1@Import(EurekaServerMarkerConfiguration.class)2public @interface EnableEurekaServer &#123;3&#125; 它的文档注释非常简单： Annotation to activate Eureka Server related configuration. 用于激活 EurekaServer 相关配置的注解。 它被标注了一个 @Import 注解，导入的是一个 EurekaServerMarkerConfiguration 的配置类。 如果小伙伴对 @Import 注解还不是很了解，可以移步我的 《SpringBoot源码解读与原理分析》小册，先了解 SpringFramework 的基础。 2. EurekaServerMarkerConfiguration1@Configuration2public class EurekaServerMarkerConfiguration &#123;34 @Bean5 public Marker eurekaServerMarkerBean() &#123;6 return new Marker();7 &#125;89 class Marker &#123;1011 &#125;12&#125; 这段源码看上去莫名其妙的，它是一个配置类，然后它定义了一个 Marker 的内部类，又注册了一个Bean，但这光秃秃的，也没点别的逻辑，它到底想干啥？果然还是得靠文档注释： Responsible for adding in a marker bean to activate EurekaServerAutoConfiguration. 负责添加标记Bean来激活 EurekaServerAutoConfiguration 。 好吧，原来它的作用是给IOC容器中添加一个标记，代表要启用 EurekaServerAutoConfiguration 的自动配置类。 那咱就移步 EurekaServerAutoConfiguration 来看它的定义了。 3. EurekaServerAutoConfiguration看到 AutoConfiguration 结尾的类，咱马上要想到：这个类肯定在 spring.factories 文件标注好了，不然没法生效。 果然，在 spring-cloud-netflix-eureka-server 的 jar 包中发现了一个 spring.factories 文件，而文件内部的声明就是如此的简单： 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\2 org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration 没得跑，来看它的定义和声明吧： 1@Configuration2@Import(EurekaServerInitializerConfiguration.class)3@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)4@EnableConfigurationProperties(&#123; EurekaDashboardProperties.class,5 InstanceRegistryProperties.class &#125;)6@PropertySource(\"classpath:/eureka/server.properties\")7public class EurekaServerAutoConfiguration extends WebMvcConfigurerAdapter 注意看 @ConditionalOnBean 的条件：必须IOC容器中有一个 EurekaServerMarkerConfiguration.Marker 类型的 Bean，该配置类才会生效！（原来它是这样做自动配置开关的） 注意到它继承了 WebMvcConfigurerAdapter ，但全篇没有找到跟 WebMvcConfigurer 相关的部分，也没重写对应的方法。那它这是几个意思？这个时候咱要了解一个小背景： 在 SpringFramework5.0+ 后，因为接口可以直接声明 default 方法，所以 WebMvcConfigurerAdapter 被废弃（被标注 @Deprecated），替代方案是直接实现 WebMvcConfigurer 接口。 那既然是这样， 它还继承着这个适配器类，那咱可以大概猜测：它应该是旧版本的遗留。 回到正题，咱看 EurekaServerAutoConfiguration 的类定义声明上还有什么值得注意的。除了上面说的，那就只剩下一个了：它导入了一个 EurekaServerInitializerConfiguration 。 4. EurekaServerInitializerConfiguration1@Configuration2public class EurekaServerInitializerConfiguration implements ServletContextAware, SmartLifecycle, Ordered 注意它实现了 SmartLifecycle 接口，之前咱在《SpringBoot源码解读与原理分析》原理小册中提到过（第16篇 12.2.2章节），如果小伙伴们对这部分不了解，可以移步我的 《SpringBoot源码解读与原理分析》小册，这里咱直接说，它的核心方法是 start ： 1public void start() &#123;2 new Thread(new Runnable() &#123;3 @Override4 public void run() &#123;5 try &#123;6 // TODO: is this class even needed now?7 // 初始化、启动 EurekaServer8 eurekaServerBootstrap.contextInitialized(9 EurekaServerInitializerConfiguration.this.servletContext);10 log.info(\"Started Eureka Server\");1112 // 发布Eureka已注册的事件13 publish(new EurekaRegistryAvailableEvent(getEurekaServerConfig()));14 // 修改 EurekaServer 的运行状态15 EurekaServerInitializerConfiguration.this.running = true;16 // 发布Eureka已启动的事件17 publish(new EurekaServerStartedEvent(getEurekaServerConfig()));18 &#125; // catch ......19 &#125;20 &#125;).start();21&#125; （至此应该进一步意识到为什么上面 EurekaServerAutoConfiguration 继承了一个过时的类，Runnable 都没换成 Lambda 表达式。。。当然也跟 Eureka 1.x 不继续更新有关吧） 这个 start 方法只干了一件事，起一个新的线程来启动 EurekaServer 。这里面核心的 run 方法执行了这么几件事，都已经标注在源码中了。 这里面最重要的步骤就是第一步：初始化、启动 EurekaServer 。 在继续展开这部分源码之前，要带小伙伴了解一点前置知识。 EurekaServer 本身应该是一个完整的 Servlet 应用，在原生的 EurekaServer 中，EurekaServerBootstrap 这个类会实现 ServletContextListener 接口（Servlet3.0规范）来引导启动 EurekaServer 。SpringBoot 应用一般使用嵌入式 Web 容器，没有所谓 Servlet3.0 规范作用的机会了，所以需要另外的启动方式，于是 SpringCloud 在整合这部分时，借助了IOC容器中支持的 LifeCycle 机制，来以此触发 EurekaServer 的启动。 4.0 eurekaServerBootstrap.contextInitialized：初始化、启动EurekaServer1public void contextInitialized(ServletContext context) &#123;2 try &#123;3 initEurekaEnvironment();4 initEurekaServerContext();5 context.setAttribute(EurekaServerContext.class.getName(), this.serverContext);6 &#125; // catch......7&#125; 这里面又分为两个部分，依此来看： 4.1 initEurekaEnvironment：初始化Eureka的运行环境1private static final String TEST = \"test\";2private static final String DEFAULT = \"default\";34protected void initEurekaEnvironment() throws Exception &#123;5 log.info(\"Setting the eureka configuration..\");67 // Eureka的数据中心8 String dataCenter = ConfigurationManager.getConfigInstance()9 .getString(EUREKA_DATACENTER);10 if (dataCenter == null) &#123;11 log.info(12 \"Eureka data center value eureka.datacenter is not set, defaulting to default\");13 ConfigurationManager.getConfigInstance()14 .setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);15 &#125;16 else &#123;17 ConfigurationManager.getConfigInstance()18 .setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);19 &#125;20 // Eureka运行环境21 String environment = ConfigurationManager.getConfigInstance()22 .getString(EUREKA_ENVIRONMENT);23 if (environment == null) &#123;24 ConfigurationManager.getConfigInstance()25 .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);26 log.info(27 \"Eureka environment value eureka.environment is not set, defaulting to test\");28 &#125;29 else &#123;30 ConfigurationManager.getConfigInstance()31 .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, environment);32 &#125;33&#125; 这里面的逻辑咱乍一看，貌似都长得差不多啊，都是 获取 → 判断 → 设置 ，而且它们都有对应的默认值（源码中已标注）。至于这部分是干嘛的呢，咱不得不关注一下 setProperty 方法中的两个常量： 1private static final String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = \"archaius.deployment.environment\";2private static final String ARCHAIUS_DEPLOYMENT_DATACENTER = \"archaius.deployment.datacenter\"; 配置项的前缀是 archaius ，它是 Netflix 旗下的一个配置管理组件（提到这里，是不是产生了一种感觉：它会不会跟 SpringCloudConfig 有关系？然而并不是，当引入 SpringCloudConfig 时，archaius 并不会带进来），这个组件可以实现更强大的动态配置，它的基底是 Apache 的 commons-configuration ： ![](服务发现-EurekaServer的初始化和启动原理/3. archaius的底层依赖是commons-configuration.png) 对于这个组件，小册不展开研究了，小伙伴们只需要知道有这么回事就可以了，下面的才是重点。 4.2 initEurekaServerContext：初始化EurekaServer的运行上下文1protected void initEurekaServerContext() throws Exception &#123;2 // For backward compatibility 兼容低版本Eureka3 JsonXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(),4 XStream.PRIORITY_VERY_HIGH);5 XmlXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(),6 XStream.PRIORITY_VERY_HIGH);78 if (isAws(this.applicationInfoManager.getInfo())) &#123;9 this.awsBinder = new AwsBinderDelegate(this.eurekaServerConfig,10 this.eurekaClientConfig, this.registry, this.applicationInfoManager);11 this.awsBinder.start();12 &#125;1314 // 注册EurekaServerContextHolder，通过它可以很方便的获取EurekaServerContext15 EurekaServerContextHolder.initialize(this.serverContext);1617 log.info(\"Initialized server context\");1819 // Copy registry from neighboring eureka node20 // Eureka复制集群节点注册表21 int registryCount = this.registry.syncUp();22 this.registry.openForTraffic(this.applicationInfoManager, registryCount);2324 // Register all monitoring statistics.25 EurekaMonitors.registerAllStats();26&#125; 前面的一大段都是为了低版本兼容而做的一些额外工作，咱不关心这些。中间又是注册了一个 注册EurekaServerContextHolder 的组件，通过它可以直接获取 EurekaServerContext （它的内部使用简单的单例实现，实现非常简单，小伙伴可自行查看）。 注意最后几行，倒数第二个单行注释的内容： Copy registry from neighboring eureka node。 从相邻的eureka节点复制注册表。 节点复制注册表？这很明显是为了 Eureka 集群而设计的！由此可知 Eureka 集群能保证后起来的节点也不会出问题，是这里同步了注册表啊！这一步的操作非常复杂，咱后续另开一篇解释。 除了这部分之外，EurekaServerInitializerConfiguration 已经没有要配置的组件，回到 EurekaServerAutoConfiguration 中。 5. EurekaServerAutoConfiguration中配置的核心组件5.1 EurekaController1@Bean2@ConditionalOnProperty(prefix = \"eureka.dashboard\", name = \"enabled\", matchIfMissing = true)3public EurekaController eurekaController() &#123;4 return new EurekaController(this.applicationInfoManager);5&#125; 呦，一看这是个 Controller ，有木有立马想到自己写的那些 Controller ？赶紧点进去瞅一眼： 1@Controller2@RequestMapping(\"$&#123;eureka.dashboard.path:/&#125;\")3public class EurekaController 哇塞果然是我们熟悉的 SpringWebMvc 的内容！既然是一个 Controller ，那它肯定能给咱定义了一些处理方法，不然咱咋看到的 Eureka 控制台呢？翻看源码，它这里面定义了两个处理方法，分别是： status - 获取当前 EurekaServer 的状态（即控制台）、lastn - 获取当前 EurekaServer 上服务注册动态历史记录。这部分咱不展开描述了，有兴趣的小伙伴们可以深入这个类来研究。 5.2 PeerAwareInstanceRegistry1@Bean2public PeerAwareInstanceRegistry peerAwareInstanceRegistry(ServerCodecs serverCodecs) &#123;3 this.eurekaClient.getApplications(); // force initialization4 return new InstanceRegistry(this.eurekaServerConfig, this.eurekaClientConfig,5 serverCodecs, this.eurekaClient,6 this.instanceRegistryProperties.getExpectedNumberOfClientsSendingRenews(),7 this.instanceRegistryProperties.getDefaultOpenForTrafficCount());8&#125; 这个 PeerAwareInstanceRegistry 很重要，它是 EurekaServer 集群中节点之间同步微服务实例注册表的核心组件（这里默认小伙伴已经对 EurekaServer 的集群配置及相关基础都了解了）。集群节点同步注册表的内容咱会另起一篇研究，这里咱只是看一下这个类的继承结构，方面后续看到时不至于不认识： 1public class InstanceRegistry extends PeerAwareInstanceRegistryImpl implements ApplicationContextAware2public class PeerAwareInstanceRegistryImpl extends AbstractInstanceRegistry implements PeerAwareInstanceRegistry3public abstract class AbstractInstanceRegistry implements InstanceRegistry 这里面继承的两个类 PeerAwareInstanceRegistryImpl 、AbstractInstanceRegistry ，它们将会在后续研究节点同步时有重要作用，包括里面涉及的功能会在后面的组件（EurekaServerContext 等）发挥功能时带着一起解释。 5.3 PeerEurekaNodes1@Bean2@ConditionalOnMissingBean3public PeerEurekaNodes peerEurekaNodes(PeerAwareInstanceRegistry registry, ServerCodecs serverCodecs,4 ReplicationClientAdditionalFilters replicationClientAdditionalFilters) &#123;5 return new RefreshablePeerEurekaNodes(registry, this.eurekaServerConfig,6 this.eurekaClientConfig, serverCodecs, this.applicationInfoManager,7 replicationClientAdditionalFilters);8&#125; 这个 PeerEurekaNodes 可以理解成微服务实例的节点集合。换言之，一个 PeerEurekaNode 就是一个微服务节点实例的包装，PeerEurekaNodes 就是这组 PeerEurekaNode 的集合，这种节点是可以被 EurekaServer 集群中的各个注册中心节点共享的（PeerAwareInstanceRegistry）。翻开 PeerEurekaNodes 的结构，可以发现它的结构中有这么几样东西： 1public class PeerEurekaNodes &#123;23 protected final PeerAwareInstanceRegistry registry;4 // ......56 private volatile List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();7 private volatile Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();89 private ScheduledExecutorService taskExecutor; PeerAwareInstanceRegistry ：集群间节点同步的核心组件 List&lt;PeerEurekaNode&gt; ：节点集合 peerEurekaNodeUrls ：所有节点所在url ScheduledExecutorService ：执行定时任务的线程池 另外 PeerEurekaNodes 还提供了一个 start 和 shutdown 方法： 5.3.1 start1public void start() &#123;2 taskExecutor = Executors.newSingleThreadScheduledExecutor(3 new ThreadFactory() &#123;4 @Override5 public Thread newThread(Runnable r) &#123;6 Thread thread = new Thread(r, \"Eureka-PeerNodesUpdater\");7 thread.setDaemon(true);8 return thread;9 &#125;10 &#125;11 );12 try &#123;13 updatePeerEurekaNodes(resolvePeerUrls());14 Runnable peersUpdateTask = new Runnable() &#123;15 @Override16 public void run() &#123;17 try &#123;18 updatePeerEurekaNodes(resolvePeerUrls());19 &#125; // catch ......20 &#125;21 &#125;;22 taskExecutor.scheduleWithFixedDelay(23 peersUpdateTask,24 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),25 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),26 TimeUnit.MILLISECONDS27 );28 &#125; // catch ...... log ......29&#125; 可以发现 start 方法的核心是借助线程池完成定时任务。定时任务的内容是中间那一段实现了 Runnable 接口的匿名内部类，它会执行一个 updatePeerEurekaNodes 方法来更新集群节点。下面定时任务的执行时间，借助IDEA跳转到 EurekaServerConfigBean 中发现默认的配置是 10 分钟，即每隔10分钟会同步一次集群节点。至于 updatePeerEurekaNodes 的具体实现，咱同样放到后面跟节点同步放在一起来解析。 5.3.2 shutdown1public void shutdown() &#123;2 taskExecutor.shutdown();3 List&lt;PeerEurekaNode&gt; toRemove = this.peerEurekaNodes;45 this.peerEurekaNodes = Collections.emptyList();6 this.peerEurekaNodeUrls = Collections.emptySet();78 for (PeerEurekaNode node : toRemove) &#123;9 node.shutDown();10 &#125;11&#125; 这个方法的内容比较简单，它会把线程池的定时任务停掉，并移除掉当前所有的服务节点信息。它被调用的时机是下面要解析的 EurekaServerContext 。 5.4 EurekaServerContext1@Bean2public EurekaServerContext eurekaServerContext(ServerCodecs serverCodecs,3 PeerAwareInstanceRegistry registry, PeerEurekaNodes peerEurekaNodes) &#123;4 return new DefaultEurekaServerContext(this.eurekaServerConfig, serverCodecs,5 registry, peerEurekaNodes, this.applicationInfoManager);6&#125; 它创建了一个 DefaultEurekaServerContext ，文档注释原文翻译： Represent the local server context and exposes getters to components of the local server such as the registry. 表示本地服务器上下文，并将 getter 方法暴露给本地服务器的组件（例如注册表）。 可以大概的意识到，它确实跟 SpringFramework 的 ApplicationContext 差不太多哈，可以这么简单地理解吧，咱还是看看里面比较特殊的内容。 进入到 DefaultEurekaServerContext 中，果然发现了两个特殊的方法： 1@PostConstruct2public void initialize() &#123;3 logger.info(\"Initializing ...\");4 peerEurekaNodes.start();5 try &#123;6 registry.init(peerEurekaNodes);7 &#125; catch (Exception e) &#123;8 throw new RuntimeException(e);9 &#125;10 logger.info(\"Initialized\");11&#125;1213@PreDestroy14public void shutdown() &#123;15 logger.info(\"Shutting down ...\");16 registry.shutdown();17 peerEurekaNodes.shutdown();18 logger.info(\"Shut down\");19&#125; 果然，是 EurekaServerContext 的初始化，带动 PeerEurekaNodes 的初始化，EurekaServerContext 的销毁带动 PeerEurekaNodes 的销毁。除了带动 PeerEurekaNodes 之前，还有一个 PeerAwareInstanceRegistry 也带动初始化了，看一眼它的 init 方法吧： 5.4.1 PeerAwareInstanceRegistry#init关键部分注释已标注在源码： 1public void init(PeerEurekaNodes peerEurekaNodes) throws Exception &#123;2 // 5.4.1.1 启动续订租约的频率统计器3 this.numberOfReplicationsLastMin.start();4 this.peerEurekaNodes = peerEurekaNodes;5 initializedResponseCache();6 // 5.4.1.2 开启续订租约最低阈值检查的定时任务7 scheduleRenewalThresholdUpdateTask();8 // 5.4.1.3 初始化远程分区注册中心9 initRemoteRegionRegistry();1011 try &#123;12 Monitors.registerObject(this);13 &#125; catch (Throwable e) &#123;14 logger.warn(\"Cannot register the JMX monitor for the InstanceRegistry :\", e);15 &#125;16&#125; 源码标注了三个关键的环节，一一来看： 5.4.1.1 numberOfReplicationsLastMin.start()：启动续订租约的频率统计器1private final AtomicLong lastBucket = new AtomicLong(0);2private final AtomicLong currentBucket = new AtomicLong(0);34private final long sampleInterval;56public synchronized void start() &#123;7 if (!isActive) &#123;8 timer.schedule(new TimerTask() &#123;9 @Override10 public void run() &#123;11 try &#123;12 // Zero out the current bucket.13 lastBucket.set(currentBucket.getAndSet(0));14 &#125; catch (Throwable e) &#123;15 logger.error(\"Cannot reset the Measured Rate\", e);16 &#125;17 &#125;18 &#125;, sampleInterval, sampleInterval);19 isActive = true;20 &#125;21&#125; 这个方法实现不难理解，它会隔一段时间重置 lastBucket 和 currentBucket 的值为0，那时间间隔是多少呢？翻看整个类，发现只有构造方法可以设置时间间隔： 1public MeasuredRate(long sampleInterval) &#123;2 this.sampleInterval = sampleInterval;3 this.timer = new Timer(\"Eureka-MeasureRateTimer\", true);4 this.isActive = false;5&#125; 借助IDEA，发现设置 sampleInterval 的值有两处，但值都是一样的：new MeasuredRate(1000 * 60 * 1); ，也就是1分钟重置一次。可关键的问题是，它这个操作是干嘛呢？为啥非得一分钟统计一次续约次数呢？实际上，这个计算次数会体现在 Eureka 的控制台，以及配合 Servo 完成续约次数监控（说白了，咱这看着没啥用，微服务监控和治理还是管用的，不然为什么 Eureka 被称为服务发现与治理的框架呢）。 5.4.1.2 scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务1private int renewalThresholdUpdateIntervalMs = 15 * MINUTES;23private void scheduleRenewalThresholdUpdateTask() &#123;4 timer.schedule(new TimerTask() &#123;5 @Override6 public void run() &#123;7 updateRenewalThreshold();8 &#125;9 &#125;, serverConfig.getRenewalThresholdUpdateIntervalMs(),10 serverConfig.getRenewalThresholdUpdateIntervalMs());11&#125; 又是一个定时任务，配置项中的默认时间间隔可以发现是15分钟。那定时任务中执行的核心方法是 updateRenewalThreshold 方法，跳转过去： 1private void updateRenewalThreshold() &#123;2 try &#123;3 Applications apps = eurekaClient.getApplications();4 int count = 0;5 for (Application app : apps.getRegisteredApplications()) &#123;6 for (InstanceInfo instance : app.getInstances()) &#123;7 if (this.isRegisterable(instance)) &#123;8 ++count;9 &#125;10 &#125;11 &#125;12 synchronized (lock) &#123;13 // Update threshold only if the threshold is greater than the14 // current expected threshold or if self preservation is disabled.15 if ((count) &gt; (serverConfig.getRenewalPercentThreshold() * expectedNumberOfClientsSendingRenews)16 || (!this.isSelfPreservationModeEnabled())) &#123;17 this.expectedNumberOfClientsSendingRenews = count;18 updateRenewsPerMinThreshold();19 &#125;20 &#125;21 logger.info(\"Current renewal threshold is : &#123;&#125;\", numberOfRenewsPerMinThreshold);22 &#125; // catch ......23&#125; 上面的 for 循环很明显是检查当前已经注册到本地的服务实例是否还保持连接，由于该方法一定会返回 true （可翻看该部分实现，全部都是 return true），故上面统计的 count 就是所有的微服务实例数量。 下面的同步代码块中，它会检查统计好的数量是否比预期的多，如果统计好的服务实例数比预期的数量多，证明出现了新的服务注册，要替换下一次统计的期望数量值，以及重新计算接下来心跳的数量统计。心跳的数量统计方法 updateRenewsPerMinThreshold() ： 1private int expectedClientRenewalIntervalSeconds = 30;2private double renewalPercentThreshold = 0.85;34protected void updateRenewsPerMinThreshold() &#123;5 this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfClientsSendingRenews6 * (60.0 / serverConfig.getExpectedClientRenewalIntervalSeconds())7 * serverConfig.getRenewalPercentThreshold());8&#125; 可以看出来它的计算数是：每隔30秒发一次心跳（一分钟心跳两次），而且必须所有的服务实例的心跳总数要达到前面计算数量的85%才算整体微服务正常，其实这也就是 EurekaServer 的自我保护机制。 5.4.1.3 initRemoteRegionRegistry：初始化远程分区注册中心1protected void initRemoteRegionRegistry() throws MalformedURLException &#123;2 Map&lt;String, String&gt; remoteRegionUrlsWithName = serverConfig.getRemoteRegionUrlsWithName();3 if (!remoteRegionUrlsWithName.isEmpty()) &#123;4 allKnownRemoteRegions = new String[remoteRegionUrlsWithName.size()];5 int remoteRegionArrayIndex = 0;6 for (Map.Entry&lt;String, String&gt; remoteRegionUrlWithName : remoteRegionUrlsWithName.entrySet()) &#123;7 RemoteRegionRegistry remoteRegionRegistry = new RemoteRegionRegistry(8 serverConfig,9 clientConfig,10 serverCodecs,11 remoteRegionUrlWithName.getKey(),12 new URL(remoteRegionUrlWithName.getValue()));13 regionNameVSRemoteRegistry.put(remoteRegionUrlWithName.getKey(), remoteRegionRegistry);14 allKnownRemoteRegions[remoteRegionArrayIndex++] = remoteRegionUrlWithName.getKey();15 &#125;16 &#125;17 logger.info(\"Finished initializing remote region registries. All known remote regions: &#123;&#125;\",18 (Object) allKnownRemoteRegions);19&#125; 这里面提到了一个概念：RemoteRegionRegistry ，它的文档注释原文翻译： Handles all registry operations that needs to be done on a eureka service running in an other region. The primary operations include fetching registry information from remote region and fetching delta information on a periodic basis. 处理在其他区域中运行的eureka服务上需要完成的所有注册表操作。主要操作包括从远程区域中获取注册表信息以及定期获取增量信息。 文档注释的解释看着似懂非懂，它没有把这个类的作用完全解释清楚。实际上这里涉及到 Eureka 的服务分区，这个咱留到后面解释 Eureka 的高级特性时再聊。 5.4.2 PeerAwareInstanceRegistry#shutdown当 EurekaServerContext 被销毁时，会回调 @PreDestory 标注的 shutdown 方法，而这个方法又调到 PeerAwareInstanceRegistry 的 shutdown 方法。 1public void shutdown() &#123;2 try &#123;3 DefaultMonitorRegistry.getInstance().unregister(Monitors.newObjectMonitor(this));4 &#125; // catch .......5 try &#123;6 peerEurekaNodes.shutdown();7 &#125; // catch .......8 numberOfReplicationsLastMin.stop();9 super.shutdown();10&#125; 这里它干的事情不算麻烦，它首先利用 DefaultMonitorRegistry 做了一个注销操作，DefaultMonitorRegistry 这个组件本身来源于 servo 包，它是做监控使用，那自然能猜出来这部分是关闭监控。接下来它会把那些微服务节点实例全部注销，停止计数器监控，最后回调父类的 shutdown 方法： 1public void shutdown() &#123;2 deltaRetentionTimer.cancel();3 evictionTimer.cancel();4 renewsLastMin.stop();5&#125; 可以发现也是跟监控相关的组件停止，不再赘述。 5.5 EurekaServerBootstrap1@Bean2public EurekaServerBootstrap eurekaServerBootstrap(PeerAwareInstanceRegistry registry,3 EurekaServerContext serverContext) &#123;4 return new EurekaServerBootstrap(this.applicationInfoManager,5 this.eurekaClientConfig, this.eurekaServerConfig, registry,6 serverContext);7&#125; 这个咱上面已经提过了，有了 EurekaServerBootstrap 才能引导启动 EurekaServer 。 5.6 ServletContainer1@Bean2public FilterRegistrationBean jerseyFilterRegistration(javax.ws.rs.core.Application eurekaJerseyApp) &#123;3 FilterRegistrationBean bean = new FilterRegistrationBean();4 bean.setFilter(new ServletContainer(eurekaJerseyApp));5 bean.setOrder(Ordered.LOWEST_PRECEDENCE);6 bean.setUrlPatterns(Collections.singletonList(EurekaConstants.DEFAULT_PREFIX + \"/*\"));7 return bean;8&#125; 它注册的 FilterRegistrationBean 我在之前的《SpringBoot源码解读与原理分析》中有提过（第6章4.1.2节），这里咱直接说核心的 Filter 是 ServletContainer ： 1package com.sun.jersey.spi.container.servlet;23public class ServletContainer extends HttpServlet implements Filter 注意它所在的包，里面有一个很关键的词：jersey ，它是一个类似于 SpringWebMvc 的框架，由于 Eureka 本身也是一个 Servlet 应用，只是它使用的 Web 层框架不是 SpringWebMvc 而是 Jersey 而已，Jersey 在 Eureka 的远程请求、心跳包发送等环节起到至关重要的作用，后续咱会详细解释。 5.7 Application1@Bean2public javax.ws.rs.core.Application jerseyApplication(Environment environment,3 ResourceLoader resourceLoader) &#123;4 // ......5&#125; 这个类的创建咱不是很关心，瞅一眼这个类的子类，发现全部都是来自 Jersey 的： ![](服务发现-EurekaServer的初始化和启动原理/3. Application下面的子类全部都是jersey的.png) 而且上面的 ServletContainer 中正好也用到了这个 Application ，那大概也明白它是配合上面的过滤器使用，后续咱会跟上面的 Jersey 一起解释。 5.8 HttpTraceFilter1@Bean2public FilterRegistrationBean traceFilterRegistration(@Qualifier(\"httpTraceFilter\") Filter filter) &#123;3 FilterRegistrationBean bean = new FilterRegistrationBean();4 bean.setFilter(filter);5 bean.setOrder(Ordered.LOWEST_PRECEDENCE - 10);6 return bean;7&#125; 它注册了一个名为 httpTraceFilter 的过滤器，借助IDEA发现这个过滤器来自 HttpTraceAutoConfiguration 的内部类 ServletTraceFilterConfiguration ： 1@Configuration2@ConditionalOnWebApplication(type = Type.SERVLET)3static class ServletTraceFilterConfiguration &#123;4 @Bean5 @ConditionalOnMissingBean6 public HttpTraceFilter httpTraceFilter(HttpTraceRepository repository, HttpExchangeTracer tracer) &#123;7 return new HttpTraceFilter(repository, tracer);8 &#125;9&#125; 这个过滤器的作用也很容易猜想，trace 的概念咱从日志系统里也接触过，它打印的内容非常非常多，且涵盖了上面的几乎所有级别。这个类的文档注释也恰好印证了我们的猜想： Servlet Filter that logs all requests to an HttpTraceRepository. 记录所有请求日志的Servlet过滤器。 6. EurekaServerConfigBeanConfigurationEurekaServerAutoConfiguration 还有一个内部的配置类：EurekaServerConfigBeanConfiguration 1@Configuration2protected static class EurekaServerConfigBeanConfiguration &#123;3 @Bean4 @ConditionalOnMissingBean5 public EurekaServerConfig eurekaServerConfig(EurekaClientConfig clientConfig) &#123;6 EurekaServerConfigBean server = new EurekaServerConfigBean();7 if (clientConfig.shouldRegisterWithEureka()) &#123;8 // Set a sensible default if we are supposed to replicate9 server.setRegistrySyncRetries(5);10 &#125;11 return server;12 &#125;13&#125; 它就是注册了默认的 EurekaServer 的配置模型，这个模型类里的配置咱上面也看到一些了，后面的部分咱还会接触它，先有一个印象即可。 小结 @EnableEurekaServer 注解会激活 EurekaServer 的自动配置，核心是向IOC容器注册一个 Marker 的内部类。 EurekaServerInitializerConfiguration 负责 EurekaServer 的初始化，初始化的过程包括本身初始化、运行环境初始化、运行上下文的初始化。 EurekaServerAutoConfiguration 注册的核心组件包括展示控制台的 Controller 、微服务节点实例的模型和管理组件、EurekaServerContext、EurekaServerBootstrap（启动引导类）、两个过滤器。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloudNetflix","slug":"SpringCloudNetflix","permalink":"http://yoursite.com/tags/SpringCloudNetflix/"},{"name":"EurekaServer","slug":"EurekaServer","permalink":"http://yoursite.com/tags/EurekaServer/"},{"name":"服务发现","slug":"服务发现","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"}]},{"title":"嵌入式容器：嵌入式Tomcat的优化和配置","slug":"嵌入式容器：嵌入式Tomcat的优化和配置","date":"2019-12-02T12:17:59.000Z","updated":"2020-06-28T07:07:39.607Z","comments":true,"path":"2019/12/02/嵌入式容器：嵌入式Tomcat的优化和配置/","link":"","permalink":"http://yoursite.com/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"在以往的开发中我们可能会根据项目本身对 Tomcat 进行一些调整，以达到最大化利用 Tomcat 的目的。SpringBoot 使用嵌入式 Tomcat，再像之前那样做 Tomcat 性能调优就显得不那么现实了，为此我们需要了解如何在 SpringBoot 内部给嵌入式 Tomcat 做性能调优。本篇文章只做定性的解析，深入到量的控制本文不作详细探讨。 0. 调优前的准备为测试当前 SpringBoot 中嵌入式 Tomcat 的最大性能，需要一个压力测试工具来辅助我们测试性能，目前应用比较多的压测工具有 Bench 和 JMeter ，本文中使用 Bench 作为压测工具。 测试之前，咱先把工具准备好： Bench：https://www.apachelounge.com/download/ JMeter：http://jmeter.apache.org/download_jmeter.cgi 下载好之后，把这两个工具的环境变量都配置好，方便直接从控制台执行。 除此之外，把一开始的测试工程中加入一个测试的 DemoController ，用于接收请求压测（为模拟真实业务场景，会在 DemoController 中让线程随机阻塞 100 - 500ms ，以代替数据库连接和业务查询）。最后，把工程打成可执行jar包并启动，等待测试。 jar包启动的方式非常简单：java -jar demo-0.0.1-SNAPSHOT.jar （本文在进行压测时的物理环境：Windows10 + Intel Core i7-8750H） 1. 使用Bench进行压测在cmd中执行如下命令： ab -n 10000 -c 500 http://localhost:8080/test 执行完成后会在控制台打印测试报告：（报告中的指标解释已标注在行尾） 1This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;2Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/3Licensed to The Apache Software Foundation, http://www.apache.org/45Benchmarking localhost (be patient)6Completed 1000 requests7Completed 2000 requests8Completed 3000 requests9Completed 4000 requests10Completed 5000 requests11Completed 6000 requests12Completed 7000 requests13Completed 8000 requests14Completed 9000 requests15Completed 10000 requests16Finished 10000 requests171819Server Software:20Server Hostname: localhost // 主机名21Server Port: 8080 // 端口号2223Document Path: /test24Document Length: 4 bytes2526Concurrency Level: 500 // 并发量27Time taken for tests: 15.670 seconds // 所有请求的总耗时28Complete requests: 10000 // 成功的请求数29Failed requests: 030Total transferred: 1360000 bytes // 总传输数据量31HTML transferred: 40000 bytes // 总响应数据量32Requests per second: 638.17 [#/sec] (mean) // 【重要】每秒执行的请求数量（吞吐量）33Time per request: 783.493 [ms] (mean) // 【重要】客户端平均响应时间34Time per request: 1.567 [ms] (mean, across all concurrent requests) // 服务器平均请求等待时间35Transfer rate: 84.76 [Kbytes/sec] received // 每秒传输的数据量3637Connection Times (ms)38 min mean[+/-sd] median max39Connect: 0 0 0.2 0 140Processing: 105 738 135.1 742 99341Waiting: 105 738 135.2 742 99342Total: 105 738 135.1 742 9934344Percentage of the requests served within a certain time (ms)45 50% 74246 66% 81047 75% 84748 80% 86849 90% 90950 95% 93151 98% 94552 99% 95253 100% 993 (longest request) 在测试报告中有两个重要的指标需要咱来关注： Requests per second：每秒执行的请求数量（吞吐量） 吞吐量越高，代表性能越好 Time per request：客户端平均响应时间 响应时间越短，代表性能越好 在这里面测得的结果是 638.17 的吞吐量，783.493ms 的平均响应时间，这个响应时间比代码中控制的阻塞时间更长，说明 Tomcat 对500的并发已经有一些吃力了。 下面咱再用更大的并发量来测试效果： ab -n 50000 -c 2000 http://localhost:8080/test 测得的结果（截取主要部分）： 1Concurrency Level: 20002Time taken for tests: 75.689 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 660.60 [#/sec] (mean)8Time per request: 3027.564 [ms] (mean)9Time per request: 1.514 [ms] (mean, across all concurrent requests)10Transfer rate: 87.74 [Kbytes/sec] received 发现吞吐量没有什么太大的变化，但平均响应时间大幅提升，且大概为上面的4倍。可以看得出来，Tomcat 的处理速度已经远远跟不上请求到来的速度，需要进行性能调优。 2. 嵌入式Tomcat调优依据调优一定要有依据，咱根据现状和之前对 SpringBoot 的学习和原理剖析，应该知道配置大多都是两种形式： 声明式配置：application.properties 或 application.yml 编程式配置：XXXConfigurer 或 XXXCustomizer 其中，利用配置文件进行配置，最终会映射到 SpringBoot 中的一些 Properties 类中，例如 server.port 配置会映射到 ServerProperties 类中： 1@ConfigurationProperties(prefix = \"server\", ignoreUnknownFields = true)2public class ServerProperties &#123;3 private Integer port; 那我们来大体分析一下对于 Tomcat 的声明式配置，都有哪些可以控制的部分： 2.1 Tomcat的声明式配置在 ServerProperties 类中，有一个 Tomcat 的静态内部类： 1/**2 * Tomcat properties.3 */4public static class Tomcat &#123;5 // ...... 这里面就是配置嵌入式 Tomcat 的可以供我们配置的映射配置类。咱来看里面的核心属性： 1/**2 * Maximum amount of worker threads.3 * 最大工作线程数4 */5private int maxThreads = 200;67/**8 * Minimum amount of worker threads.9 * 最小工作线程数10 */11private int minSpareThreads = 10;1213/**14 * Maximum number of connections that the server accepts and processes at any15 * given time. Once the limit has been reached, the operating system may still16 * accept connections based on the \"acceptCount\" property.17 * 服务器最大连接数18 */19private int maxConnections = 10000;2021/**22 * Maximum queue length for incoming connection requests when all possible request23 * processing threads are in use.24 * 最大请求队列等待长度25 */26private int acceptCount = 100; 可以发现这里面的几个指标，分别控制连接数、线程数、等待数。 咱来分析为什么上面的吞吐量不够大：请求中的关键耗时动作是 Thread.sheep 卡线程，导致吞吐量变大。Thread.sleep 模拟了IO操作、数据库交互等非CPU高速计算的行为，在数据库交互时，CPU资源被浪费，导致无法处理后来的请求，出现资源利用率低的现象。为此，我们需要提高请求并发数，以此来提高CPU利用率。提高请求并发的方法在上面的几个参数中很明显是 maxThreads 。 3. 调整maxThreads从源码中很明显看到默认的最大线程数是200，我们在 application.properties 中修改值为 500： server.tomcat.max-threads=500 修改之后的测试： 1Concurrency Level: 20002Time taken for tests: 30.910 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 1617.61 [#/sec] (mean)8Time per request: 1236.391 [ms] (mean)9Time per request: 0.618 [ms] (mean, across all concurrent requests)10Transfer rate: 214.84 [Kbytes/sec] received 发现吞吐量有明显的提升，且吞吐量的放大倍数大概是前面线程数为 200 时的2.5倍。继续放大该值为 2000： server.tomcat.max-threads=2000 重新测试效果： 1Concurrency Level: 20002Time taken for tests: 12.050 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 4149.38 [#/sec] (mean)8Time per request: 482.000 [ms] (mean)9Time per request: 0.241 [ms] (mean, across all concurrent requests)10Transfer rate: 551.09 [Kbytes/sec] received 吞吐量又一次明显上升，但注意此时的吞吐量并没有扩大到上一次的 4 倍。继续放大该值为 10000： server.tomcat.max-threads=10000 重新测试效果： 1Concurrency Level: 20002Time taken for tests: 13.808 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 3621.22 [#/sec] (mean)8Time per request: 552.300 [ms] (mean)9Time per request: 0.276 [ms] (mean, across all concurrent requests)10Transfer rate: 480.94 [Kbytes/sec] received 发现吞吐量竟然下降了！为什么会出现这种现象呢？ 4. 现象解释要解释这个原因，就不得不提到 CPU 的工作原理了。当CPU的核心线程数小于当前应用线程时，CPU为了保证所有应用线程都正常执行，它会在多个线程中来回切换，以保证每个线程都能获得CPU时间。在一个确定的时间点中，一个CPU只能处理一个线程。 所以这个现象就可以这样解释：当开启的 Tomcat 线程过多时，CPU会消耗大量时间在这些 Tomcat 线程中来回切换，导致真正处理业务请求的时间变少，最终导致整体应用处理速度变慢。 由此也可以推出另一种可能：如果业务逻辑中有大量CPU处理工作（如运算、处理数据等），则CPU需要更多的时间用于计算，此时若 Tomcat 线程过多，则处理速度会更慢。 5. 总结由上面的情况可以总结出以下结论： 应用中大部分业务逻辑都是阻塞型处理（IO、数据库操作等），这种情况下CPU的压力较低，可以适当调大 maxThreads 的值大小。 应用中大部分业务逻辑都是数据处理和计算，这种情况下CPU的压力较大，应适当调小 maxThreads 的值大小。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"},{"name":"嵌入式容器","slug":"嵌入式容器","permalink":"http://yoursite.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8/"}]}]}