{"meta":{"title":"LinkedBear的GitHub","subtitle":"","description":"LinkedBear的GitHub博客","author":"LinkedBear","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-12-02T11:52:50.000Z","updated":"2019-12-02T12:03:20.257Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一个平凡的码畜我不是什么有身份的人，在圈子里也没什么动静。我只是一个默默研究框架源码以及其中内部原理的草根研究者，闷头翻源码是我喜欢的事情，同样也是我的乐趣。平常工作中，我通常扮演偏架构和偏基础的组件研发，也不是什么很牛的组件贡献者。 机缘巧合的小册我有一个关系很好的小圈子，那些伙计鼓励我写一本 SpringBoot 的小册（毕竟那是我研究最多的框架，没有之一），机缘巧合之下，我联系到了掘金平台，从此开始了我的创作路。小册发布后评价都还不错，感谢小伙伴们的认可和对我的支持，我也会在后续有更多的产出。 寻找我的方式讲真，我也没什么名气，也没有太多的精力去运营公众号等自媒体，所以目前来讲能找到我的办法，可能只有借助掘金小册了。。。后续如果真的我慢慢做大了，那寻找我也会变得容易的多。"},{"title":"juejin","date":"2019-12-02T12:49:54.000Z","updated":"2020-05-23T05:58:43.054Z","comments":true,"path":"juejin/index.html","permalink":"http://yoursite.com/juejin/index.html","excerpt":"","text":"掘金小册的创作由来我有一个关系很好的小圈子，那些伙计鼓励我写一本 SpringBoot 的小册（毕竟那是我研究最多的框架，没有之一），机缘巧合之下，我联系到了掘金平台，从此开始了我的创作路。小册发布后评价都还不错，感谢小伙伴们的认可和对我的支持，我也会在后续有更多的产出。 SpringBoot 小册SpringBoot 的小册虽说是第一本小册，里面的内容还是很多的，对 SpringFramework 和 SpringBoot 有深入理解的想法的小伙伴，你可以去读几篇体会一下，如果感觉你喜欢或者你需要的话，不妨买来看看(滑稽)，虽说不贵，但内容绝对超值（已得到多名小伙伴的反馈）。 跳转戳 → https://juejin.im/book/5da3bc3d6fb9a04e35597a76 SpringCloudNetflix小册时隔半年，SpringCloud 的小册也终于发行了，上篇讲的都是 SpringCloudNetflix 下的解决方案集，小册延续 SpringBoot 的风格，详细解析源码和内部的设计实现原理，相信对于想系统了解 SpringCloud 原理的小伙伴来讲，这是一个不错的帮助。 跳转戳 → https://juejin.im/book/5e905b75f265da47dd398c48 后续计划好多小伙伴跟我反馈说看了 Boot 和 Cloud 的小册，感觉就像没学过一样，也或者不知道的太多了，所以接下来的小册会回归基础，出一版 SpringFramework 的基础小册，我会尽可能从最最基础开始，一点一点领你重新学一遍 SpringFramework 中的重难点，达到让小伙伴真正对 SpringFramework 有一个系统的掌握。"}],"posts":[{"title":"Spring的IOC，你真的能解释清楚吗？","slug":"Spring的IOC，你真的能解释清楚吗？","date":"2020-05-18T04:50:55.000Z","updated":"2020-05-23T06:01:04.730Z","comments":true,"path":"2020/05/18/Spring的IOC，你真的能解释清楚吗？/","link":"","permalink":"http://yoursite.com/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/","excerpt":"","text":"一直以来，SpringFramework 作为 Java 企业级开发的老大哥，面试中也常被问到。虽说有些基础性的问题可能不那么特别被面试官和求职者重视，但如果真的问起来，能不能回答的准确、全面、有深度，还是很容易体现出水平的。 在接下来的一个系列中，我会慢慢盘点一些 Spring 中常见但不好回答全面的问题，跟小伙伴们分享。 本文主题：Spring 的 IOC 如何回答的尽可能全面、准确、有深度。 问：什么是IOC？这是一个看上去特别简单、感觉很无脑的问题，很多求职者在回答这个问题时会不加思考、快速回答出一个很简单但同时也没有什么含量的答案。 草率的回答 IOC 是控制反转，Inverse of Control 。 试问一句，亲，你在做名词翻译吗？ 就算真的是在做名词翻译，也不应该只是把这个简称的全称解释出来就完事吧，好歹的展开解释点东西也好吧，作为面试官不应该只想听到这么一点点吧。 方向偏了 IOC 是控制反转，它把对象间的依赖关系的维护权利交给了 Spring ，程序本身不再维护。 这里面大体上把 IOC 的核心思想解释出来了：对象间的依赖关系的维护权利发生了转移，但是请小伙伴们注意，我们在问 IOC ，这个问题仅仅是问 IOC 本身，与具体的技术无关。IOC 不止有 Spring ，只是当下最强大的、使用最广的是 Spring 而已。 所以小伙伴们在回答理论、概念等问题时，不要直接在概念解释中提到具体的技术，技术都是概念和理论的落地实现，不止一种。单把一种拉出来，面试官可能会觉得：你是不是只知道这个？ 一种参考回答 该答案仅供参考，可根据自身的知识储备动态调整。 IOC 全名控制反转 Inverse of Control，它是一种编程原则，它的设计和架构可以实现组件间的解耦，核心思想是将控制权转移出去。 这里面提到了几个点： 编程原则：它是一种理论，而非具体的某种技术落地 组件间的解耦：所谓耦合，就是上面提到的对象间的依赖关系；解耦，就是解除了对象间的依赖关系。 提到解耦，有可能面试官会继续问“什么是解耦”，也有可能不会问 “为什么用 Spring ”了 控制权的转移：IOC 为了实现解耦，将原有的对象间的主动依赖改为被动接收型依赖（由直接 new 变为 set ） 问：IOC与DI的区别如果对 IOC 的实现不是特别了解，或者只是用 SpringFramework 用的太习惯了，亦或是刻板的学习 SpringFramework ，那这个答案通常会是这样的： IOC 就是 DI 。 如果回答出这个答案，而面试官碰巧也跟你一样，那恭喜你“瞎猫碰到死耗子”了！因为这个回答真的大错特错啊，IOC 不止有 DI 的！ 正确的回答应该是： IOC 是一种思想、编程原则，DI 是 IOC 思想的一种实现方式。 IOC 的实现方式有依赖查找（ Dependency lookup ）和依赖注入（ Dependency Injection ）。 上面已经介绍过了，IOC 仅仅是一种思想，它的意图是想让对象间的依赖控制发生转换。用过 SpringFramework 的小伙伴都知道，你没有在哪个地方见过直接写 IOC 的代码，都是由一些实现方式来体现 IOC 的。 如果按照上面这样回答，可能会引来下面一个问题： 依赖查找和依赖注入分别都是什么？如何区分它们？针对这个问题，最好不要一上来就搬出代码解释，最好是先理论后代码。 一般情况下，对比依赖查找和依赖注入，通常可以从以下几个维度对比： 依赖查找 依赖注入 实现方式 使用上下文（容器）主动获取 依赖上下文被动接收 作用目标 通常是方法体内的局部变量，也可以是对象成员 通常是对象成员 API依赖 依赖 IOC 框架的 API（必须操纵容器的 API ） 可以不依赖（暴露 setter 方法即可） applicationContext.getBean(beanName) public void setXXX() { … } 问：SpringFramework中实现的IOC有什么？真的不会有小伙伴只能答出 ApplicationContext 吧，一开始学的时候应该知道还有个 BeanFactory 吧。这是 SpringFramework 中两个核心的 IOC 容器的抽象。BeanFactory 仅仅是提供了一个容器管理的基本能力，ApplicationContext 在此基础上做了更加完善、强大的扩展。具体的对比可以参照下表： Feature BeanFactory ApplicationContext Bean instantiation/wiring —— Bean的实例化和属性注入 Yes Yes Integrated lifecycle management —— 生命周期管理 No Yes Automatic BeanPostProcessor registration —— Bean后置处理器的支持 No Yes Automatic BeanFactoryPostProcessor registration —— BeanFactory后置处理器的支持 No Yes Convenient MessageSource access (for internalization) —— 消息转换服务（国际化） No Yes Built-in ApplicationEvent publication mechanism —— 事件发布机制（事件驱动） No Yes 下面提供一个比较完整的示例答案，小伙伴们可以根据自己的知识储备和理解，调整这里面的一些描述细节： BeanFactory 接口提供了一个抽象的配置和对象的管理机制，ApplicationContext 是 BeanFactory 的子接口，它简化了与 AOP 的整合、消息机制、事件机制，以及对 Web 环境的扩展（ WebApplicationContext 等），BeanFactory 是没有这些扩展的。 ApplicationContext 主要扩展了以下功能：（括号内的部分是解释扩展功能的一些简单描述或者原理底层实现，能回答出来更好） AOP的支持（ AnnotationAwareAspectJAutoProxyCreator 作用于 Bean 的初始化之后 ） 配置元信息（ BeanDefinition 、Environment 、注解等 ） 资源管理（ Resource 抽象 ） 事件驱动机制（ ApplicationEvent 、ApplicationListener ） 消息与国际化（ LocaleResolver ） Environment 抽象（SpringFramework 3.1以后） 问：依赖注入的注入方式？有什么区别？注意这个问题也是与 SpringFramework 无关的，注入的方式本身就应该是依赖注入的实现，至于框架的代码，那是人家对于这个方式的落地。 可从以下几个维度对比： 注入方式 被注入成员是否可变 是否依赖IOC框架的API 使用场景 构造器注入 不可变 否（xml、编程式注入不依赖） 不可变的固定注入 参数注入 不可变 是（只能通过标注注解来侵入式注入） 通常用于不可变的固定注入 setter注入 可变 否（xml、编程式注入不依赖） 可选属性的注入 基本上问这个问题的话，还可能会继续问另一个问题： 你觉得哪种方式好？为什么？“莽夫”应聘者一看终于来开放式问题了，赶紧开始自由发挥了： 我觉得参数注入好，因为我写习惯了，给参数打注解多舒服啊！ 你是这么说了，面试官咋想：就这？就这？？？进而对你的印象可能就会有所减分了。 这种问题，除了要表述主观看法之外，更多的是要根据一些既有的论述来辅助你的观点，最好的论述那一定是官方文档了。 SpringFramework 的官方文档在不同的版本推荐的注入方式是不同的： SpringFramework 4.0.2 及之前是推荐 setter 注入，理由是一个 Bean 有多个依赖时，构造器的参数列表会很长；而且如果 Bean 中依赖的属性不都是必需的话，注入会变得更麻烦； 4.0.3 及以后官方推荐构造器注入，理由是构造器注入的依赖是不可变的、完全初始化好的，且可以保证不为 null ； 当然 4.0.3 及以后的官方文档中也说了，如果真的出现构造器参数列表过长的情况，可能是这个 Bean 承担的责任太多，应该考虑组件的责任拆解。 问：组件注入的注解有什么？有什么区别？相信大多数小伙伴都能答出 @Autowired 和 @Resource 吧，如果答出这两个，那证明你应该用过，也会用。但你能回答出 @Inject ，证明你对这些注入的注解确实有了解。作为应聘者，在回答问题时一定是回答的尽可能全面为好，下面对这几种注解作一个对比： 注解 注入方式 是否支持@Primary 来源 Bean不存在时处理 @Autowired 根据类型注入 是 SpringFramework原生注解 可指定 required=false 来避免注入失败 @Resource 根据名称注入 否 JSR250规范 容器中不存在指定Bean会抛出异常 @Inject 根据类型注入 是 JSR330规范 ( 需要导jar包 ) 容器中不存在指定Bean会抛出异常 跟上面差不多，如果问到了这个问题，那就有可能继续被问到下面一个问题： 存在多个相同类型Bean时如何解决注入问题？可能大多数小伙伴都能答出以下几种解决方案： @Resource ：根据名称指定注入的 Bean @Qualifier ：配合 @Autowired 注解使用，如果被标注的成员 / 方法在根据类型注入时发现有多个相同类型的 Bean ，则会根据该注解声明的 name 寻找特定的 bean @Primary ：配合 @Bean 注解使用，如果有多个相同类型的 Bean 同时注册到 IOC 容器中，使用 @Autowired 、@Inject 注解时会注入标注 @Primary 注解的 bean 其实你还可以提另外一种方案：把注入的字段名与 bean 的名称保持一致，这样也可以解决注入时报不唯一 Bean 的问题。 以上几个问题是关于 SpringFramework 与 IOC 部分的一些常见问题，倒是问题都不太陌生，但是小伙伴们想回答的全面、有深度，还是需要下下功夫的。希望小伙伴们能有所收获，在面试中流利回答，斩获 offer ！ 问题整理不易，不点个赞支持一下作者吗？（可怜巴巴）","categories":[{"name":"SpringFramework","slug":"SpringFramework","permalink":"http://yoursite.com/categories/SpringFramework/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"服务发现-EurekaServer的初始化和启动原理","slug":"服务发现-EurekaServer的初始化和启动原理","date":"2020-01-04T11:50:55.000Z","updated":"2020-05-23T06:04:13.840Z","comments":true,"path":"2020/01/04/服务发现-EurekaServer的初始化和启动原理/","link":"","permalink":"http://yoursite.com/2020/01/04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-EurekaServer%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/","excerpt":"","text":"刚学习 SpringCloud 的时候先要学习注册中心，也就是服务发现与治理。SpringCloudNetflix 的方案是使用 Eureka，咱也都很清楚了，下面咱先搭建一个只有 EurekaServer 的工程。 pom依赖只需要两个： 1&lt;dependency&gt;2 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;3 &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;4&lt;/dependency&gt;5&lt;dependency&gt;6 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;7 &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;8&lt;/dependency&gt; 启动类上标注 @EnableEurekaServer： 1@EnableEurekaServer2@SpringBootApplication3public class EurekaServerApplication &#123;4 public static void main(String[] args) &#123;5 SpringApplication.run(EurekaServerApplication.class, args);6 &#125;7&#125; application.yml 中配置一些最基础的信息： 1server:2 port: 900034spring:5 application:6 name: eureka-server78eureka:9 instance:10 hostname: eureka-server11 client:12 register-with-eureka: false13 fetch-registry: false14 service-url:15 defaultZone: http://localhost:9000/eureka/ 之后运行主启动类，EurekaServer 便会运行在9000端口上。 如果不标注 @EnableEurekaServer 注解，即便导入依赖也不会启动 EurekaServer，说明真正打开 EurekaServer 的是 @EnableEurekaServer 注解。 1. @EnableEurekaServer1@Import(EurekaServerMarkerConfiguration.class)2public @interface EnableEurekaServer &#123;3&#125; 它的文档注释非常简单： Annotation to activate Eureka Server related configuration. 用于激活 EurekaServer 相关配置的注解。 它被标注了一个 @Import 注解，导入的是一个 EurekaServerMarkerConfiguration 的配置类。 如果小伙伴对 @Import 注解还不是很了解，可以移步我的 《SpringBoot源码解读与原理分析》小册，先了解 SpringFramework 的基础。 2. EurekaServerMarkerConfiguration1@Configuration2public class EurekaServerMarkerConfiguration &#123;34 @Bean5 public Marker eurekaServerMarkerBean() &#123;6 return new Marker();7 &#125;89 class Marker &#123;1011 &#125;12&#125; 这段源码看上去莫名其妙的，它是一个配置类，然后它定义了一个 Marker 的内部类，又注册了一个Bean，但这光秃秃的，也没点别的逻辑，它到底想干啥？果然还是得靠文档注释： Responsible for adding in a marker bean to activate EurekaServerAutoConfiguration. 负责添加标记Bean来激活 EurekaServerAutoConfiguration 。 好吧，原来它的作用是给IOC容器中添加一个标记，代表要启用 EurekaServerAutoConfiguration 的自动配置类。 那咱就移步 EurekaServerAutoConfiguration 来看它的定义了。 3. EurekaServerAutoConfiguration看到 AutoConfiguration 结尾的类，咱马上要想到：这个类肯定在 spring.factories 文件标注好了，不然没法生效。 果然，在 spring-cloud-netflix-eureka-server 的 jar 包中发现了一个 spring.factories 文件，而文件内部的声明就是如此的简单： 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\2 org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration 没得跑，来看它的定义和声明吧： 1@Configuration2@Import(EurekaServerInitializerConfiguration.class)3@ConditionalOnBean(EurekaServerMarkerConfiguration.Marker.class)4@EnableConfigurationProperties(&#123; EurekaDashboardProperties.class,5 InstanceRegistryProperties.class &#125;)6@PropertySource(\"classpath:/eureka/server.properties\")7public class EurekaServerAutoConfiguration extends WebMvcConfigurerAdapter 注意看 @ConditionalOnBean 的条件：必须IOC容器中有一个 EurekaServerMarkerConfiguration.Marker 类型的 Bean，该配置类才会生效！（原来它是这样做自动配置开关的） 注意到它继承了 WebMvcConfigurerAdapter ，但全篇没有找到跟 WebMvcConfigurer 相关的部分，也没重写对应的方法。那它这是几个意思？这个时候咱要了解一个小背景： 在 SpringFramework5.0+ 后，因为接口可以直接声明 default 方法，所以 WebMvcConfigurerAdapter 被废弃（被标注 @Deprecated），替代方案是直接实现 WebMvcConfigurer 接口。 那既然是这样， 它还继承着这个适配器类，那咱可以大概猜测：它应该是旧版本的遗留。 回到正题，咱看 EurekaServerAutoConfiguration 的类定义声明上还有什么值得注意的。除了上面说的，那就只剩下一个了：它导入了一个 EurekaServerInitializerConfiguration 。 4. EurekaServerInitializerConfiguration1@Configuration2public class EurekaServerInitializerConfiguration implements ServletContextAware, SmartLifecycle, Ordered 注意它实现了 SmartLifecycle 接口，之前咱在《SpringBoot源码解读与原理分析》原理小册中提到过（第16篇 12.2.2章节），如果小伙伴们对这部分不了解，可以移步我的 《SpringBoot源码解读与原理分析》小册，这里咱直接说，它的核心方法是 start ： 1public void start() &#123;2 new Thread(new Runnable() &#123;3 @Override4 public void run() &#123;5 try &#123;6 // TODO: is this class even needed now?7 // 初始化、启动 EurekaServer8 eurekaServerBootstrap.contextInitialized(9 EurekaServerInitializerConfiguration.this.servletContext);10 log.info(\"Started Eureka Server\");1112 // 发布Eureka已注册的事件13 publish(new EurekaRegistryAvailableEvent(getEurekaServerConfig()));14 // 修改 EurekaServer 的运行状态15 EurekaServerInitializerConfiguration.this.running = true;16 // 发布Eureka已启动的事件17 publish(new EurekaServerStartedEvent(getEurekaServerConfig()));18 &#125; // catch ......19 &#125;20 &#125;).start();21&#125; （至此应该进一步意识到为什么上面 EurekaServerAutoConfiguration 继承了一个过时的类，Runnable 都没换成 Lambda 表达式。。。当然也跟 Eureka 1.x 不继续更新有关吧） 这个 start 方法只干了一件事，起一个新的线程来启动 EurekaServer 。这里面核心的 run 方法执行了这么几件事，都已经标注在源码中了。 这里面最重要的步骤就是第一步：初始化、启动 EurekaServer 。 在继续展开这部分源码之前，要带小伙伴了解一点前置知识。 EurekaServer 本身应该是一个完整的 Servlet 应用，在原生的 EurekaServer 中，EurekaServerBootstrap 这个类会实现 ServletContextListener 接口（Servlet3.0规范）来引导启动 EurekaServer 。SpringBoot 应用一般使用嵌入式 Web 容器，没有所谓 Servlet3.0 规范作用的机会了，所以需要另外的启动方式，于是 SpringCloud 在整合这部分时，借助了IOC容器中支持的 LifeCycle 机制，来以此触发 EurekaServer 的启动。 4.0 eurekaServerBootstrap.contextInitialized：初始化、启动EurekaServer1public void contextInitialized(ServletContext context) &#123;2 try &#123;3 initEurekaEnvironment();4 initEurekaServerContext();5 context.setAttribute(EurekaServerContext.class.getName(), this.serverContext);6 &#125; // catch......7&#125; 这里面又分为两个部分，依此来看： 4.1 initEurekaEnvironment：初始化Eureka的运行环境1private static final String TEST = \"test\";2private static final String DEFAULT = \"default\";34protected void initEurekaEnvironment() throws Exception &#123;5 log.info(\"Setting the eureka configuration..\");67 // Eureka的数据中心8 String dataCenter = ConfigurationManager.getConfigInstance()9 .getString(EUREKA_DATACENTER);10 if (dataCenter == null) &#123;11 log.info(12 \"Eureka data center value eureka.datacenter is not set, defaulting to default\");13 ConfigurationManager.getConfigInstance()14 .setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);15 &#125;16 else &#123;17 ConfigurationManager.getConfigInstance()18 .setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);19 &#125;20 // Eureka运行环境21 String environment = ConfigurationManager.getConfigInstance()22 .getString(EUREKA_ENVIRONMENT);23 if (environment == null) &#123;24 ConfigurationManager.getConfigInstance()25 .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);26 log.info(27 \"Eureka environment value eureka.environment is not set, defaulting to test\");28 &#125;29 else &#123;30 ConfigurationManager.getConfigInstance()31 .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, environment);32 &#125;33&#125; 这里面的逻辑咱乍一看，貌似都长得差不多啊，都是 获取 → 判断 → 设置 ，而且它们都有对应的默认值（源码中已标注）。至于这部分是干嘛的呢，咱不得不关注一下 setProperty 方法中的两个常量： 1private static final String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = \"archaius.deployment.environment\";2private static final String ARCHAIUS_DEPLOYMENT_DATACENTER = \"archaius.deployment.datacenter\"; 配置项的前缀是 archaius ，它是 Netflix 旗下的一个配置管理组件（提到这里，是不是产生了一种感觉：它会不会跟 SpringCloudConfig 有关系？然而并不是，当引入 SpringCloudConfig 时，archaius 并不会带进来），这个组件可以实现更强大的动态配置，它的基底是 Apache 的 commons-configuration ： ![](服务发现-EurekaServer的初始化和启动原理/3. archaius的底层依赖是commons-configuration.png) 对于这个组件，小册不展开研究了，小伙伴们只需要知道有这么回事就可以了，下面的才是重点。 4.2 initEurekaServerContext：初始化EurekaServer的运行上下文1protected void initEurekaServerContext() throws Exception &#123;2 // For backward compatibility 兼容低版本Eureka3 JsonXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(),4 XStream.PRIORITY_VERY_HIGH);5 XmlXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(),6 XStream.PRIORITY_VERY_HIGH);78 if (isAws(this.applicationInfoManager.getInfo())) &#123;9 this.awsBinder = new AwsBinderDelegate(this.eurekaServerConfig,10 this.eurekaClientConfig, this.registry, this.applicationInfoManager);11 this.awsBinder.start();12 &#125;1314 // 注册EurekaServerContextHolder，通过它可以很方便的获取EurekaServerContext15 EurekaServerContextHolder.initialize(this.serverContext);1617 log.info(\"Initialized server context\");1819 // Copy registry from neighboring eureka node20 // Eureka复制集群节点注册表21 int registryCount = this.registry.syncUp();22 this.registry.openForTraffic(this.applicationInfoManager, registryCount);2324 // Register all monitoring statistics.25 EurekaMonitors.registerAllStats();26&#125; 前面的一大段都是为了低版本兼容而做的一些额外工作，咱不关心这些。中间又是注册了一个 注册EurekaServerContextHolder 的组件，通过它可以直接获取 EurekaServerContext （它的内部使用简单的单例实现，实现非常简单，小伙伴可自行查看）。 注意最后几行，倒数第二个单行注释的内容： Copy registry from neighboring eureka node。 从相邻的eureka节点复制注册表。 节点复制注册表？这很明显是为了 Eureka 集群而设计的！由此可知 Eureka 集群能保证后起来的节点也不会出问题，是这里同步了注册表啊！这一步的操作非常复杂，咱后续另开一篇解释。 除了这部分之外，EurekaServerInitializerConfiguration 已经没有要配置的组件，回到 EurekaServerAutoConfiguration 中。 5. EurekaServerAutoConfiguration中配置的核心组件5.1 EurekaController1@Bean2@ConditionalOnProperty(prefix = \"eureka.dashboard\", name = \"enabled\", matchIfMissing = true)3public EurekaController eurekaController() &#123;4 return new EurekaController(this.applicationInfoManager);5&#125; 呦，一看这是个 Controller ，有木有立马想到自己写的那些 Controller ？赶紧点进去瞅一眼： 1@Controller2@RequestMapping(\"$&#123;eureka.dashboard.path:/&#125;\")3public class EurekaController 哇塞果然是我们熟悉的 SpringWebMvc 的内容！既然是一个 Controller ，那它肯定能给咱定义了一些处理方法，不然咱咋看到的 Eureka 控制台呢？翻看源码，它这里面定义了两个处理方法，分别是： status - 获取当前 EurekaServer 的状态（即控制台）、lastn - 获取当前 EurekaServer 上服务注册动态历史记录。这部分咱不展开描述了，有兴趣的小伙伴们可以深入这个类来研究。 5.2 PeerAwareInstanceRegistry1@Bean2public PeerAwareInstanceRegistry peerAwareInstanceRegistry(ServerCodecs serverCodecs) &#123;3 this.eurekaClient.getApplications(); // force initialization4 return new InstanceRegistry(this.eurekaServerConfig, this.eurekaClientConfig,5 serverCodecs, this.eurekaClient,6 this.instanceRegistryProperties.getExpectedNumberOfClientsSendingRenews(),7 this.instanceRegistryProperties.getDefaultOpenForTrafficCount());8&#125; 这个 PeerAwareInstanceRegistry 很重要，它是 EurekaServer 集群中节点之间同步微服务实例注册表的核心组件（这里默认小伙伴已经对 EurekaServer 的集群配置及相关基础都了解了）。集群节点同步注册表的内容咱会另起一篇研究，这里咱只是看一下这个类的继承结构，方面后续看到时不至于不认识： 1public class InstanceRegistry extends PeerAwareInstanceRegistryImpl implements ApplicationContextAware2public class PeerAwareInstanceRegistryImpl extends AbstractInstanceRegistry implements PeerAwareInstanceRegistry3public abstract class AbstractInstanceRegistry implements InstanceRegistry 这里面继承的两个类 PeerAwareInstanceRegistryImpl 、AbstractInstanceRegistry ，它们将会在后续研究节点同步时有重要作用，包括里面涉及的功能会在后面的组件（EurekaServerContext 等）发挥功能时带着一起解释。 5.3 PeerEurekaNodes1@Bean2@ConditionalOnMissingBean3public PeerEurekaNodes peerEurekaNodes(PeerAwareInstanceRegistry registry, ServerCodecs serverCodecs,4 ReplicationClientAdditionalFilters replicationClientAdditionalFilters) &#123;5 return new RefreshablePeerEurekaNodes(registry, this.eurekaServerConfig,6 this.eurekaClientConfig, serverCodecs, this.applicationInfoManager,7 replicationClientAdditionalFilters);8&#125; 这个 PeerEurekaNodes 可以理解成微服务实例的节点集合。换言之，一个 PeerEurekaNode 就是一个微服务节点实例的包装，PeerEurekaNodes 就是这组 PeerEurekaNode 的集合，这种节点是可以被 EurekaServer 集群中的各个注册中心节点共享的（PeerAwareInstanceRegistry）。翻开 PeerEurekaNodes 的结构，可以发现它的结构中有这么几样东西： 1public class PeerEurekaNodes &#123;23 protected final PeerAwareInstanceRegistry registry;4 // ......56 private volatile List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();7 private volatile Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();89 private ScheduledExecutorService taskExecutor; PeerAwareInstanceRegistry ：集群间节点同步的核心组件 List&lt;PeerEurekaNode&gt; ：节点集合 peerEurekaNodeUrls ：所有节点所在url ScheduledExecutorService ：执行定时任务的线程池 另外 PeerEurekaNodes 还提供了一个 start 和 shutdown 方法： 5.3.1 start1public void start() &#123;2 taskExecutor = Executors.newSingleThreadScheduledExecutor(3 new ThreadFactory() &#123;4 @Override5 public Thread newThread(Runnable r) &#123;6 Thread thread = new Thread(r, \"Eureka-PeerNodesUpdater\");7 thread.setDaemon(true);8 return thread;9 &#125;10 &#125;11 );12 try &#123;13 updatePeerEurekaNodes(resolvePeerUrls());14 Runnable peersUpdateTask = new Runnable() &#123;15 @Override16 public void run() &#123;17 try &#123;18 updatePeerEurekaNodes(resolvePeerUrls());19 &#125; // catch ......20 &#125;21 &#125;;22 taskExecutor.scheduleWithFixedDelay(23 peersUpdateTask,24 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),25 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),26 TimeUnit.MILLISECONDS27 );28 &#125; // catch ...... log ......29&#125; 可以发现 start 方法的核心是借助线程池完成定时任务。定时任务的内容是中间那一段实现了 Runnable 接口的匿名内部类，它会执行一个 updatePeerEurekaNodes 方法来更新集群节点。下面定时任务的执行时间，借助IDEA跳转到 EurekaServerConfigBean 中发现默认的配置是 10 分钟，即每隔10分钟会同步一次集群节点。至于 updatePeerEurekaNodes 的具体实现，咱同样放到后面跟节点同步放在一起来解析。 5.3.2 shutdown1public void shutdown() &#123;2 taskExecutor.shutdown();3 List&lt;PeerEurekaNode&gt; toRemove = this.peerEurekaNodes;45 this.peerEurekaNodes = Collections.emptyList();6 this.peerEurekaNodeUrls = Collections.emptySet();78 for (PeerEurekaNode node : toRemove) &#123;9 node.shutDown();10 &#125;11&#125; 这个方法的内容比较简单，它会把线程池的定时任务停掉，并移除掉当前所有的服务节点信息。它被调用的时机是下面要解析的 EurekaServerContext 。 5.4 EurekaServerContext1@Bean2public EurekaServerContext eurekaServerContext(ServerCodecs serverCodecs,3 PeerAwareInstanceRegistry registry, PeerEurekaNodes peerEurekaNodes) &#123;4 return new DefaultEurekaServerContext(this.eurekaServerConfig, serverCodecs,5 registry, peerEurekaNodes, this.applicationInfoManager);6&#125; 它创建了一个 DefaultEurekaServerContext ，文档注释原文翻译： Represent the local server context and exposes getters to components of the local server such as the registry. 表示本地服务器上下文，并将 getter 方法暴露给本地服务器的组件（例如注册表）。 可以大概的意识到，它确实跟 SpringFramework 的 ApplicationContext 差不太多哈，可以这么简单地理解吧，咱还是看看里面比较特殊的内容。 进入到 DefaultEurekaServerContext 中，果然发现了两个特殊的方法： 1@PostConstruct2public void initialize() &#123;3 logger.info(\"Initializing ...\");4 peerEurekaNodes.start();5 try &#123;6 registry.init(peerEurekaNodes);7 &#125; catch (Exception e) &#123;8 throw new RuntimeException(e);9 &#125;10 logger.info(\"Initialized\");11&#125;1213@PreDestroy14public void shutdown() &#123;15 logger.info(\"Shutting down ...\");16 registry.shutdown();17 peerEurekaNodes.shutdown();18 logger.info(\"Shut down\");19&#125; 果然，是 EurekaServerContext 的初始化，带动 PeerEurekaNodes 的初始化，EurekaServerContext 的销毁带动 PeerEurekaNodes 的销毁。除了带动 PeerEurekaNodes 之前，还有一个 PeerAwareInstanceRegistry 也带动初始化了，看一眼它的 init 方法吧： 5.4.1 PeerAwareInstanceRegistry#init关键部分注释已标注在源码： 1public void init(PeerEurekaNodes peerEurekaNodes) throws Exception &#123;2 // 5.4.1.1 启动续订租约的频率统计器3 this.numberOfReplicationsLastMin.start();4 this.peerEurekaNodes = peerEurekaNodes;5 initializedResponseCache();6 // 5.4.1.2 开启续订租约最低阈值检查的定时任务7 scheduleRenewalThresholdUpdateTask();8 // 5.4.1.3 初始化远程分区注册中心9 initRemoteRegionRegistry();1011 try &#123;12 Monitors.registerObject(this);13 &#125; catch (Throwable e) &#123;14 logger.warn(\"Cannot register the JMX monitor for the InstanceRegistry :\", e);15 &#125;16&#125; 源码标注了三个关键的环节，一一来看： 5.4.1.1 numberOfReplicationsLastMin.start()：启动续订租约的频率统计器1private final AtomicLong lastBucket = new AtomicLong(0);2private final AtomicLong currentBucket = new AtomicLong(0);34private final long sampleInterval;56public synchronized void start() &#123;7 if (!isActive) &#123;8 timer.schedule(new TimerTask() &#123;9 @Override10 public void run() &#123;11 try &#123;12 // Zero out the current bucket.13 lastBucket.set(currentBucket.getAndSet(0));14 &#125; catch (Throwable e) &#123;15 logger.error(\"Cannot reset the Measured Rate\", e);16 &#125;17 &#125;18 &#125;, sampleInterval, sampleInterval);19 isActive = true;20 &#125;21&#125; 这个方法实现不难理解，它会隔一段时间重置 lastBucket 和 currentBucket 的值为0，那时间间隔是多少呢？翻看整个类，发现只有构造方法可以设置时间间隔： 1public MeasuredRate(long sampleInterval) &#123;2 this.sampleInterval = sampleInterval;3 this.timer = new Timer(\"Eureka-MeasureRateTimer\", true);4 this.isActive = false;5&#125; 借助IDEA，发现设置 sampleInterval 的值有两处，但值都是一样的：new MeasuredRate(1000 * 60 * 1); ，也就是1分钟重置一次。可关键的问题是，它这个操作是干嘛呢？为啥非得一分钟统计一次续约次数呢？实际上，这个计算次数会体现在 Eureka 的控制台，以及配合 Servo 完成续约次数监控（说白了，咱这看着没啥用，微服务监控和治理还是管用的，不然为什么 Eureka 被称为服务发现与治理的框架呢）。 5.4.1.2 scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务1private int renewalThresholdUpdateIntervalMs = 15 * MINUTES;23private void scheduleRenewalThresholdUpdateTask() &#123;4 timer.schedule(new TimerTask() &#123;5 @Override6 public void run() &#123;7 updateRenewalThreshold();8 &#125;9 &#125;, serverConfig.getRenewalThresholdUpdateIntervalMs(),10 serverConfig.getRenewalThresholdUpdateIntervalMs());11&#125; 又是一个定时任务，配置项中的默认时间间隔可以发现是15分钟。那定时任务中执行的核心方法是 updateRenewalThreshold 方法，跳转过去： 1private void updateRenewalThreshold() &#123;2 try &#123;3 Applications apps = eurekaClient.getApplications();4 int count = 0;5 for (Application app : apps.getRegisteredApplications()) &#123;6 for (InstanceInfo instance : app.getInstances()) &#123;7 if (this.isRegisterable(instance)) &#123;8 ++count;9 &#125;10 &#125;11 &#125;12 synchronized (lock) &#123;13 // Update threshold only if the threshold is greater than the14 // current expected threshold or if self preservation is disabled.15 if ((count) &gt; (serverConfig.getRenewalPercentThreshold() * expectedNumberOfClientsSendingRenews)16 || (!this.isSelfPreservationModeEnabled())) &#123;17 this.expectedNumberOfClientsSendingRenews = count;18 updateRenewsPerMinThreshold();19 &#125;20 &#125;21 logger.info(\"Current renewal threshold is : &#123;&#125;\", numberOfRenewsPerMinThreshold);22 &#125; // catch ......23&#125; 上面的 for 循环很明显是检查当前已经注册到本地的服务实例是否还保持连接，由于该方法一定会返回 true （可翻看该部分实现，全部都是 return true），故上面统计的 count 就是所有的微服务实例数量。 下面的同步代码块中，它会检查统计好的数量是否比预期的多，如果统计好的服务实例数比预期的数量多，证明出现了新的服务注册，要替换下一次统计的期望数量值，以及重新计算接下来心跳的数量统计。心跳的数量统计方法 updateRenewsPerMinThreshold() ： 1private int expectedClientRenewalIntervalSeconds = 30;2private double renewalPercentThreshold = 0.85;34protected void updateRenewsPerMinThreshold() &#123;5 this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfClientsSendingRenews6 * (60.0 / serverConfig.getExpectedClientRenewalIntervalSeconds())7 * serverConfig.getRenewalPercentThreshold());8&#125; 可以看出来它的计算数是：每隔30秒发一次心跳（一分钟心跳两次），而且必须所有的服务实例的心跳总数要达到前面计算数量的85%才算整体微服务正常，其实这也就是 EurekaServer 的自我保护机制。 5.4.1.3 initRemoteRegionRegistry：初始化远程分区注册中心1protected void initRemoteRegionRegistry() throws MalformedURLException &#123;2 Map&lt;String, String&gt; remoteRegionUrlsWithName = serverConfig.getRemoteRegionUrlsWithName();3 if (!remoteRegionUrlsWithName.isEmpty()) &#123;4 allKnownRemoteRegions = new String[remoteRegionUrlsWithName.size()];5 int remoteRegionArrayIndex = 0;6 for (Map.Entry&lt;String, String&gt; remoteRegionUrlWithName : remoteRegionUrlsWithName.entrySet()) &#123;7 RemoteRegionRegistry remoteRegionRegistry = new RemoteRegionRegistry(8 serverConfig,9 clientConfig,10 serverCodecs,11 remoteRegionUrlWithName.getKey(),12 new URL(remoteRegionUrlWithName.getValue()));13 regionNameVSRemoteRegistry.put(remoteRegionUrlWithName.getKey(), remoteRegionRegistry);14 allKnownRemoteRegions[remoteRegionArrayIndex++] = remoteRegionUrlWithName.getKey();15 &#125;16 &#125;17 logger.info(\"Finished initializing remote region registries. All known remote regions: &#123;&#125;\",18 (Object) allKnownRemoteRegions);19&#125; 这里面提到了一个概念：RemoteRegionRegistry ，它的文档注释原文翻译： Handles all registry operations that needs to be done on a eureka service running in an other region. The primary operations include fetching registry information from remote region and fetching delta information on a periodic basis. 处理在其他区域中运行的eureka服务上需要完成的所有注册表操作。主要操作包括从远程区域中获取注册表信息以及定期获取增量信息。 文档注释的解释看着似懂非懂，它没有把这个类的作用完全解释清楚。实际上这里涉及到 Eureka 的服务分区，这个咱留到后面解释 Eureka 的高级特性时再聊。 5.4.2 PeerAwareInstanceRegistry#shutdown当 EurekaServerContext 被销毁时，会回调 @PreDestory 标注的 shutdown 方法，而这个方法又调到 PeerAwareInstanceRegistry 的 shutdown 方法。 1public void shutdown() &#123;2 try &#123;3 DefaultMonitorRegistry.getInstance().unregister(Monitors.newObjectMonitor(this));4 &#125; // catch .......5 try &#123;6 peerEurekaNodes.shutdown();7 &#125; // catch .......8 numberOfReplicationsLastMin.stop();9 super.shutdown();10&#125; 这里它干的事情不算麻烦，它首先利用 DefaultMonitorRegistry 做了一个注销操作，DefaultMonitorRegistry 这个组件本身来源于 servo 包，它是做监控使用，那自然能猜出来这部分是关闭监控。接下来它会把那些微服务节点实例全部注销，停止计数器监控，最后回调父类的 shutdown 方法： 1public void shutdown() &#123;2 deltaRetentionTimer.cancel();3 evictionTimer.cancel();4 renewsLastMin.stop();5&#125; 可以发现也是跟监控相关的组件停止，不再赘述。 5.5 EurekaServerBootstrap1@Bean2public EurekaServerBootstrap eurekaServerBootstrap(PeerAwareInstanceRegistry registry,3 EurekaServerContext serverContext) &#123;4 return new EurekaServerBootstrap(this.applicationInfoManager,5 this.eurekaClientConfig, this.eurekaServerConfig, registry,6 serverContext);7&#125; 这个咱上面已经提过了，有了 EurekaServerBootstrap 才能引导启动 EurekaServer 。 5.6 ServletContainer1@Bean2public FilterRegistrationBean jerseyFilterRegistration(javax.ws.rs.core.Application eurekaJerseyApp) &#123;3 FilterRegistrationBean bean = new FilterRegistrationBean();4 bean.setFilter(new ServletContainer(eurekaJerseyApp));5 bean.setOrder(Ordered.LOWEST_PRECEDENCE);6 bean.setUrlPatterns(Collections.singletonList(EurekaConstants.DEFAULT_PREFIX + \"/*\"));7 return bean;8&#125; 它注册的 FilterRegistrationBean 我在之前的《SpringBoot源码解读与原理分析》中有提过（第6章4.1.2节），这里咱直接说核心的 Filter 是 ServletContainer ： 1package com.sun.jersey.spi.container.servlet;23public class ServletContainer extends HttpServlet implements Filter 注意它所在的包，里面有一个很关键的词：jersey ，它是一个类似于 SpringWebMvc 的框架，由于 Eureka 本身也是一个 Servlet 应用，只是它使用的 Web 层框架不是 SpringWebMvc 而是 Jersey 而已，Jersey 在 Eureka 的远程请求、心跳包发送等环节起到至关重要的作用，后续咱会详细解释。 5.7 Application1@Bean2public javax.ws.rs.core.Application jerseyApplication(Environment environment,3 ResourceLoader resourceLoader) &#123;4 // ......5&#125; 这个类的创建咱不是很关心，瞅一眼这个类的子类，发现全部都是来自 Jersey 的： ![](服务发现-EurekaServer的初始化和启动原理/3. Application下面的子类全部都是jersey的.png) 而且上面的 ServletContainer 中正好也用到了这个 Application ，那大概也明白它是配合上面的过滤器使用，后续咱会跟上面的 Jersey 一起解释。 5.8 HttpTraceFilter1@Bean2public FilterRegistrationBean traceFilterRegistration(@Qualifier(\"httpTraceFilter\") Filter filter) &#123;3 FilterRegistrationBean bean = new FilterRegistrationBean();4 bean.setFilter(filter);5 bean.setOrder(Ordered.LOWEST_PRECEDENCE - 10);6 return bean;7&#125; 它注册了一个名为 httpTraceFilter 的过滤器，借助IDEA发现这个过滤器来自 HttpTraceAutoConfiguration 的内部类 ServletTraceFilterConfiguration ： 1@Configuration2@ConditionalOnWebApplication(type = Type.SERVLET)3static class ServletTraceFilterConfiguration &#123;4 @Bean5 @ConditionalOnMissingBean6 public HttpTraceFilter httpTraceFilter(HttpTraceRepository repository, HttpExchangeTracer tracer) &#123;7 return new HttpTraceFilter(repository, tracer);8 &#125;9&#125; 这个过滤器的作用也很容易猜想，trace 的概念咱从日志系统里也接触过，它打印的内容非常非常多，且涵盖了上面的几乎所有级别。这个类的文档注释也恰好印证了我们的猜想： Servlet Filter that logs all requests to an HttpTraceRepository. 记录所有请求日志的Servlet过滤器。 6. EurekaServerConfigBeanConfigurationEurekaServerAutoConfiguration 还有一个内部的配置类：EurekaServerConfigBeanConfiguration 1@Configuration2protected static class EurekaServerConfigBeanConfiguration &#123;3 @Bean4 @ConditionalOnMissingBean5 public EurekaServerConfig eurekaServerConfig(EurekaClientConfig clientConfig) &#123;6 EurekaServerConfigBean server = new EurekaServerConfigBean();7 if (clientConfig.shouldRegisterWithEureka()) &#123;8 // Set a sensible default if we are supposed to replicate9 server.setRegistrySyncRetries(5);10 &#125;11 return server;12 &#125;13&#125; 它就是注册了默认的 EurekaServer 的配置模型，这个模型类里的配置咱上面也看到一些了，后面的部分咱还会接触它，先有一个印象即可。 小结 @EnableEurekaServer 注解会激活 EurekaServer 的自动配置，核心是向IOC容器注册一个 Marker 的内部类。 EurekaServerInitializerConfiguration 负责 EurekaServer 的初始化，初始化的过程包括本身初始化、运行环境初始化、运行上下文的初始化。 EurekaServerAutoConfiguration 注册的核心组件包括展示控制台的 Controller 、微服务节点实例的模型和管理组件、EurekaServerContext、EurekaServerBootstrap（启动引导类）、两个过滤器。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"EurekaServer","slug":"EurekaServer","permalink":"http://yoursite.com/tags/EurekaServer/"}]},{"title":"嵌入式容器：嵌入式Tomcat的优化和配置","slug":"嵌入式容器：嵌入式Tomcat的优化和配置","date":"2019-12-02T12:17:59.000Z","updated":"2019-12-02T12:21:25.547Z","comments":true,"path":"2019/12/02/嵌入式容器：嵌入式Tomcat的优化和配置/","link":"","permalink":"http://yoursite.com/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"在以往的开发中我们可能会根据项目本身对 Tomcat 进行一些调整，以达到最大化利用 Tomcat 的目的。SpringBoot 使用嵌入式 Tomcat，再像之前那样做 Tomcat 性能调优就显得不那么现实了，为此我们需要了解如何在 SpringBoot 内部给嵌入式 Tomcat 做性能调优。本篇文章只做定性的解析，深入到量的控制本文不作详细探讨。 0. 调优前的准备为测试当前 SpringBoot 中嵌入式 Tomcat 的最大性能，需要一个压力测试工具来辅助我们测试性能，目前应用比较多的压测工具有 Bench 和 JMeter ，本文中使用 Bench 作为压测工具。 测试之前，咱先把工具准备好： Bench：https://www.apachelounge.com/download/ JMeter：http://jmeter.apache.org/download_jmeter.cgi 下载好之后，把这两个工具的环境变量都配置好，方便直接从控制台执行。 除此之外，把一开始的测试工程中加入一个测试的 DemoController ，用于接收请求压测（为模拟真实业务场景，会在 DemoController 中让线程随机阻塞 100 - 500ms ，以代替数据库连接和业务查询）。最后，把工程打成可执行jar包并启动，等待测试。 jar包启动的方式非常简单：java -jar demo-0.0.1-SNAPSHOT.jar （本文在进行压测时的物理环境：Windows10 + Intel Core i7-8750H） 1. 使用Bench进行压测在cmd中执行如下命令： ab -n 10000 -c 500 http://localhost:8080/test 执行完成后会在控制台打印测试报告：（报告中的指标解释已标注在行尾） 1This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;2Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/3Licensed to The Apache Software Foundation, http://www.apache.org/45Benchmarking localhost (be patient)6Completed 1000 requests7Completed 2000 requests8Completed 3000 requests9Completed 4000 requests10Completed 5000 requests11Completed 6000 requests12Completed 7000 requests13Completed 8000 requests14Completed 9000 requests15Completed 10000 requests16Finished 10000 requests171819Server Software:20Server Hostname: localhost // 主机名21Server Port: 8080 // 端口号2223Document Path: /test24Document Length: 4 bytes2526Concurrency Level: 500 // 并发量27Time taken for tests: 15.670 seconds // 所有请求的总耗时28Complete requests: 10000 // 成功的请求数29Failed requests: 030Total transferred: 1360000 bytes // 总传输数据量31HTML transferred: 40000 bytes // 总响应数据量32Requests per second: 638.17 [#/sec] (mean) // 【重要】每秒执行的请求数量（吞吐量）33Time per request: 783.493 [ms] (mean) // 【重要】客户端平均响应时间34Time per request: 1.567 [ms] (mean, across all concurrent requests) // 服务器平均请求等待时间35Transfer rate: 84.76 [Kbytes/sec] received // 每秒传输的数据量3637Connection Times (ms)38 min mean[+/-sd] median max39Connect: 0 0 0.2 0 140Processing: 105 738 135.1 742 99341Waiting: 105 738 135.2 742 99342Total: 105 738 135.1 742 9934344Percentage of the requests served within a certain time (ms)45 50% 74246 66% 81047 75% 84748 80% 86849 90% 90950 95% 93151 98% 94552 99% 95253 100% 993 (longest request) 在测试报告中有两个重要的指标需要咱来关注： Requests per second：每秒执行的请求数量（吞吐量） 吞吐量越高，代表性能越好 Time per request：客户端平均响应时间 响应时间越短，代表性能越好 在这里面测得的结果是 638.17 的吞吐量，783.493ms 的平均响应时间，这个响应时间比代码中控制的阻塞时间更长，说明 Tomcat 对500的并发已经有一些吃力了。 下面咱再用更大的并发量来测试效果： ab -n 50000 -c 2000 http://localhost:8080/test 测得的结果（截取主要部分）： 1Concurrency Level: 20002Time taken for tests: 75.689 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 660.60 [#/sec] (mean)8Time per request: 3027.564 [ms] (mean)9Time per request: 1.514 [ms] (mean, across all concurrent requests)10Transfer rate: 87.74 [Kbytes/sec] received 发现吞吐量没有什么太大的变化，但平均响应时间大幅提升，且大概为上面的4倍。可以看得出来，Tomcat 的处理速度已经远远跟不上请求到来的速度，需要进行性能调优。 2. 嵌入式Tomcat调优依据调优一定要有依据，咱根据现状和之前对 SpringBoot 的学习和原理剖析，应该知道配置大多都是两种形式： 声明式配置：application.properties 或 application.yml 编程式配置：XXXConfigurer 或 XXXCustomizer 其中，利用配置文件进行配置，最终会映射到 SpringBoot 中的一些 Properties 类中，例如 server.port 配置会映射到 ServerProperties 类中： 1@ConfigurationProperties(prefix = \"server\", ignoreUnknownFields = true)2public class ServerProperties &#123;3 private Integer port; 那我们来大体分析一下对于 Tomcat 的声明式配置，都有哪些可以控制的部分： 2.1 Tomcat的声明式配置在 ServerProperties 类中，有一个 Tomcat 的静态内部类： 1/**2 * Tomcat properties.3 */4public static class Tomcat &#123;5 // ...... 这里面就是配置嵌入式 Tomcat 的可以供我们配置的映射配置类。咱来看里面的核心属性： 1/**2 * Maximum amount of worker threads.3 * 最大工作线程数4 */5private int maxThreads = 200;67/**8 * Minimum amount of worker threads.9 * 最小工作线程数10 */11private int minSpareThreads = 10;1213/**14 * Maximum number of connections that the server accepts and processes at any15 * given time. Once the limit has been reached, the operating system may still16 * accept connections based on the \"acceptCount\" property.17 * 服务器最大连接数18 */19private int maxConnections = 10000;2021/**22 * Maximum queue length for incoming connection requests when all possible request23 * processing threads are in use.24 * 最大请求队列等待长度25 */26private int acceptCount = 100; 可以发现这里面的几个指标，分别控制连接数、线程数、等待数。 咱来分析为什么上面的吞吐量不够大：请求中的关键耗时动作是 Thread.sheep 卡线程，导致吞吐量变大。Thread.sleep 模拟了IO操作、数据库交互等非CPU高速计算的行为，在数据库交互时，CPU资源被浪费，导致无法处理后来的请求，出现资源利用率低的现象。为此，我们需要提高请求并发数，以此来提高CPU利用率。提高请求并发的方法在上面的几个参数中很明显是 maxThreads 。 3. 调整maxThreads从源码中很明显看到默认的最大线程数是200，我们在 application.properties 中修改值为 500： server.tomcat.max-threads=500 修改之后的测试： 1Concurrency Level: 20002Time taken for tests: 30.910 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 1617.61 [#/sec] (mean)8Time per request: 1236.391 [ms] (mean)9Time per request: 0.618 [ms] (mean, across all concurrent requests)10Transfer rate: 214.84 [Kbytes/sec] received 发现吞吐量有明显的提升，且吞吐量的放大倍数大概是前面线程数为 200 时的2.5倍。继续放大该值为 2000： server.tomcat.max-threads=2000 重新测试效果： 1Concurrency Level: 20002Time taken for tests: 12.050 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 4149.38 [#/sec] (mean)8Time per request: 482.000 [ms] (mean)9Time per request: 0.241 [ms] (mean, across all concurrent requests)10Transfer rate: 551.09 [Kbytes/sec] received 吞吐量又一次明显上升，但注意此时的吞吐量并没有扩大到上一次的 4 倍。继续放大该值为 10000： server.tomcat.max-threads=10000 重新测试效果： 1Concurrency Level: 20002Time taken for tests: 13.808 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 3621.22 [#/sec] (mean)8Time per request: 552.300 [ms] (mean)9Time per request: 0.276 [ms] (mean, across all concurrent requests)10Transfer rate: 480.94 [Kbytes/sec] received 发现吞吐量竟然下降了！为什么会出现这种现象呢？ 4. 现象解释要解释这个原因，就不得不提到 CPU 的工作原理了。当CPU的核心线程数小于当前应用线程时，CPU为了保证所有应用线程都正常执行，它会在多个线程中来回切换，以保证每个线程都能获得CPU时间。在一个确定的时间点中，一个CPU只能处理一个线程。 所以这个现象就可以这样解释：当开启的 Tomcat 线程过多时，CPU会消耗大量时间在这些 Tomcat 线程中来回切换，导致真正处理业务请求的时间变少，最终导致整体应用处理速度变慢。 由此也可以推出另一种可能：如果业务逻辑中有大量CPU处理工作（如运算、处理数据等），则CPU需要更多的时间用于计算，此时若 Tomcat 线程过多，则处理速度会更慢。 5. 总结由上面的情况可以总结出以下结论： 应用中大部分业务逻辑都是阻塞型处理（IO、数据库操作等），这种情况下CPU的压力较低，可以适当调大 maxThreads 的值大小。 应用中大部分业务逻辑都是数据处理和计算，这种情况下CPU的压力较大，应适当调小 maxThreads 的值大小。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"Tomcat, 嵌入式容器, SpringBoot","slug":"Tomcat-嵌入式容器-SpringBoot","permalink":"http://yoursite.com/tags/Tomcat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8-SpringBoot/"}]}]}