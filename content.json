{"meta":{"title":"LinkedBear的GitHub","subtitle":"","description":"LinkedBear的GitHub博客","author":"LinkedBear","url":"http://yoursite.com","root":"/"},"pages":[{"title":"纸质图书","date":"2022-10-20T02:00:00.000Z","updated":"2022-10-18T01:50:11.742Z","comments":true,"path":"book/index.html","permalink":"http://yoursite.com/book/index.html","excerpt":"","text":"《SpringBoot 源码解读与原理分析》SpringBoot 从诞生至今已有数个年头，依托其简单易用、覆盖场景广泛、满足分布式应用快速开发等特性，使得 SpringBoot 迅速成为互联网软件开发的基础框架首选。SpringBoot 本身的设计之强大、巧妙，内部蕴含着让许多开发者和使用者争相学习的设计、思想等精华，无论您是什么段位，通过研究 SpringBoot 与 SpringFramework 的源码与底层设计，都会使能力得到不同程度的提升。但是，能够做到深挖源码和理解原理设计的人实在少之又少，总结关键因素可以发现主要包含以下几点： 阅读源码是一件难度极大且费时费力的工作，对于开发者而言单枪匹马深入底层研究，其投入产出比太低； 框架源码的底层过于复杂，尤其是经历了近 20 年迭代的老牌框架，其内部设计之精炼、覆盖之全面、结构之庞大可想而知，这也为想要研究源码的开发者提高了很大难度； 借助网络可以找到与源码解读相关的资料和博客，但由于大多不成体系、没有来龙去脉等原因，导致出现“读不懂”、“没听说过”等尴尬现状，长期多次出现尴尬现状会引起深入学习的负反馈，最终导致退缩甚至放弃。 基于以上原因可以发现，开发者对于学习 SpringBoot 与 SpringFramework 的原理与设计是有意向的，但由于门槛高、难度大、难成体系等障碍因素导致望而却步。为了给各位同仁提供一个相对合理、平滑、系统的源码阅读与学习轨迹，我前前后后花了 2 年半的时间编写了本书，总结了自己对 SpringBoot 与 SpringFramework 的研究和理解，希望能对正在探究和准备开始学习 SpringBoot 原理的开发者提供一些帮助。 目标读者本书并不是一本 SpringBoot 的入门图书，所以需要正在阅读的您至少了解 SpringBoot 和 SpringFramework ，并有基本的使用经验即可，无需了解地很深入。除此之外，还希望读者对 JavaSE 、JavaEE 的相关基础有一定的掌握。因此本书更适合以下人群阅读： 会使用 SpringBoot 、SpringFramework 的同学； 有实际的项目开发经验，但不满足于浅层次使用现状的同学； 能熟练使用 SpringBoot ，但没有深入挖掘深层次特性和高级使用的同学； 职业规划目标为技术总监、架构师等高级技术岗位的同学； 技术广度足够，但深度有限的同学； 被 SpringBoot 、SpringFramework 问题困扰的求职者； 有意向对 Spring 生态深入探究的研究者。 售后答疑凡是购买本书的小伙伴，可以扫码加我好友进交流答疑群（也可搜微信号：LinkedBearrr ），答疑群中可以提问有关本书 / 本人撰写小册的问题。加好友后请声明来意并拍照本书的目录页（防止广告营销类号），感谢小伙伴的配合！ 为划分交流和答疑区，可在加好友后向我指定加哪个群（交流 or 答疑），交流群以唠嗑为主，答疑群以技术交流和讨论为主。"},{"title":"关于阿熊","date":"2022-11-01T02:00:00.000Z","updated":"2022-10-18T01:32:36.480Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一个平凡的码农我不是什么有身份的人，在圈子里也没什么动静。我只是一个默默研究框架源码，以及其中内部原理的草根研究者，也不是什么很牛的组件贡献者，平时闷头翻源码是我喜欢做的事情，分享是我的乐趣。平常工作中，我通常扮演偏架构和偏基础组件的研发。 机缘巧合的小册我有一个关系很好的小圈子，那些伙计鼓励我写一本 SpringBoot 的小册（毕竟那是我研究最多的框架之一），机缘巧合之下，我联系到了掘金平台，从此开始了我的创作路。小册发布后评价都还不错，感谢小伙伴们的认可和对我的支持，目前也有几本 Spring 的小册还有 MyBatis 小册的产出了，后续我还会有更多的产出。 潜心作成的图书2021 年的年初，我有幸接触到了人民邮电出版社的编辑老师，在了解双方意愿后，我们非常愉快地达成了合作，随后我用了一年多的时间撰写了现在的这本《SpringBoot 源码解读与原理分析》的纸质图书。书很厚，讲的内容非常多，算是本人近几年出力最多的作品了。 寻找我的方式 微信：LLLinkedBear 微信公众号 ：老熊说Spring （推文少，主要为推送通知使用） GitHub ：https://github.com/LinkedBear 邮箱 ：LinkedBear@163.com"},{"title":"掘金小册","date":"2021-08-01T09:49:54.000Z","updated":"2022-10-18T02:04:15.080Z","comments":true,"path":"juejin/index.html","permalink":"http://yoursite.com/juejin/index.html","excerpt":"","text":"掘金小册的创作由来我有一个关系很好的小圈子，那些伙计鼓励我写一本 SpringBoot 的小册（毕竟那是我研究最多的框架之一），机缘巧合之下，我联系到了掘金平台，从此开始了我的创作路。小册发布后评价都还不错，感谢小伙伴们的认可和对我的支持，我也会在后续有更多的产出。 SpringBoot 小册SpringBoot 的小册虽说是第一本小册，里面的内容还是很多的，对 SpringFramework 和 SpringBoot 有深入理解的想法的小伙伴，你可以去读几篇体会一下，如果感觉你喜欢或者你需要的话，不妨买来看看(滑稽)，虽说不贵，但内容绝对超值（已得到多名小伙伴的反馈）。 跳转戳 → https://juejin.cn/book/6844733814560784397 SpringCloudNetflix小册时隔半年，SpringCloud 的小册也终于发行了，上篇讲的都是 SpringCloudNetflix 下的解决方案集，小册延续 SpringBoot 的风格，详细解析源码和内部的设计实现原理，相信对于想系统了解 SpringCloud 原理的小伙伴来讲，这是一个不错的帮助。 跳转戳 → https://juejin.cn/book/6844733831069564941 从 0 开始深入学习 Spring 小册一直以来，Spring 作为 Java 界最最受欢迎的框架（没有之一），它的地位无疑是极高的。无论是之前流行的 SSH ，到后来的 SSM ，再到现在的分布式、微服务、云原生，底层的技术栈无一不用 Spring ，且 Spring 本身有着强大的整合能力，它配合构建的开发生态也是最庞大的。可以这么说，Spring 早已成为 Java 开发的主流标准，掌握 Spring 框架，对平时的开发，甚至是进攻大厂、获得更好地职业前景，都是非常关键的一部分。 小册以 SpringFramework 的入门为起点，逐步带你学习 SpringFramework 的进阶、高级，和底层的原理，不需要小伙伴有前置的框架学习和使用经验，只需要最起码的 JavaSE 知识、JavaWeb 知识即可。当然，如果小伙伴已经有 SpringFramework 的使用经验，但还想深层次学习更高级的知识，小册也会给你讲解更深入的特性和用法。总之，这本小册的受众群体非常大，想学的小伙伴一定要去看看呀！ 这本小册目前已经连载完毕，八十多个章节的小册估计小伙伴也没怎么见过吧，信我一句话，买它就对了！（目前已好评如潮） 小册还会不定时更新加餐内容，恩，我就是这么良心 ~ ~ ~ 跳转戳 → https://juejin.cn/book/6857911863016390663 玩转 MyBatis ：深度解析与定制小册之前在写 《从 0 开始深入学习 Spring》 小册时，阿熊提到过一件事：学习 JavaEE 开发的第一个框架，大多数是推荐 MyBatis 的，因为它相对简单，学习起来也相对轻松。不过不要因为 MyBatis 入门简单，就认为 MyBatis 这个框架简单。MyBatis 自打 2001 年问世，到 2004 年出来 iBATIS 2.0 ，再到 2010 年发布 MyBatis 3.0 ，这个框架的设计和底层一直都广受研究，也有不少开发者从中汲取到了宝贵的设计经验。总的来说，MyBatis 是一个非常优秀的持久层框架，是一个使用起来简单的框架，同时也是一个值得我们去深入研究和探索的框架。 小册目前连载完毕，共计 40 章节，包含从配置、Mapper 到众多特性，再到生命周期原理和设计模式，最后还有带各位动手封装一下 MyBatis ，对于深入学习 MyBatis 来讲绝对是一个不错的参考。 跳转戳 → https://juejin.cn/book/6944917557878980638 后续计划SpringBoot 的原理讲解完毕后，我想再对日常开发中的场景整合做一个尽可能多而全的覆盖，顺便也讲解下里面的一些深层次原理和机制，所以目前筹划的是写一本与 SpringBoot 整合各种场景开发的小册，敬请期待！"}],"posts":[{"title":"2021.05.15  闲聊","slug":"2021.05.15  闲聊","date":"2021-05-15T13:30:00.000Z","updated":"2021-05-15T23:53:34.245Z","comments":true,"path":"2021/05/15/2021.05.15  闲聊/","link":"","permalink":"http://yoursite.com/2021/05/15/2021.05.15%20%20%E9%97%B2%E8%81%8A/","excerpt":"","text":"如果去大厂，但之前在传统行业公司，怕拿不下活，焦虑，该怎么办？不是怕累，是怕拿不下活 如果是针对接不下活，可以先观察，有一种思路可以参考：主动躺平放弃内卷（但需要考虑到年终评绩效时得 3.25 ） 大小周 VS 单休但周六上班不干活 哪边更累呢？ 大小周，最终会收敛于单休 读源码时有的时候忘得快，因为平时用的也少，所以很难有比较深的印象 几个建议： 读前大胆猜测 读时小心求证 读后认真记录总结 不定期回头反思 背所谓的面试八股文吗？ 从来不，没意义，理解的去记最好。 读源码的时候总是因为一些细节想要去了解，深入之后忘掉了整体，如何解决 要么自己记录下深入之前的点，要么借助已有资源帮你记录 一个小 tip ，使用的鼠标最好带拇指侧键，方便读源码时前进后退","categories":[{"name":"闲聊杂记","slug":"闲聊杂记","permalink":"http://yoursite.com/categories/%E9%97%B2%E8%81%8A%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"Spring如何在运行期动态注册新的数据源？","slug":"Spring如何在运行期动态注册新的数据源？","date":"2021-05-08T06:57:23.000Z","updated":"2021-05-08T06:59:59.226Z","comments":true,"path":"2021/05/08/Spring如何在运行期动态注册新的数据源？/","link":"","permalink":"http://yoursite.com/2021/05/08/Spring%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%9F/","excerpt":"","text":"2021 年已经过去 1/3 了，阿熊怎么还不写文章呢？ 哎，不是不写，是一直在更新着新的 MyBatis 小册嘛，正好这段时间处在换工作的阶段，白天除了找找招聘岗位就是写写小册和文章，相对也清闲一点（但是快要饿死了呀 ~ ）。最近在翻底稿的时候找到了一个之前跟小册交流群的群友讨论的话题，感觉这个主题还不错，所以本篇文章，我们就来研究一下本文标题所述的这个话题：SpringFramework 如何在运行期动态注册新的数据源？ 需求来源这个需求的起源是来自一个 SpringBoot 自动装配的数据源注册，因为一个项目中需要注册的数据源不确定，所以需要在启动时根据配置文件的内容动态注册多个数据源。后来聊着聊着，就演变成运行时动态注册新的数据源了。虽然看上去这两个事情好像差不多，但实际上两件事差了很多哈。 启动时动态初始化数据源：在基于 SpringFramework / SpringBoot 的应用初始化，也即 IOC 容器初始化时，读取并解析配置文件，构造多个数据源，并注册到 IOC 容器中 此时通常情况下 IOC 容器还没有刷新完毕，项目还没有启动完成 运行期动态注册新的数据源：在项目的运行期间，动态的构造数据源，并注册到 Spring 的 IOC 容器中 此时项目已经在正常运行中了 前者的处理方式相对比较简单，通过声明一个标注了 @ConfigurationProperties 的类，并用 Map 接收数据源的参数就可以把数据源的定义信息都获取到了： 1@ConfigurationProperties(prefix = \"spring.datasource.dynamic\")2public class DynamicDataSourceProperties &#123;3 4 private Map&lt;String, DataSource&gt; dataSourceMap = new HashMap&lt;&gt;();5 6 // ......7&#125; 然后，再编写一个 ImportBeanDefinitionRegistrar ，读取这个 DynamicDataSourceProperties 的内容，就可以把这些数据源都注册到 IOC 容器中。 但是后者就麻烦了，运行期动态注册新的数据源应该如何实现才行呢？下面我们来通过几个方案，讲解该需求的实现。 编码环境搭建首先，我们先来搭建一下编码环境。 数据库准备首先，我们先来创建 3 个不同的数据库（当然也可以只创建一个数据库，这里我们搞的更真实一点吧）： 1CREATE DATABASE db1;2CREATE DATABASE db2;3CREATE DATABASE db3; 接下来给每一个数据库中都初始化一张相同的表： 1CREATE TABLE tbl_user (2 id int(11) NOT NULL AUTO_INCREMENT,3 name varchar(32) NOT NULL,4 tel varchar(16) NULL,5 PRIMARY KEY (id)6); OK 就这么简单的准备一下就可以了。 初始代码编写为了快速编码，我们仍然采用 SpringBoot 构建项目，直接使用 SpringInitializer 就挺好，当然也可以通过 Maven 构建项目，这里我们就省去那些麻烦的构建步骤了，只把代码贴一下哈。 项目名称：dynamic-register-datasource 。 pom.xml ： 1&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;2&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"3 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"4 xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;5 &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;6 &lt;parent&gt;7 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;8 &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;9 &lt;version&gt;2.2.8.RELEASE&lt;/version&gt;10 &lt;relativePath/&gt;11 &lt;/parent&gt;12 &lt;groupId&gt;com.linkedbear.spring&lt;/groupId&gt;13 &lt;artifactId&gt;dynamic-register-datasource&lt;/artifactId&gt;14 &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;1516 &lt;properties&gt;17 &lt;java.version&gt;1.8&lt;/java.version&gt;18 &lt;/properties&gt;1920 &lt;dependencies&gt;21 &lt;dependency&gt;22 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;23 &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;24 &lt;/dependency&gt;25 &lt;dependency&gt;26 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;27 &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;28 &lt;/dependency&gt;29 &lt;dependency&gt;30 &lt;groupId&gt;mysql&lt;/groupId&gt;31 &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;32 &lt;version&gt;5.1.47&lt;/version&gt;33 &lt;/dependency&gt;34 &lt;/dependencies&gt;3536 &lt;build&gt;37 &lt;plugins&gt;38 &lt;plugin&gt;39 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;40 &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;41 &lt;/plugin&gt;42 &lt;/plugins&gt;43 &lt;/build&gt;44&lt;/project&gt; application.yml ： 1spring:2 datasource:3 db1:4 driver-class-name: com.mysql.jdbc.Driver5 jdbc-url: jdbc:mysql://localhost:3306/db1?characterEncoding=utf8 # 注意这里是jdbc-url而不是url6 username: root7 password: 1234568 db2:9 driver-class-name: com.mysql.jdbc.Driver10 jdbc-url: jdbc:mysql://localhost:3306/db2?characterEncoding=utf811 username: root12 password: 123456 DataSourceConfiguration ： 1@Configuration2public class DataSourceConfiguration &#123;3 4 @Bean5 @Primary6 @ConfigurationProperties(\"spring.datasource.db1\")7 public DataSource db1() &#123;8 return DataSourceBuilder.create().build();9 &#125;10 11 @Bean12 @ConfigurationProperties(\"spring.datasource.db2\")13 public DataSource db2() &#123;14 return DataSourceBuilder.create().build();15 &#125;16&#125; 以上的代码，是我们最常见到的 SpringBoot 中定义多个数据源的方法了是吧。 测试运行一下最后编写 SpringBoot 主启动类，在这里我们将启动完成后的 IOC 容器拿到，并从中取出所有的 DataSource ，取一下它们其中的数据库连接 Connection ： 1@SpringBootApplication2public class DynamicRegisterDataSourceApplication &#123;3 4 public static void main(String[] args) throws Exception &#123;5 ConfigurableApplicationContext ctx = SpringApplication.run(DynamicRegisterDataSourceApplication.class, args);6 Map&lt;String, DataSource&gt; dataSourceMap = ctx.getBeansOfType(DataSource.class);7 for (Map.Entry&lt;String, DataSource&gt; entry : dataSourceMap.entrySet()) &#123;8 String name = entry.getKey();9 DataSource dataSource = entry.getValue();10 System.out.println(name);11 System.out.println(dataSource.getConnection()); // 这里会抛出异常，直接throws走了12 &#125;13 &#125;14&#125; 运行主启动类，可以在控制台中发现我们已经注册好的两个 DataSource ，以及它们对应的 Connection ： 1db122021-01-15 20:43:14.299 INFO 7624 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Starting...32021-01-15 20:43:14.412 INFO 7624 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Start completed.4HikariProxyConnection@65982709 wrapping com.mysql.jdbc.JDBC4Connection@64030b915db262021-01-15 20:43:14.414 INFO 7624 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-2 - Starting...72021-01-15 20:43:14.418 INFO 7624 --- [ main] com.zaxxer.hikari.HikariDataSource : HikariPool-2 - Start completed.8HikariProxyConnection@652007616 wrapping com.mysql.jdbc.JDBC4Connection@66e889df 到这里，基本的环境和代码都就准备好了。 下面，我们来讲解两种程序运行期动态注册数据源的解决方案。 解决方案1：基于BeanDefinition如果各位小伙伴有学习过我 Spring 小册的 IOC 高级部分，应该都知道 bean 的创建来源是 BeanDefinition 吧！通常情况下，我们通过 &lt;bean&gt; 标签、@Bean 注解，或者 @Component 配合 @ComponentScan 注解完成的 bean 注册，都是先封装为一个个的 BeanDefinition ，然后才是根据 BeanDefinition 创建 bean 对象！ 使用 SpringFramework 的 BeanDefinition 元编程，我们可以手动构造一个 BeanDefinition ，并注册到 DefaultListableBeanFactory（ BeanDefinitionRegistry ）中： 1@RestController2public class RegisterDataSourceController implements BeanFactoryAware, ApplicationContextAware &#123;3 4 private DefaultListableBeanFactory beanFactory;56 @GetMapping(\"/register1\")7 public String register1() &#123;8 BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(HikariDataSource.class);9 builder.addPropertyReference(\"driverClassName\", \"com.mysql.jdbc.Driver\");10 builder.addPropertyReference(\"jdbcUrl\", \"jdbc:mysql://localhost:3306/db3?characterEncoding=utf8\");11 builder.addPropertyReference(\"username\", \"root\");12 builder.addPropertyReference(\"password\", \"123456\");13 // builder.setScope(ConfigurableListableBeanFactory.SCOPE_SINGLETON);14 beanFactory.registerBeanDefinition(\"db3\", builder.getBeanDefinition());15 return \"success\";16 &#125;17 18 @GetMapping(\"/getDataSources\")19 public String getDataSources() &#123;20 Map&lt;String, DataSource&gt; dataSourceMap = beanFactory.getBeansOfType(DataSource.class);21 dataSourceMap.forEach((s, dataSource) -&gt; &#123;22 System.out.println(s + \" ======== \" + dataSource);23 &#125;);24 return \"success\";25 &#125;26 27 // ......28&#125; 如果构造的 DataSource 需要指定作用域等额外的配置，可以操纵 BeanDefinitionBuilder 的 API 进行设置。 以此法编写好之后，我们可以重启项目测试一下。重启之后先访问 /getDataSources ，可以发现控制台只有两个 DataSource 的打印： 1db1 ======== HikariDataSource (HikariPool-1)2db2 ======== HikariDataSource (HikariPool-2) 然后访问 /register1 路径，之后再访问 /getDataSources ，控制台就可以打印三个 DataSource 了： 1db1 ======== HikariDataSource (HikariPool-1)2db2 ======== HikariDataSource (HikariPool-2)3db3 ======== HikariDataSource (HikariPool-3) 这种方法比较简单，比较具有通用性，关键的点是抓住核心知识点：BeanFactory 中的 bean 绝大多数都是通过 BeanDefinition 创建而来。 解决方案2：基于SingletonBeanRegistry如果需要注册的 bean 都是单实例 bean ，而且不需要经过 AOP 处理的话，则也可以使用接下来要讲的这种方式，相较于上一种而言，采用这种方法相对会更友好。 如果小伙伴有看过我的 Spring 小册第 14 章 BeanFactory 章节，应该不会忘记 BeanFactory 在 ApplicationContext 中唯一现役的最终实现是 DefaultListableBeanFactory 吧。那这个实现类，最终是继承了 AbstractBeanFactory ，而它又继承了一个叫 DefaultSingletonBeanRegistry 的类，这个类我们在 Spring 小册的正篇中没有提及，现已经补充到小册的加餐内容中了，小伙伴们可以戳链接去学习呀。 简单示例代码我们简单的来说哈，DefaultSingletonBeanRegistry 这个类实现了一个 SingletonBeanRegistry 接口，这个接口中定义了一个方法：registerSingleton ，它可以直接向 IOC 容器注册一个已经完完全全存在的对象，使其成为 IOC 容器中的一个 bean 。 1void registerSingleton(String beanName, Object singletonObject); 又因为 DefaultListableBeanFactory 继承自 DefaultSingletonBeanRegistry ，所以借助这个原理之后，实现这个需求就简单的很了。我们只需要拿到 DefaultListableBeanFactory ，之后调用它的 registerSingleton 方法即可： 1@RestController2public class RegisterDataSourceController implements BeanFactoryAware &#123;3 4 private DefaultListableBeanFactory beanFactory;5 6 @GetMapping(\"/getDataSources\")7 public String getDataSources() &#123;8 Map&lt;String, DataSource&gt; dataSourceMap = beanFactory.getBeansOfType(DataSource.class);9 dataSourceMap.forEach((s, dataSource) -&gt; &#123;10 System.out.println(s + \" ======== \" + dataSource);11 &#125;);12 return \"success\";13 &#125;1415 @GetMapping(\"/register2\")16 public String register2() throws SQLException &#123;17 HikariDataSource dataSource = new HikariDataSource();18 dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");19 dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/db3?characterEncoding=utf8\");20 dataSource.setUsername(\"root\");21 dataSource.setPassword(\"123456\");22 dataSource.getConnection();23 System.out.println(\"db3 创建完成！\");24 beanFactory.registerSingleton(\"db3\", dataSource);25 return \"success\";26 &#125;27 28 @Override29 public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;30 this.beanFactory = (DefaultListableBeanFactory) beanFactory;31 &#125;32&#125; 这样注册好了，IOC 容器中就有这个 db3 的数据源了，我们可以再测试一下。 测试注册效果重启工程，先访问 /getDataSources ，控制台依然是只有两个 DataSource 的打印： 1db1 ======== HikariDataSource (HikariPool-1)2db2 ======== HikariDataSource (HikariPool-2) 然后访问 /register2 路径，控制台可以打印成功 db3 创建完成！ ，此时再访问 /getDataSources 路径，控制台也可以打印三个 DataSource 了： 1db1 ======== HikariDataSource (HikariPool-1)2db2 ======== HikariDataSource (HikariPool-2)3db3 ======== HikariDataSource (HikariPool-3) 依赖注入？上面我们看到的生效，那仅仅是我们拿到 BeanFactory ，或者 ApplicationContext 后主动调用 getBean 系列方法，去获取 IOC 容器的 bean 。但对于那些依赖了 DataSource 的 bean ，这种情况就不好办了：因为依赖注入的时机是 bean 的初始化阶段，当 bean 创建完成后，没有其他代码的干涉，bean 依赖的那些 bean 就不会变化。 听起来有点绕，我们来写一个 Service 类来解释一下。 1@Service2public class DataSourceService &#123;3 4 @Autowired5 Map&lt;String, DataSource&gt; dataSourceMap;6 7 public void printDataSources() &#123;8 dataSourceMap.forEach((s, dataSource) -&gt; &#123;9 System.out.println(s + \" ======== \" + dataSource);10 &#125;);11 &#125;12&#125; 这里我们造了一个 DataSourceService ，并通过注入一整个 Map 的方式，将 IOC 容器中的 DataSource 连带着 bean 的 name 都注入进来。 然后我们修改一下 Controller ，让它取容器中的 DataSourceService ，打印它里面的 DataSource ： 1@GetMapping(\"/getDataSources\")2public String getDataSources() &#123;3 DataSourceService dataSourceService = beanFactory.getBean(DataSourceService.class);4 dataSourceService.printDataSources();5 return \"success\";6&#125; 重启工程，并重复上面的测试效果，这次发现两次打印的结果是一样的： 1db1 ======== HikariDataSource (HikariPool-1)2db2 ======== HikariDataSource (HikariPool-2)3db3 创建完成！4db1 ======== HikariDataSource (HikariPool-1)5db2 ======== HikariDataSource (HikariPool-2) 这个现象就是上面提到的：bean 中依赖注入的属性没有被主动干预，则不会发生变化。 怎么解决这个问题呢？哎，还是靠 BeanFactory 。 在 Spring 小册第 14 章 BeanFactory 的 1.4.2 节中我们讲到了有关 AutowireCapableBeanFactory 的一个作用是框架集成，它提供了一个 autowireBean 方法，用于给现有的对象进行依赖注入： 1void autowireBean(Object existingBean) throws BeansException; 所以我们可以借助这个特性，在动态注册完 DataSource 后，把 IOC 容器中的 DataSourceService 取出来，让它重新执行一次依赖注入即可： 1@GetMapping(\"/register2\")2public String register2() throws SQLException &#123;3 HikariDataSource dataSource = new HikariDataSource();4 dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");5 dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/db3?characterEncoding=utf8\");6 dataSource.setUsername(\"root\");7 dataSource.setPassword(\"123456\");8 dataSource.getConnection();9 System.out.println(\"db3 创建完成！\");10 beanFactory.registerSingleton(\"db3\", dataSource);11 // 重新执行依赖注入12 beanFactory.autowireBean(beanFactory.getBean(DataSourceService.class));13 return \"success\";14&#125; 就这么简单，添加这样一行代码即可。 再测试OK ，重新测试一下效果怎样，重启工程，按照上面的测试过程，先访问 /getDataSources ，再访问 /register2 ，然后重新访问 /getDataSources ，这次控制台打印了 DataSourceService 中的 3 个 DataSource 了： 1db1 ======== HikariDataSource (HikariPool-1)2db2 ======== HikariDataSource (HikariPool-2)3db3 创建完成！4db1 ======== HikariDataSource (HikariPool-1)5db2 ======== HikariDataSource (HikariPool-2)6db3 ======== HikariDataSource (HikariPool-3) 这样依赖注入的问题也就解决了。 不足？虽然上面这样的写法没啥问题，但如果依赖 DataSource 的 bean 太多，那我们一个一个的重新依赖注入，那岂不是太费劲了？有没有更好的方案，能针对某一种特定的 bean 的类型，当 BeanFactory 动态注册该类型的 bean 时，自动刷新 IOC 容器中依赖了该类型 bean 的 bean 。这个想法是否能实现呢？ 优化方案：自定义注解+事件监听比较可惜，使用普通的套路我们无法比较容易的获取到 IOC 容器中哪些 bean 依赖这些 DataSource ，所以我们可以换一个思路：既然依赖这些 DataSource 的 bean 通常都是我们自己编写的（我们自己的业务场景需要呀），所以我们完全可以给这些 bean 上面添加一个自定义的注解。 自定义注解譬如说，我们给上面的代码中，DataSourceService 的上面添加一个 @RefreshDependency 注解： 1@Documented2@Retention(RetentionPolicy.RUNTIME)3@Target(ElementType.TYPE)4public @interface RefreshDependency &#123;5 6&#125; 1@Service2@RefreshDependency3public class DataSourceService &#123;4 5 @Autowired6 Map&lt;String, DataSource&gt; dataSourceMap;7 8 // ......9&#125; 这个注解的作用，就是标识那些需要 BeanFactory 去执行依赖重注入动作的 bean 。 接下来，就是每次动态注册完 bean 后，让 BeanFactory 去寻找这些标有 @RefreshDependency 注解的 bean ，并执行依赖重注入： 1@GetMapping(\"/register3\")2public String register3() throws SQLException &#123;3 HikariDataSource dataSource = new HikariDataSource();4 dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");5 dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/db3?characterEncoding=utf8\");6 dataSource.setUsername(\"root\");7 dataSource.setPassword(\"123456\");8 dataSource.getConnection();9 System.out.println(\"db3 创建完成！\");10 beanFactory.registerSingleton(\"db3\", dataSource);11 12 Map&lt;String, Object&gt; beansMap = beanFactory.getBeansWithAnnotation(RefreshDependency.class);13 beansMap.values().forEach(bean -&gt; beanFactory.autowireBean(bean));14 return \"success\";15&#125; 当然，这两行代码虽然不长，但它毕竟是一个可以抽取的逻辑。如果后续我们的代码中还有别的地方也需要动态注册新的 bean 后通知其它 bean 完成依赖重注入，则相同的代码又要再写一次。 针对这个问题，我们可以继续使用事件驱动的特性来优化。 事件驱动优化既然要用事件驱动，而我们又知道 ApplicationContext 本身也是一个 ApplicationEventPublisher ，它具备发布事件的能力，所以我们这次就不必在 Controller 中注入 BeanFactory 了，而是换用 ApplicationContext ： 1@RestController2public class RegisterDataSourceController implements BeanFactoryAware, ApplicationContextAware &#123;3 4 private ConfigurableApplicationContext ctx;5 6 // ......7 8 @Override9 public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123;10 this.ctx = (ConfigurableApplicationContext) ctx;11 &#125;12&#125; 注意这里要用 ConfigurableApplicationContext 去接收，因为 ApplicationContext 接口并没有继承 SingletonBeanRegistry 接口，ConfigurableApplicationContext 才继承了它。 然后，在注册完 bean 之后，就可以发布一个事件，通过事件机制来触发 bean 的依赖重注入了。我们先来把事件和监听器造出来： 1// 继承自ApplicationContextEvent，则可以直接从事件中获取ApplicationContext2public class DynamicRegisterEvent extends ApplicationContextEvent &#123;3 4 public DynamicRegisterEvent(ApplicationContext source) &#123;5 super(source);6 &#125;7&#125; 1@Component2public class DynamicRegisterListener implements ApplicationListener&lt;DynamicRegisterEvent&gt; &#123;3 4 @Override5 public void onApplicationEvent(DynamicRegisterEvent event) &#123;6 ApplicationContext ctx = event.getApplicationContext();7 AutowireCapableBeanFactory beanFactory = ctx.getAutowireCapableBeanFactory();8 Map&lt;String, Object&gt; beansMap = ctx.getBeansWithAnnotation(RefreshDependency.class);9 beansMap.values().forEach(beanFactory::autowireBean);10 &#125;11&#125; OK ，把监听器注册到 IOC 容器周，接下来再修改 Controller 中的动态注册 bean 的逻辑，让它注册完 bean 后发布 DynamicRegisterEvent 事件： 1@GetMapping(\"/register3\")2public String register3() throws SQLException &#123;3 HikariDataSource dataSource = new HikariDataSource();4 dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");5 dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/db3?characterEncoding=utf8\");6 dataSource.setUsername(\"root\");7 dataSource.setPassword(\"123456\");8 dataSource.getConnection();9 System.out.println(\"db3 创建完成！\");10 ctx.getBeanFactory().registerSingleton(\"db3\", dataSource);11 12 ctx.publishEvent(new DynamicRegisterEvent(ctx));13 return \"success\";14&#125; 这样一切就大功告成了，注册 bean 的逻辑，和依赖重注入的逻辑也都通过事件驱动解耦了。 重新测试一下，浏览器先后访问 /getDataSources 、/register3 、/getDataSources ，控制台依然可以打印 DataSourceService 中的 3 个 DataSource ： 1db1 ======== HikariDataSource (HikariPool-1)2db2 ======== HikariDataSource (HikariPool-2)3db3 创建完成！4db1 ======== HikariDataSource (HikariPool-1)5db2 ======== HikariDataSource (HikariPool-2)6db3 ======== HikariDataSource (HikariPool-3) 说明我们的优化方案是没有问题的。 本文涉及到的所有源码可以从 GitHub 中找到：https://github.com/LinkedBear/juejin-posts-sources 【都看到这里了，小伙伴们要不要关注点赞一下呀，有 Spring 、SpringBoot 、MyBatis 及相关源码学习需要的可以看我的柯基小册四件套哦（对，是四件套了），学习起来 ~ 奥利给】","categories":[{"name":"SpringFramework","slug":"SpringFramework","permalink":"http://yoursite.com/categories/SpringFramework/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"艰难又收获满满的2020","slug":"2020掘金年度征文","date":"2020-12-01T05:57:16.000Z","updated":"2021-02-01T07:32:18.611Z","comments":true,"path":"2020/12/01/2020掘金年度征文/","link":"","permalink":"http://yoursite.com/2020/12/01/2020%E6%8E%98%E9%87%91%E5%B9%B4%E5%BA%A6%E5%BE%81%E6%96%87/","excerpt":"","text":"艰难又收获满满的2020 伙计们，这一年过得都好吗？ 2020 年是很艰难的一年，是不寻常的一年，这一年大家都很难，很多在年初立下的 flag 都因为这场疫情而不得不作出改变，不过话又说回来，疫情的影响又带来了一些新的机遇，不少小伙伴也趁此机会谋求了更好的工作。总的来看，这一年既有挑战，也有机会。借此机会，我也来写一写我的 2020 ，我这一年的经历。 加班加点肝小册之余，与小伙伴们分享这一年的经历，希望小伙伴们能多多给阿熊点赞呀 Ｏ(≧▽≦)Ｏ 期待与小伙伴的交流。 小册写作如果你要问我这一年最大的精力都放在哪里，那毫无疑问是掘金的两本小册了。继 2019 年 11 月 《SpringBoot 源码解读与原理分析》小册发布之后，2020 年 6 月，第二本小册《SpringCloudNetflix 源码解读与原理分析》，以及 9 月的第三本小册《从 0 开始深入学习 Spring 》也都陆续发布，而且目前 Spring 小册还在继续连载更新中。 回想 19 年的那个秋天，当时写第一本小册的动机，可能还是单纯的觉得，完成一本成体系的、有深度的付费读物，就已经是一个不错的目标了。直到今年第二本小册，也就是 SpringCloudNetflix 的小册发布之后，越来越多的小伙伴反映没有 SpringFramework 的坚实的基础，阅读源码和原理级别的东西真的蛮吃力，我就下定决心，准备在下半年策划写一本回归 SpringFramework 基础到深入的小册。这时的我已经不再是单纯的为了写作而写作了，更多的是抱着如何能让更多的小伙伴，能更容易、更完整、更深入、成体系的学习一个框架技术，而且尽可能的让小伙伴能追根溯源的了解技术的演变，以及最终在实际开发中的落地，最后才是深入底层、剖析原理。 我想，以这种思路与大家分享技术，应该会学起来更加轻松吧。果不其然，在 Spring 小册发布后的不到一周，在第三章 入门-IOC是怎么来的 的底部就已经得到了大量的积极反馈，而且还有不少小伙伴主动地在下面分享自己的思考和总结，整个氛围都非常的积极。由此我也更加坚定了这个思路，之后的文章更新也是完全按照从基础，到进阶，再到高级，最后深入原理底层，尽可能地既覆盖足够大的广度，又能让小伙伴们学到足够的深度。目前来看，IOC 和 AOP 的内容也都全部更新完毕了，在计划中，12 月 31 日之前，Spring 小册的所有正篇内容都会如期更新完毕。 当然，Spring 的小册也不会因为正篇更新完毕而完结，通过这几个月与小册交流群里的小伙伴沟通交流，发现有一些知识点或者问题，对于部分小伙伴来讲还是蛮有兴趣或者存在疑惑的，所以我打算在正篇更新完毕后，会根据小伙伴的反馈，在小册的最后追加几篇加餐内容，以尽可能多的帮助到小伙伴，解答你们的疑惑，拓宽大家的知识范围。 B站直播2020 年 10 月 15 日，有幸受掘金官方的邀请，本人在 B 站以掘金技术社区的主讲人身份，跟小伙伴们分享了一些有关 Spring 方面的技术和学习思路，包括一些常见的 Spring 相关的面试题。这也是我本人第一次参与线上的直播技术分享，总的来说还算挺成功的，小伙伴们反响也不错，小册姐也有夸，说到底还是很荣幸参与的啦。 当时直播的时候人还蛮多的，不少买过我小册的小伙伴都去捧场了，还有几位在小册交流群的小伙伴抽到了掘金官方的缸子、保温杯等周边，我也只能表示实名羡慕啦 o(￣▽￣)ｄ 。如果小伙伴对那一次的直播还蛮有兴趣，或者当时没有来得及上车，可以戳链接去看直播回放： Spring漫漫深耕路 - 记在掘金的第一次直播 。 当然，这一次直播并不是终点，我自己也在策划着如何更近距离、更有效的与小伙伴们沟通交流，之前也有考虑设计过，针对小册的某些复杂或者困难的章节辅以直播 / 视频讲解，这些设想我一直都有保留，只不过当下最重要的，是把 Spring 的小册更新完结，明年吧，明年一定会把这些设想都落实到位的，小伙伴们等我 ~ 社区日常除了上班时间之外，我的空余时间大部分都放在技术研究，和小册的写作上了。当然这其中少不了我与读者伙伴们的沟通交流。就目前而言，比较活跃的群有 SpringBoot 的群，和两个 Spring 小册的群，我也经常出没在这两个群里。（对，我一点也不高冷 ~ ） 日常情况我都会没事点开群里看看小伙伴们都在聊什么，感兴趣的还会掺和两句进去；当然，要是遇到有小伙伴问 Spring 相关的问题，我都会尽可能快速及时的响应并给予解答。这里面不乏有一些跟我聊得很熟的小伙伴：琛羽千遇 、Mtc 、皮皮柒 、唯有大骨熬成汤 、南岩 、Seirios 、Y 、小橙子 、阿甘 ，等等等等（人太多了没办法在短时间一一喊出各位的名字），他们都是本身小册学习就特别积极，也特别优秀，而且在群里也是超级活跃的，我很荣幸能有你们这些优秀的读者伙伴，当然支持小册的小伙伴都是很优秀的伙伴啦 ヽ(￣▽￣)ﾉ ，感谢你们对阿熊的支持和认可，阿熊也会一如既往用高质量的知识分享陪伴大家的。 展望2021最后再聊一下明年的计划吧，照目前看来，2021 年的安排主要以写作为主，直播 / 视频为辅。 写作今年小册完结之后，明年暂时没有新小册开坑的计划，而是考虑将 《SpringBoot 源码解读与原理分析》重新整理并发行实体书。经过一年多的时间考验，以及在小册交流群里与小伙伴们的交流，我大概清楚了深入学习 SpringBoot 深层次原理的思路，并且会将这些思路，加上目前 Spring 小册中的部分核心知识，重新整合进接下来要写的实体书中，相信接下来新出的 SpringBoot 原理分析实体书会帮助小伙伴们更好地理解、学习 SpringBoot 、SpringFramework 中的核心知识点，以及它们的特性。小伙伴们敬请期待吧！ 直播/视频前面也说了，现在的三本小册中肯定存在一些小伙伴们比较难理解的、讨论度高的问题，我会把这些问题收集好，单独摘出来，以直播 Q&amp;A 或者视频讲解的方式来解答这些问题，至于承载的媒介，我暂时还没想好用哪些平台，小伙伴们也可以多多给我提建议呀！期待能与小伙伴的交流！ 总结2020 是艰难的，但也是收获满满的，我收获了小册的产出和反馈，更收获了支持小册支持阿熊的你们。2021 ，阿熊会继续前行，同小伙伴们一起进步一起成长。 相信未来美好的事情即将发生，相信一切都会变得更好，你也是。","categories":[{"name":"掘金日记","slug":"掘金日记","permalink":"http://yoursite.com/categories/%E6%8E%98%E9%87%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"2020","slug":"2020","permalink":"http://yoursite.com/tags/2020/"}]},{"title":"记【在掘金的第一次直播】","slug":"记【在掘金的第一次直播】","date":"2020-10-18T00:30:00.000Z","updated":"2020-10-31T09:29:12.971Z","comments":true,"path":"2020/10/18/记【在掘金的第一次直播】/","link":"","permalink":"http://yoursite.com/2020/10/18/%E8%AE%B0%E3%80%90%E5%9C%A8%E6%8E%98%E9%87%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B4%E6%92%AD%E3%80%91/","excerpt":"","text":"2020年10月15日，本人有幸参与了掘金技术社区的一次直播活动，作为主讲人与小伙伴们分享了一些关于 Spring 方面的内容。这次分享的内容以概述为主，主要帮小伙伴们理清楚学习 Spring 的思路，以及学完 Spring 框架之后的进一步规划。 写这篇文章，主要是记录一下当天分享的内容，以及一些后续的复盘等等，帮助没有赶上车的小伙伴们。 【B站直播回放：https://www.bilibili.com/video/BV13i4y177ZW】 Java开发生态中，Spring究竟有多重要既然是聊 Spring ，那咱还是要知道它的地位和分量。Spring 的地位想必都已经到 2020 年了，小伙伴们都非常的清楚。 Spring使Java变得简单在 Spring 的官方网站 https://spring.io 中，一上来我们看到的就是 Spring 官方对 Spring 的描述： Spring makes Java simple.modern.productive.reactive.cloud-ready. Spring 使 Java 开发变得简单、现代化，并且可以编写生产级别的应用、响应式的应用，并且也支持云应用。 包括下面主页上也列出了 Spring 可以做的内容： 可见，Spring 代表的不仅仅是一个框架 / 一个技术，而是一整个生态。 Spring是一个生态翻开 Spring 官网的工程概览 https://spring.io/projects ，我们会发现里面的工程实在是好多好多呀！ 最顶部的两个代表之作，分别是现阶段最最流行的后端服务搭建基本框架 SpringBoot ，以及它的基底 SpringFramework ： 往下看，还有关于数据访问层的 SpringData 、用于解决微服务开发的整体解决方案 SpringCloud 、用于解决权限安全方面的 SpringSecurity 、用于解决 Session 外置的 SpringSession 等等，这些都是 Spring 生态中的一个个解决方案。 Spring的使用范围极广如果只是人家官方自己吹，那说服力很明显不是很足，咱看看主流的比较受欢迎的开源项目，它们都用了什么底层框架。 翻开码云的开源项目 https://gitee.com/explore/backend?lang=Java ，观察这些比较受欢迎的后台管理系统都是用什么搭建的： 可见这些开源项目都是基于 Spring / SpringBoot 搭建的！这足够有说服力了吧，连这些主流的、受欢迎的项目都是用 Spring 搭建的，那就足以说明 Spring 真的足够的强大了。 Spring是面试常客最后一个点是关于面试，一直以来面试中就容易问到 Spring 这个框架，而且近年来难度有上升趋势，小伙伴们看以下几个问题都能回答多少呢： 如何理解 Spring 中的 IOC ？ Bean 的生命周期包括哪些阶段？ Spring 如何处理循环依赖？ Spring 的事务在什么情况下会失效？ DispatcherServlet 的工作流程？ 这些问题，在 Spring 的小册，以及 SpringBoot 的小册中，都有相应的解答，小册总结的面试题很多，如果小伙伴们有在准备面试的话，小册会是你备战的一个坚实的依靠。 如何才能全方面的掌握Spring那既然 Spring 如此的重要，我们应该如何全方面的去学习、掌握 Spring 这个框架呢？ 简单的来讲，我们可以分为 4 个部分来学习： IOCIOC 的部分是整个 Spring 框架最强大，同时也是最复杂的部分，这里面包含的知识点实在是太多了，咱可以简单地罗列一下： IOC 的思想及实现方式 IOC 的两种实现方式分别是依赖查找、依赖注入 如何实现依赖查找、依赖注入，都有哪些编码实现的方式 Bean 的注册、创建、装配等 Bean 的类型、作用域 Bean 的创建方式、装配方式 组件扫描 Bean 与 BeanDefinition Bean 的定义是如何设计的 BeanDefinition 如何与 IOC 容器配合创建 bean 实例 事件驱动、资源管理、后置处理器 Bean 、IOC 容器的生命周期 …… 这些知识点，在 《从 0 开始深入学习 Spring》的小册中，全部都会讲到，而且难度都是逐层递进的，包括其中涉及到的面试题总结等等。 AOP&amp;事务Spring 的两大核心，除了 IOC 之外，另外一个就是 AOP 了。咱都知道 AOP 的核心底层实现是动态代理，那它是怎么实现的，如何编写 AOP 的切面；以及 Spring 中对于 AOP 的一个实现：事务管理，它又是怎么使用的，如何编程式 / 声明式 / 配置式的添加事务，以及它的底层如何实现事务控制，这都是在 AOP 和事务部分要学习的。 这个部分的内容大概可以划分为如下内容： AOP 与动态代理 jdk / Cglib AOP 的实现、应用 日志打印 权限拦截 事务管理 编程式 / 声明式 / 配置式添加事务 事务传播行为 AOP &amp; 事务控制底层核心 AOP 如何创建代理对象 事务管理器如何控制开启 / 提交 / 回滚事务 Web大多数人都喜欢把 Spring 跟 SpringMVC 分开来说，但确切的说，SpringMVC 是 Spring 框架的一部分，并且自打 Spring 5 出现之后，SpringMVC 多了一个孪生兄弟 SpringWebFlux ，所以 SpringMVC 也被称为 SpringWebMvc 了。 同样的，Web 模块中 Spring 也是重拳出击，这部分内容主要围绕以下的一些关键知识点来学习： Spring 整合 Web 工程 SpringWebMvc 控制器的编写与使用 参数绑定 数据校验 国际化 拦截器 WebMvc 中的核心组件工作机制、流程、原理 DispatcherServlet HandlerMapping HandlerAdapter ViewResolver …… SpringWebFlux 因为用的人还很少，而且理解的难度相对很大，所以这里我们只是提一下，如果小伙伴已经熟练掌握了 SpringWebMvc ，那可以试着学习一下 WebFlux 的东西。 整合如果只是因为 Spring 这个框架本身强大的话，还不足以在整个 JavaWeb 的开发界独占鳌头，它优秀且强大的整合第三方技术的能力绝对是不可或缺的一部分。通常来讲我们接触的比较多的、比较知名的技术，几乎都与 Spring 框架进行了整合。 这里面不乏包含咱熟悉的技术： 数据持久层框架：MyBatis 、Hibernate 缓存中间件：Redis 、MongoDB 消息中间件：RabbitMQ 、Kafka 搜索引擎：ElasticSearch 、Solr …… 学习这些技术的时候，一定要记得顺便学习它与 Spring 的整合。 学习的思路对于 Spring 框架的学习，作者可以提供两种思路： 水平式学习 第一阶段 先学习 Spring 中 IOC 部分相关的基础内容 包括 IOC 的实现方式，依赖注入的方式 Bean 的类型、作用域、创建方式、生命周期控制等等 然后学习 AOP 部分的基础内容 复习一下动态代理 学习 xml / 注解的方式编写 AOP 的切面等等 接下来是事务部分的基础 Spring 如何整合 jdbc JdbcTemplate 的使用 如何使用编程式事务、声明式事务 最后学习 SpringWebMvc 的一些基础 包括控制器的编写、参数绑定、响应 json 、拦截器等等 等这些基础部分学习完毕后，基本上 Spring 的基础知识你就都掌握了，这些知识可以应对大部分的实际编码场景 后续阶段 依次学习 IOC 、AOP 、事务 、Web 等模块的进阶、高级知识 这种层层递进的方式，可以称其为 “水平式学习” 垂直式学习 第一阶段 还是先学习 IOC 相关的基础知识 IOC 的实现方式，依赖注入的方式 Bean 的类型、作用域、创建方式、生命周期控制等等 然后，继续学习 IOC 部分的进阶知识 包括 IOC 容器的设计、思想 Bean 的装配、组件扫描 事件驱动 资源管理、资源文件等等 接下来继续学习 IOC 部分的高级内容 Bean 、BeanDefinition BeanFactory 、BeanDefinitionRegistry 后置处理器 深入底层等 这个阶段学习完成之后，可以说，整个 Spring 的 IOC 模块核心知识点，你基本上已经全部掌握了 后续阶段 按照这个顺序继续学习 AOP 、事务 、Web 模块的各个层级的知识 这种分模块学习，每个模块都是由浅入深的学习思路，可以称其为 “垂直式学习” 两种方法思路任选其一，根据自己的学习风格、思维和习惯来就好。 不止是学习 Spring ，学习其它框架 / 技术时，这两种思路同样适用。 掌握Spring之后如何作中长期规划Spring 框架学习完毕之后，接下来的规划也是至关重要的。明确自己目前所处的位置，并针对自己的情况制定中长期的规划，对自己的整个职业生涯的重要性不言而喻。作者在此也只是提一些导向性的建议，帮助小伙伴们理清自己。 如果 Spring 是你的第一个学习的框架 / 刚学完 SSM 那么接下来你最好先停下来，把这部分的知识巩固住，并且找一个实际的项目 / 需求做一下，体会一下项目开发的感觉，顺便这个期间你的基础知识也就能得到巩固了 如果 Spring 框架本身已经掌握的不错了 后续的计划可以围绕着 Spring 的生态展开，SpringBoot 是一个非常好的选择，因为 SpringBoot 是完全构建于 Spring 框架之上，它充分利用了 Spring 底层设计的机制，也扩展了一些新的机制（如自动装配、新的后置处理器等） 如果 Spring 和 SpringBoot 都基本掌握了 那么中长期的规划可以从两种路线出发 要么，继续进攻 SpringCloud 微服务解决方案，了解和实践微服务开发 要么，研究学习主流的开源中间件（Redis 、RabbitMQ 、ElasticSearch 等），扩充技术栈的广度 Q&amp;A还没毕业的同学，实习之前需要掌握SpringCloud吗回答：不需要。 原因：对于初入职场的小伙伴，公司更看重的是你的基本功，基本功扎实，想必可塑性都不会差。所以，尽可能的让你的基础知识掌握得更牢靠吧（JavaSE 、JavaWeb 、基本的框架等）。 AOP在哪些场景下会失效回答：一般发生在后置处理器的初始化阶段。 原理：可参照小册第 34 章和第 48 章（后续更新）。 JavaSE的源码阅读起来有些吃力，有什么好办法吗回答：可参考开源项目 learningjdk 。 https://github.com/kangjianwei/LearningJDK 学习SpringBoot和Cloud之前需要先学习Servlet吗回答：必须的。 原因：兄dei，如果你连 HttpServletRequest 和 HttpServletResponse 都搞不明白，学 SpringBoot 开发 Web 场景的功能时，岂不就直接废了？Servlet 方面的知识是 JavaWeb 的基础，SpringWebMvc 是构建在 JavaWeb 之上的，SpringBoot 又是整合 SpringWebMvc 的，所以按照这个依赖关系，Servlet 当然是一个必学项啦，而且是基础的必学项。 框架的高级知识如何能记得更牢靠回答：多写多用多练。 小伙伴们扪心自问一下，你一开始学习那些框架、知识等等的，发现有这样那样的高级知识，你学会了，哇塞我牛X了，我直接芜湖起飞了！可是，你真的有在实际场景下用过吗？对于咱搞开发的来讲，知识不是学了就能记住的，一定要多加练习，这个学习没有捷径，你看到的熟练都是背后有大量付出的。 写在最后初次参与直播分享，前期准备的也比较有限，难免会出现有些地方的疏漏、或者交流不充分不到位的地方，敬请小伙伴们海涵和指正。小伙伴们可以通过加入掘金直播分享群找到我，或者通过邮箱 LinkedBear@163.com 与我联系。后续有机会的话，我也会继续参加咱掘金的直播，继续与各位小伙伴作有关 Spring 及生态相关的技术分享和交流。 最后，感谢各位小伙伴的捧场，也感谢掘金官方工作人员的辛勤付出，各位都辛苦啦！","categories":[{"name":"掘金日记","slug":"掘金日记","permalink":"http://yoursite.com/categories/%E6%8E%98%E9%87%91%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"【不懂就问】MyBatis的一级缓存竟然还会引来麻烦？","slug":"【不懂就问】MyBatis的一级缓存竟然还会引来麻烦？","date":"2020-06-28T11:48:16.000Z","updated":"2020-06-28T11:49:08.025Z","comments":true,"path":"2020/06/28/【不懂就问】MyBatis的一级缓存竟然还会引来麻烦？/","link":"","permalink":"http://yoursite.com/2020/06/28/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91MyBatis%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AB%9F%E7%84%B6%E8%BF%98%E4%BC%9A%E5%BC%95%E6%9D%A5%E9%BA%BB%E7%83%A6%EF%BC%9F/","excerpt":"","text":"【“不懂就问”，是一个新的系列，主要整理我的小册群里遇到的一些比较有意思的 / 有难度的 / 容易被讨论起来的问题，并给出问题的解析和方案等等。喜欢的小伙伴们可以点赞关注我鸭 ~ ~ 学习源码可以看看我的小册 ~ ~】 端午假期相信不少小伙伴都在偷偷学习吧（说好了放假一起玩耍呢，结果又背着我学习），这不，刚过了端午，我的一个沙雕程序猿圈子里就有人讨论起来问题了，这个问题聊起来好像挺麻烦，但实际上问题是很简单的，下面咱来讨论下这个问题。 原问题MyBatis 一级缓存与 SpringFramework 的声明式事务有冲突吗？在 Service 中开启事务，连续查询两次同样的数据，结果两次查询的结果不一致。 —— 使用 Mapper 的 selectById 查出来实体，然后修改实体的属性值，然后再 selectById 一下查出来实体，对比一下之前查出来的，发现查出来的是刚才修改过的实体，不是从数据库查出来的。 —— 如果不开启事务，则两次请求查询的结果是相同的，控制台打印了两次 SQL 。 初步分析讲道理，看到这个问题，我一下子就猜到是 MyBatis 一级缓存重复读取的问题了。 MyBatis 的一级缓存默认开启，属于 SqlSession 作用范围。在事务开启的期间，同样的数据库查询请求只会查询一次数据库，之后重复查询会从一级缓存中获取。当不开启事务时，同样的多次数据库查询都会发送数据库请求。 上面的都属于基础知识了，不多解释。重点是，他修改的实体是直接从 MyBatis 的一级缓存中查询出来的。咱都知道，查询出来的这些实体肯定属于对象，拿到的是对象的引用，咱在 Service 里修改了，一级缓存中相应的也就会被影响。由此可见，这个问题的核心原因也就很容易找到了。 问题复现为了展示这个问题，咱还是简单复现一下场景吧。 工程搭建咱使用 SpringBoot + mybatis-spring-boot-starter 快速构建出工程，此处 SpringBoot 版本为 2.2.8 ，mybatis-spring-boot-starter 的版本为 2.1.2 。 pom核心的 pom 依赖有 3 个： 1&lt;dependency&gt;2 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;3 &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;4&lt;/dependency&gt;56&lt;dependency&gt;7 &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;8 &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;9 &lt;version&gt;2.1.2&lt;/version&gt;10&lt;/dependency&gt;1112&lt;dependency&gt;13 &lt;groupId&gt;com.h2database&lt;/groupId&gt;14 &lt;artifactId&gt;h2&lt;/artifactId&gt;15 &lt;version&gt;1.4.199&lt;/version&gt;16&lt;/dependency&gt; 数据库配置数据库咱们依然选用 h2 作为快速问题复现的数据库，只需要在 application.properties 中添加如下配置，即可初始化一个 h2 数据库。顺便的，咱把 MyBatis 的配置也简单配置好： 1spring.datasource.driver-class-name=org.h2.Driver2spring.datasource.url=jdbc:h2:mem:mybatis-transaction-cache3spring.datasource.username=sa4spring.datasource.password=sa5spring.datasource.platform=h267spring.datasource.schema=classpath:sql/schema.sql8spring.datasource.data=classpath:sql/data.sql910spring.h2.console.settings.web-allow-others=true11spring.h2.console.path=/h212spring.h2.console.enabled=true1314mybatis.type-aliases-package=com.linkedbear.demo.entity15mybatis.mapper-locations=classpath:mapper/*.xml 初始化数据库上面咱使用了 datasource 的 schema 和 data 初始化数据库，那自然的就应该有这两个 .sql 文件。 schema.sql ： 1create table if not exists sys_department (2 id varchar(32) not null primary key,3 name varchar(32) not null4); data.sql ： 1insert into sys_department (id, name) values ('idaaa', 'testaaa');2insert into sys_department (id, name) values ('idbbb', 'testbbb');3insert into sys_department (id, name) values ('idccc', 'testccc');4insert into sys_department (id, name) values ('idddd', 'testddd'); 编写测试代码咱使用一个最简单的单表模型，快速复现场景。 entity新建一个 Department 类，并声明 id 和 name 属性： 1public class Department &#123;2 3 private String id;4 private String name;5 6 // getter setter toString ......7&#125; mapperMyBatis 的接口动态代理方式可以快速声明查询的 statement ，咱只需要声明一个 findById 即可： 1@Mapper2public interface DepartmentMapper &#123;3 Department findById(String id);4&#125; mapper.xml对应的，接口需要 xml 作为照应：（此处并没有使用注解式 Mapper ） 1&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;2&lt;!DOCTYPE mapper3 PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"4 \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;5&lt;mapper namespace=\"com.linkedbear.demo.mapper.DepartmentMapper\"&gt;6 &lt;select id=\"findById\" parameterType=\"string\" resultType=\"department\"&gt;7 select * from sys_department where id = #&#123;id&#125;8 &lt;/select&gt;9&lt;/mapper&gt; serviceService 中注入 Mapper ，并编写一个需要事务的 update 方法，模拟更新动作： 1@Service2public class DepartmentService &#123;3 4 @Autowired5 DepartmentMapper departmentMapper;6 7 @Transactional(rollbackFor = Exception.class)8 public Department update(Department department) &#123;9 Department temp = departmentMapper.findById(department.getId());10 temp.setName(department.getName());11 Department temp2 = departmentMapper.findById(department.getId());12 System.out.println(\"两次查询的结果是否是同一个对象：\" + temp == temp2);13 return temp;14 &#125;15&#125; controllerController 中注入 Service ，并调用 Service 的 update 方法来触发测试： 1@RestController2public class DepartmentController &#123;3 4 @Autowired5 DepartmentService departmentService;6 7 @GetMapping(\"/department/&#123;id&#125;\")8 public Department findById(@PathVariable(\"id\") String id) &#123;9 Department department = new Department();10 department.setId(id);11 department.setName(UUID.randomUUID().toString().replaceAll(\"-\", \"\"));12 return departmentService.update(department);13 &#125;14&#125; 主启动类主启动类中不需要什么特别的内容，只需要记得开启事务就好： 1@EnableTransactionManagement2@SpringBootApplication3public class MyBatisTransactionCacheApplication &#123;4 5 public static void main(String[] args) &#123;6 SpringApplication.run(MyBatisTransactionCacheApplication.class, args);7 &#125;8&#125; 运行测试以 Debug 方式运行 SpringBoot 的主启动类，在浏览器中输入 http://localhost:8080/h2 输入刚才在 application.properties 中声明的配置，即可打开 h2 数据库的管理台。 执行 SELECT * FROM SYS_DEPARTMENT ，可以发现数据已经成功初始化了： 下面测试效果，在浏览器中输入 http://localhost:8080/department/idaaa ，控制台中打印的结果为 true ，证明 MyBatis 的一级缓存生效，两次查询最终得到的实体类对象一致。 解决方案对于这个问题的解决方案，其实说白了，就是关闭一级缓存。最常见的几种方案列举一下： 全局关闭：设置 mybatis.configuration.local-cache-scope=statement 指定 mapper 关闭：在 mapper.xml 的指定 statement 上标注 flushCache=&quot;true&quot; 另类的办法：在 statement 的 SQL 上添加一串随机数（过于非主流。。。） select * from sys_department where #{random} = #{random} 原理扩展其实到这里，问题就已经解决了，但先不要着急，思考一个问题：为什么声明了 local-cache-scope 为 statement ，或者mapper 的 statement 标签中设置 flushCache=true ，一级缓存就被禁用了呢？下面咱来了解下这背后的原理。 一级缓存失效的原理在 DepartmentService 中，执行 mapper.findById 的动作，最终会进入到 DefaultSqlSession 的 selectOne 中： 1public &lt;T&gt; T selectOne(String statement) &#123;2 return this.selectOne(statement, null);3&#125;45@Override6public &lt;T&gt; T selectOne(String statement, Object parameter) &#123;7 // Popular vote was to return null on 0 results and throw exception on too many.8 List&lt;T&gt; list = this.selectList(statement, parameter);9 if (list.size() == 1) &#123;10 return list.get(0);11 &#125; else if (list.size() &gt; 1) &#123;12 throw new TooManyResultsException(\"Expected one result (or null) to be returned by selectOne(), but found: \" + list.size());13 &#125; else &#123;14 return null;15 &#125;16&#125; 可见 selectOne 的底层是调用的 selectList ，之后 get(0) 取出第一条数据返回。 selectList 的底层会有两个步骤：获取 MappedStatement → 执行查询，如下代码中的 try 部分： 1public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123;2 try &#123;3 MappedStatement ms = configuration.getMappedStatement(statement);4 return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);5 &#125; catch (Exception e) &#123;6 throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e);7 &#125; finally &#123;8 ErrorContext.instance().reset();9 &#125;10&#125; 执行 query 方法，来到 BaseExecutor 中，它会执行三个步骤：获取预编译的 SQL → 创建缓存键 → 真正查询。 1public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, 2 RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123;3 BoundSql boundSql = ms.getBoundSql(parameter);4 CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);5 return query(ms, parameter, rowBounds, resultHandler, key, boundSql);6&#125; 这里面的缓存键是有一定设计的，它的结构可以简单的看成 “ statementId + SQL + 参数 ” 的形式，根据这三个要素，就可以唯一的确定出一个查询结果。 到了这里面的 query 方法，它就带着这个缓存键，执行真正的查询动作了，如下面的这段长源码：（注意看源码中的注释） 1public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, 2 ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;3 ErrorContext.instance().resource(ms.getResource()).activity(\"executing a query\").object(ms.getId());4 if (closed) &#123;5 throw new ExecutorException(\"Executor was closed.\");6 &#125;7 // 如果statement有设置flushCache=\"true\"，则查询之前先清理一级缓存8 if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;9 clearLocalCache();10 &#125;11 List&lt;E&gt; list;12 try &#123;13 queryStack++;14 // 先检查一级缓存15 list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;16 if (list != null) &#123;17 // 如果一级缓存中有，则直接取出18 handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);19 &#125; else &#123;20 // 一级缓存没有，则查询数据库21 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);22 &#125;23 &#125; finally &#123;24 queryStack--;25 &#125;26 if (queryStack == 0) &#123;27 for (DeferredLoad deferredLoad : deferredLoads) &#123;28 deferredLoad.load();29 &#125;30 // issue #60131 deferredLoads.clear();32 // 如果全局配置中有设置local-cache-scope=statement，则清除一级缓存33 if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;34 // issue #48235 clearLocalCache();36 &#125;37 &#125;38 return list;39&#125; 上面的注释中，可以发现，只要上面的三个解决方案，任选一个配置，则一级缓存就会失效，分别分析下： 全局设置 local-cache-scope=statement ，则查询之后即便放入了一级缓存，但存放完立马就给清了，下一次还是要查数据库； statement 设置 flushCache=&quot;true&quot; ，则查询之前先清空一级缓存，还是得查数据库； 设置随机数，如果随机数的上限足够大，那随机到相同数的概率就足够低，也能类似的看成不同的数据库请求，那缓存的 key 都不一样，自然就不会匹配到缓存。 本文涉及到的所有源码可以从 GitHub 中找到：github.com/LinkedBear/juejin-posts-sources 【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】","categories":[{"name":"不懂就问","slug":"不懂就问","permalink":"http://yoursite.com/categories/%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"一级缓存","slug":"一级缓存","permalink":"http://yoursite.com/tags/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98/"},{"name":"声明式事务","slug":"声明式事务","permalink":"http://yoursite.com/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"}]},{"title":"【不懂就问】SpringFramework中的注解声明式事务怎么被Shiro搞失效了","slug":"【不懂就问】SpringFramework中的注解声明式事务怎么被Shiro搞失效了","date":"2020-06-24T05:30:16.000Z","updated":"2020-06-28T07:06:05.100Z","comments":true,"path":"2020/06/24/【不懂就问】SpringFramework中的注解声明式事务怎么被Shiro搞失效了/","link":"","permalink":"http://yoursite.com/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/","excerpt":"","text":"【“不懂就问”，是一个新的系列，主要整理我的小册群里遇到的一些比较有意思的 / 有难度的 / 容易被讨论起来的问题，并给出问题的解析和方案等等。喜欢的小伙伴们可以点赞关注我鸭 ~ ~ 学习源码可以看看我的小册 ~ ~】 近期我在 SpringBoot 的小册交流群里碰见一个问题，感觉蛮有意思的，拿出来跟小伙伴们分享一下。 原问题那位小伙伴的项目中，有一部分 Service 的注解事务一直不起作用，但也只是一部分起作用，也有一部分是好的。而且更奇怪的是，如果他把一个事务不起作用的 ServiceImpl 代码完整的抄一遍到新的复制类里头，那个类居然是有事务的！ 初步分析咱回想一下，按常理来讲，SpringFramework 中的事务不生效，大概有这么几种情况： @Transactional 注解标注在非 public 方法上 @Transactional 注解标注在接口上，但实现类使用 Cglib 代理 @Transactional 注解标注抛出 Exception ，默认不捕捉 service 方法中自行 try-catch 了异常但没有再抛出 RuntimeException 原生 SSM 开发中，父子容器一起包扫描，会导致子容器先扫描到 service 并注册到子容器中但不加载事务，之后虽然父容器也扫描到 service 但因为子容器中的 controller 已经注入了没有事务代理的 service ，会导致事务失效 声明式事务的配置必须由父 IOC 容器加载，SpringWebMvc 的子 IOC 容器加载不生效 除此之外，如果使用的关系型数据库是 MySQL ，还要关注是否为 InnoDB 引擎（ MyISAM 不支持事务）。 结果小伙伴一通分析，发现这上面罗列的情况都没有出现，排查难度进一步加大。 新的关注点隔了大概半天吧，那位小伙伴突然发现了一点问题：他们的项目使用了 Shiro 作为权限校验框架，而且那些事务失效的 Service 刚好就是被 Shiro 中自定义 Realm 依赖的 Service ！有了这个线索，下面排查起来就容易一些了。 问题复现咱也自己搞一套，看看是不是像他说的那样吧！ 工程搭建为了快速复现这个问题，咱使用 SpringBoot + shiro-spring-boot-web-starter 构建。( SpringBoot 版本只要在 2.x 就可以，本文测试功能选用 2.2.8 ) pom关键的依赖有下面 4 个： 1&lt;dependency&gt;2 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;3 &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;4&lt;/dependency&gt;56&lt;dependency&gt;7 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;8 &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;9&lt;/dependency&gt;10&lt;dependency&gt;11 &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;12 &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt;13 &lt;version&gt;1.5.3&lt;/version&gt;14&lt;/dependency&gt;1516&lt;dependency&gt;17 &lt;groupId&gt;com.h2database&lt;/groupId&gt;18 &lt;artifactId&gt;h2&lt;/artifactId&gt;19 &lt;version&gt;1.4.199&lt;/version&gt;20&lt;/dependency&gt; RealmShiro 的自定义策略核心就是 Realm ，咱也不整那些花里胡哨的，直接糊弄下算了。 1public class CustomRealm extends AuthorizingRealm &#123;2 3 @Override4 protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;5 if (token.getPrincipal() == null) &#123;6 return null;7 &#125;8 String name = token.getPrincipal().toString();9 // 请求数据库查询是否存在用户，这里省略10 return new SimpleAuthenticationInfo(name, \"123456\", getName());11 &#125;12 13 @Override14 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;15 SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();16 // 请求数据库/缓存加载用户的权限，这里暂时使用一组假数据17 authorizationInfo.addStringPermissions(Arrays.asList(\"aa\", \"bb\", \"cc\"));18 return authorizationInfo;19 &#125;20&#125; 配置类只声明 Realm 还不够，需要定义几个 Bean 来补充必需的组件才行。 1@Configuration2public class ShiroConfiguration &#123;3 4 // 自定义Realm注册5 @Bean6 public CustomRealm authorizer() &#123;7 return new CustomRealm();8 &#125;9 10 // 动态代理创建器（上面没有导入AOP）11 @Bean12 public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() &#123;13 DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();14 advisorAutoProxyCreator.setProxyTargetClass(true);15 return advisorAutoProxyCreator;16 &#125;17 18 // 过滤器定义，此处选择全部放行，方便调试19 @Bean20 public ShiroFilterChainDefinition filterChainDefinition() &#123;21 DefaultShiroFilterChainDefinition filterChainDefinition = new DefaultShiroFilterChainDefinition();22 filterChainDefinition.addPathDefinition(\"/**\", \"anon\");23 return filterChainDefinition;24 &#125;25&#125; 数据库配置快速搭建临时测试的、结构很简单的数据库，选择 h2 内存数据库更为合适。 application.properties 中配置 h2 的数据源及初始化数据库的 SQL ： 1spring.datasource.driver-class-name=org.h2.Driver2spring.datasource.url=jdbc:h2:mem:shiro-test3spring.datasource.username=sa4spring.datasource.password=sa5spring.datasource.platform=h267spring.datasource.schema=classpath:sql/schema.sql8spring.datasource.data=classpath:sql/data.sql910spring.h2.console.settings.web-allow-others=true11spring.h2.console.path=/h212spring.h2.console.enabled=true resources 目录下创建 sql 文件夹，并创建两个 .sql 文件，分别声明数据库表的结构和数据： 1create table if not exists sys_department (2 id varchar(32) not null primary key,3 name varchar(32) not null4);56---78insert into sys_department (id, name) values ('idaaa', 'testaaa');9insert into sys_department (id, name) values ('idbbb', 'testbbb');10insert into sys_department (id, name) values ('idccc', 'testccc');11insert into sys_department (id, name) values ('idddd', 'testddd'); 编写测试代码下面就可以按照三层架构来写一些很简单的测试代码了。 DemoDao这里咱就不整合 MyBatis / Hibernate 了，直接使用原生的 JdbcTemplate 就可以： 1@Repository2public class DemoDao &#123;3 4 @Autowired5 JdbcTemplate jdbcTemplate;6 7 public List&lt;Map&lt;String, Object&gt;&gt; findAll() &#123;8 return jdbcTemplate.query(\"select * from sys_department\", new ColumnMapRowMapper());9 &#125;10 11 public int save(String name) &#123;12 return jdbcTemplate.update(\"insert into sys_department (id, name) values (?, ?)\",13 UUID.randomUUID().toString().replaceAll(\"-\", \"\"), name);14 &#125;15 16 public int update(String id, String name) &#123;17 return jdbcTemplate.update(\"update sys_department set name = ? where id = ?\", name, id);18 &#125;19&#125; DemoService + DemoService2声明一个会触发抛出运行时异常的方法，并标注 @Transactional 注解： 1@Service2public class DemoService &#123;3 4 @Autowired5 DemoDao demoDao;6 7 @Transactional(rollbackFor = Exception.class)8 public void doTransaction() &#123;9 demoDao.save(\"aaaaaaaa\");10 int i = 1 / 0;11 demoDao.update(\"18\", \"ccc\");12 &#125;13&#125; DemoService2 同样的代码，仅仅是类名不同，代码不再贴出。 DemoControllerController 里面同时依赖这两个 Service ： 1@RestController2public class DemoController &#123;3 4 @Autowired5 DemoService demoService;6 7 @Autowired8 DemoService2 demoService2;9 10 @GetMapping(\"/doTransaction\")11 public String doTransaction() &#123;12 demoService.doTransaction();13 return \"doTransaction\";14 &#125;15 16 @GetMapping(\"/doTransaction2\")17 public String doTransaction2() &#123;18 demoService2.doTransaction();19 return \"doTransaction2\";20 &#125;21&#125; Realm依赖Service最后，让自定义的 Realm 依赖咱刚写的 DemoService ： 1public class CustomRealm extends AuthorizingRealm &#123;2 3 @Autowired4 DemoService demoService;5 // ...... 运行测试运行 SpringBoot 的主启动类，在浏览器输入 http://localhost:8080/h2 输入刚才在 properties 文件中声明的配置，即可打开 h2 数据库的管理台。 执行 SELECT * FROM SYS_DEPARTMENT ，可以发现数据已经成功初始化了： 下面测试事务，在浏览器输入 localhost:8080/doTransaction ，浏览器自然会报除零异常，但刷新数据库，会发现数据库真的多了一条 insert 过去的数据！请求 /doTransaction2 则不会插入新的数据。 到这里，问题就真的发生了，下面要想办法解决这个问题才行。 问题排查既然两个 Service 在代码上完全一致，只是一个被 Realm 依赖了，一个没有依赖而已，那总不能是这两个 Service 本来就不一样吧！ 检查两个Service对象将断点打在 /doTransaction 对应的方法上，Debug 重新启动工程，待断点落下后，发现被 Realm 依赖的 DemoService 不是代理对象，而没有被 Realm 依赖的 DemoService2 经过事务的增强，成为了一个代理对象： 所以由此就可以看到问题所在了吧！上面的那个 DemoService 都没经过事务代理，凭什么能支持事务呢？？？ 检查Service的创建时机既然两个 Service 都不是一个样的，那咱就看看这俩对象都啥时候创建的吧！给 DemoService 上显式的添加上无参构造方法，方便过会 Debug ： 1@Service2public class DemoService &#123;3 4 public DemoService() &#123;5 System.out.println(\"DemoService constructor run ......\");6 &#125; 重新以 Debug 运行，等断点打在构造方法中，观察方法调用栈： 看上去还比较正常吧，但如果往下拉到底，这问题就太严重了： 哦，合着我这个 DemoService 在 refresh 方法的后置处理器注册步骤就已经创建好了啊！小伙伴们要知道，SpringFramework 中 ApplicationContext 的初始化流程，一定是先把后置处理器都注册好了，再创建单实例 Bean 。但是这里很明显是后置处理器还没完全处理完，就引发单实例 Bean 的创建了！ 问题解决问题终于找明白了，咋解决呢？其实网上有的是现成的文章了： spring boot shiro 事务无效 shiro导致springboot事务不起效解决办法 spring + shiro 配置中部分事务失效分析及解决方案 总的来看，解决方案的核心在于：如何让 Realm 创建时不立即依赖创建 DemoService ，所以就有两种解决方案了：要么延迟初始化 DemoService ，要么把自定义的 Realm 和 SecurityManager 放在一个额外的空间，利用监听器机制创建它们 。具体的实现可以参照上面文章的写法，这里就不赘述了。 原理扩展解决问题之后，如果能从这里面了解到一点更深入的原理知识，想必那是最好不过了。下面就这个问题出现的原因，以及上面 @Lazy 方案的原理，咱都深入解析一下。 Shiro提早创建Realm的原因既然上面看到了方法调用栈中，DemoService 被自定义 Realm 依赖后在 ApplicationContext 的 refresh 阶段的 registerBeanPostProcessors 中就已经被触发创建，可它为什么非要搞这一出呢？自定义 Realm 放到 finishBeanFactoryInitialization 中统一创建不好吗？下面咱通过 Debug 研究问题的成因。 Debug运行DemoService 中的断点不要去掉，重新 Debug 让断点停在那里，翻到最底下的调用栈，查看那个正在创建的 BeanPostProcessor ，发现它的名称是 shiroEventBusAwareBeanPostProcessor ： Shiro的后置处理器创建翻开创建 shiroEventBusAwareBeanPostProcessor 的位置，在 ShiroBeanAutoConfiguration 中，它又依赖了一个 EventBus ： 1@Bean2@ConditionalOnMissingBean3@Override4public ShiroEventBusBeanPostProcessor shiroEventBusAwareBeanPostProcessor() &#123;5 return super.shiroEventBusAwareBeanPostProcessor();6&#125;78protected ShiroEventBusBeanPostProcessor shiroEventBusAwareBeanPostProcessor() &#123;9 return new ShiroEventBusBeanPostProcessor(eventBus());10&#125; 顺着方法调用栈往上爬，找到下一个 doCreateBean ，发现确实有创建 eventBus 的部分： 再往上爬，发现这上面有一个 wrapIfNecessary 方法的调用，很明显这是要搞 AOP 增强了啊： AOP 的增强需要先获取到增强器，继续往上爬方法调用，在 findAdvisorBeans 方法中找到了两个适配的增强器： 上面的是 Shiro 的授权相关的增强器，下面是 SpringFramework 中的事务控制增强器。 触发AOP增强器的创建根据迭代顺序，先取出下面的事务控制增强器 TransactionAdvisor ，由于获取到增强器的 Bean 也是需要走统一的 getBean 方法，所以在方法调用栈中，咱又一次看到了 getBean 方法，继续往下创建。 由于在 SpringFramework 中，使用 @Configuration + @Bean 声明的 Bean ，都是要先把配置类初始化好，才能创建 Bean 。所以继续往上爬调用栈时，会发现它并没有接着创建 Shiro 的增强器 authorizationAttributeSourceAdvisor ，而是先初始化了声明有 TransactionAttributeSourceAdvisor 的配置类 ProxyTransactionManagementConfiguration ： 再往上走，发现又出现了一次 wrapIfNecessary 方法，说明配置类也会被 AOP 增强。那就重复一遍上面的步骤，继续遇到这两个增强器。 这个时候可能有小伙伴产生疑问了：这次创建就是因为上面的 TransactionAttributeSourceAdvisor 创建才跟过来的，这次还要再创建，这是闹哪出呢？放心，咱都想到这个问题了，人家写 SpringFramework 的大佬们能想不到吗？所以在创建之前，它加了一个判断： 1if (this.beanFactory.isCurrentlyInCreation(name)) &#123;2 // 如果当前bean正在创建，则跳过3 if (logger.isTraceEnabled()) &#123;4 logger.trace(\"Skipping currently created advisor '\" + name + \"'\");5 &#125;6&#125;7else &#123;8 try &#123;9 advisors.add(this.beanFactory.getBean(name, Advisor.class));10 &#125; 这里巧妙的利用了 singletonsCurrentlyInCreation 这个集合，判断了当前增强器是否在创建，这样就不会出现重复创建无限死循环的问题了。 singletonsCurrentlyInCreation 的存放是在 getSingleton 方法调用时就已经放进去了，所以能很稳妥的记录下当前正在创建的所有 Bean ，防止死循环重复创建。 Shiro增强器的创建上面的事务控制增强器跳过去了，那就可以创建 Shiro 的增强器了： 这次没有再出现那些幺蛾子，但是这个增强器本身依赖一个 SecurityManager ： 那就继续创建呗，创建 SecurityManager 的过程中又出现了新的依赖： 这个 authorizer ，就是咱上面在 ShiroConfiguration 中注册的自定义 Realm 。 看到这里了，后续的步骤想必不用我说小伙伴们也能自己想到了吧：Realm 的创建又需要依赖 DemoService ，而 DemoService 在创建时由于事务控制增强器还没有创建好，所以无法代理 DemoService ，最终注入到 Realm 的 DemoService 就是不带事务的。 小结捋一捋整个流程哈，整个创建过程经历了以下几个层级的依赖创建： ApplicationContext 的 refresh 方法要创建 BeanPostProcessor ShiroEventBusBeanPostProcessor 的创建需要依赖 EventBus EventBus 创建时需要被 AOP 增强，触发 AOP 增强器的创建逻辑 此时 AOP 增强器有 2 个，分别是事务控制增强器，和 Shiro 的增强器 首先创建事务控制的 AOP 增强器 TransactionAttributeSourceAdvisor ，由于它定义在配置类中，又触发配置类的创建 配置类创建时也要被 AOP 增强，再一次触发 AOP 增强器的创建逻辑 此时事务控制增强器正在被创建，所以被跳过了 触发 Shiro 增强器的创建，而 Shiro 增强器又依赖 SecurityManager SecurityManager 又依赖 authorizer ，也就是自定义的 Realm 自定义 Realm 依赖 DemoService ，触发 DemoService 的创建 DemoService 创建后要被事务 AOP 增强，但此时事务控制增强器还没有完全创建好，所以无法代理，导致 DemoService 不带事务 @Lazy解决该问题的原理上面解决方案的第三篇文章，他提到可以用 @Lazy 注解解决问题，我在翻文章时有人说不能用（他把 @Lazy 注解标注到 DemoService 类上了），讲道理可能是他不会用才这么说的（￣へ￣）。其实用 @Lazy 注解是完全可行的，不过标注的位置要对，真正要标注的位置是自定义 Realm 的 DemoService 成员上： 1@Autowired2@Lazy3DemoService demoService; 下面咱解释下为什么 @Lazy 标注在自定义 Realm 的依赖上好用，标注在 DemoService 类上不好用。 测试-@Lazy标注在DemoService上将 @Lazy 注解标注到 DemoService 的类上： 1@Service2@Lazy3public class DemoService 重新 Debug ，发现断点落在 DemoService 的构造方法时，refresh 的动作仍然停在 registerBeanPostProcessors 步骤，说明将 @Lazy 标注在 DemoService 上是不可行的，这也就是上面我提的那个文章里说 @Lazy 不可行。 测试-@Lazy标注在自定义Realm的依赖上去掉上面 DemoService 类上的 @Lazy ，在自定义 Realm 的 DemoService 依赖上标注，重新 Debug，观察断点停下时 refresh 执行的步骤： 可以发现已经到了可以正常初始化单实例 Bean 的时机了，此时创建的 DemoService 就不会有问题了。 放行断点，待应用启动完成后，浏览器再发送 /doTransaction 的请求，发现这次事务已经生效了。 到这里，就验证了 @Lazy 的正确使用方法。 但是！！！不要着急！下面咱再扩展一点原理哈 ~ ~ ~ 想一下，此时这个 DemoService 是啥玩意触发创建的？ 答案很明显是 DemoController ，因为 Controller 还依赖着 Service 呢。 测试-@Lazy标注Realm+Controller继续测试，把自定义 Realm 和 DemoController 两个类的 DemoService 依赖都标注上 @Lazy ，重新 Debug ，待断点停下后，想一下此时 DemoService 又是谁触发它创建的呢？ 答案也不难猜，是 IOC 容器本身创建的，因为 DemoService 所有被依赖的关系都延迟加载了，但 IOC 容器本身还要预先创建好所有的单实例 Bean ，所以 DemoService 还是在 IOC 容器启动的过程中创建了。 测试-@Lazy全标注继续，这次把 DemoService 上也标注上 @Lazy ，重新 Debug ，这次应用没有落在断点上直接启动了，说明 IOC 容器本身发现 DemoService 也可以延迟创建，就跳过去了，所以 IOC 容器初始化的全过程中 DemoService 都没有创建。 小结总结一下 @Lazy 的使用规则和对应的原理： @Lazy 标注在 Bean 的类上：告诉 IOC 容器，在容器初始化阶段不要实例化我 @Lazy 标注在其他 Bean 的依赖上：告诉 IOC 容器，在创建这个标注了 @Lazy 的 Bean 时，不要立即处理我标注的这个依赖 本文涉及到的所有源码可以从 GitHub 中找到：https://github.com/LinkedBear/juejin-posts-sources 【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】","categories":[{"name":"不懂就问","slug":"不懂就问","permalink":"http://yoursite.com/categories/%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"声明式事务","slug":"声明式事务","permalink":"http://yoursite.com/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"Spring中使用的设计模式，你都能说全吗？[下]","slug":"Spring中使用的设计模式，你都能说全吗？[下]","date":"2020-06-13T05:16:55.000Z","updated":"2020-06-28T07:07:04.448Z","comments":true,"path":"2020/06/13/Spring中使用的设计模式，你都能说全吗？[下]/","link":"","permalink":"http://yoursite.com/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8B]/","excerpt":"","text":"这是 Spring 面试题系列的第二篇 【Spring 中的设计模式】 下半部分， 本篇只回答一个问题： Spring 中使用了哪些设计模式？分别都是如何实现的？回顾一下上一篇的概述，从整体上讲，SpringFramework 中使用了 11 种设计模式： 单例模式+原型模式 工厂模式 代理模式 策略模式 模板方法模式 观察者模式 适配器模式 装饰者模式 外观模式 委派模式（不属于GoF23） 这一篇咱把下面的 6 个设计模式也详细解析一下。 喜欢本文的小伙伴不要忘记点赞呀 ~ ~ ~ 三克油！！！ 模板方法模式模板方法模式，在 SpringFramework 中使用的那是相当的多啊！即便是初学 SpringFramework ，在学习到 jdbc 部分，也应该接触过一个模板方法模式的体现，就是 JdbcTemplate 的回调机制：（贴两个比较常见的经典方法） 1public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;2 return result(query(sql, new RowMapperResultSetExtractor&lt;&gt;(rowMapper)));3&#125;45public List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql) throws DataAccessException &#123;6 return query(sql, getColumnMapRowMapper());7&#125; 在调用时，只需要一句话就够了： 1List&lt;Map&lt;String, Object&gt;&gt; datas = jdbcTemplate.queryForList(\"select * from user\"); 小伙伴们可能会一脸懵，这么个方法就体现模板方法模式了吗？我也看不出来啊？莫慌，下面咱先回顾下原生 jdbc 的操作步骤，慢慢自然就明白了。 原生jdbc使用步骤原生的 jdbc 操作需要以下这么多步骤： 1// 注册驱动2Class.forName(\"com.mysql.jdbc.Driver\");3// 获取连接4Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"root\", \"123456\");5// 编写SQL获取预处理对象6PreparedStatement statement = connection.prepareStatement(\"select * from user\");7// 执行SQL获取结果集8ResultSet resultSet = statement.executeQuery();9// 封装结果数据10List&lt;Map&lt;String, Object&gt;&gt; datas = new ArrayList&lt;&gt;();11while (resultSet.next()) &#123;12 Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();13 data.put(\"id\", resultSet.getString(\"id\"));14 data.put(\"name\", resultSet.getString(\"name\"));15 datas.add(data);16&#125;17// 关闭连接18resultSet.close();19statement.close();20connection.close();21// 返回/输出数据22System.out.println(datas); 但是，这里面的操作有很多是重复的，所以这一段代码可以抽取为几个方法： 1// 获取连接2public Connection getConnection() throws Exception &#123;3 Class.forName(\"com.mysql.jdbc.Driver\");4 return DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"root\", \"123456\");5&#125;67// 封装数据8public List&lt;Map&lt;String, Object&gt;&gt; encapsulate(ResultSet resultSet) throws SQLException &#123;9 List&lt;Map&lt;String, Object&gt;&gt; datas = new ArrayList&lt;&gt;();10 while (resultSet.next()) &#123;11 Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();12 data.put(\"id\", resultSet.getString(\"id\"));13 data.put(\"name\", resultSet.getString(\"name\"));14 datas.add(data);15 &#125;16 return datas;17&#125;1819// 关闭连接20public void close(Connection connection, PreparedStatement statement, ResultSet resultSet) throws SQLException &#123;21 resultSet.close();22 statement.close();23 connection.close();24&#125; 如此下来，主干代码就只剩下这些了： 1public void query() throws Exception &#123;2 Connection connection = getConnection();3 // 编写SQL获取预处理对象4 PreparedStatement statement = connection.prepareStatement(\"select * from user\");5 // 执行SQL获取结果集6 ResultSet resultSet = statement.executeQuery();7 // 封装结果数据8 List&lt;Map&lt;String, Object&gt;&gt; datas = encapsulate(resultSet);9 close(connection, statement, resultSet);10 // 返回/输出数据11 System.out.println(datas);12&#125; 那最后稍微调整一下，就可以成为一个通用的方法： 1public List&lt;Map&lt;String, Object&gt;&gt; query(String sql, List&lt;Object&gt; params) throws Exception &#123;2 Connection connection = getConnection();3 // 编写SQL获取预处理对象4 PreparedStatement statement = connection.prepareStatement(sql);5 // 填充占位符参数6 for (int i = 0; i &lt; params.size(); i++) &#123;7 statement.setObject(i + 1, params.get(i));8 &#125;9 // 执行SQL获取结果集10 ResultSet resultSet = statement.executeQuery();11 // 封装结果数据12 List&lt;Map&lt;String, Object&gt;&gt; datas = encapsulate(resultSet);13 close(connection, statement, resultSet);14 // 返回数据15 return datas;16&#125; 目前这个方法已经可以通用了，不过只能返回 Map ，如果想返回模型类对象怎么办呢？这样咱就可以扩展一个自定义结果集封装的方法，让调用者自己决定如何封装。再次改动的代码可以像如下优化： 1public &lt;T&gt; List&lt;T&gt; query(String sql, List&lt;Object&gt; params, Function&lt;ResultSet, List&lt;T&gt;&gt; encapsulate) throws Exception &#123;2 Connection connection = getConnection();3 // 编写SQL获取预处理对象4 PreparedStatement statement = connection.prepareStatement(sql);5 // 填充占位符参数6 for (int i = 0; i &lt; params.size(); i++) &#123;7 statement.setObject(i + 1, params.get(i));8 &#125;9 // 执行SQL获取结果集10 ResultSet resultSet = statement.executeQuery();11 // 封装结果数据（借助Function接口实现结果集封装）12 List&lt;T&gt; datas = encapsulate.apply(resultSet);13 close(connection, statement, resultSet);14 // 返回数据15 return datas;16&#125; 看最后一个参数，我让方法的调用者传一个 Function&lt;ResultSet, List&lt;T&gt;&gt; 类型的自定义处理逻辑，这样返回的数据究竟是什么类型我也就不用管了，完全由调用者自己决定。 到这里，模板方法模式就得以体现了，整个查询的动作我只需要让方法调用者传 SQL 、SQL 中可能出现的参数，以及自定义的结果集封装逻辑，其余的动作都不需要方法调用者关注。 可是，这跟 JdbcTemplate 又有什么关系呢？？？ JdbcTemplate中体现的模板方法我上面不是摘出来一个 JdbcTemplate 的方法嘛： 1public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;2 return result(query(sql, new RowMapperResultSetExtractor&lt;&gt;(rowMapper)));3&#125; 咱点进去看 query 方法的实现： 1public &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;2 // assert logger ......34 class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;5 @Override6 @Nullable7 public T doInStatement(Statement stmt) throws SQLException &#123;8 ResultSet rs = null;9 try &#123;10 rs = stmt.executeQuery(sql);11 return rse.extractData(rs);12 &#125;13 finally &#123;14 JdbcUtils.closeResultSet(rs);15 &#125;16 &#125;17 @Override18 public String getSql() &#123;19 return sql;20 &#125;21 &#125;2223 return execute(new QueryStatementCallback());24&#125; 注意看方法参数列表的最后一个：ResultSetExtractor ，它是一个函数式接口，而且它只有一个方法，就是根据结果集返回泛型类型的数据： 1@FunctionalInterface2public interface ResultSetExtractor&lt;T&gt; &#123;3 @Nullable4 T extractData(ResultSet rs) throws SQLException, DataAccessException;5&#125; 是不是这个设计跟我上面演示的思路基本一致了？这就是 JdbcTemplate 中体现的模板方法模式。 除了这些 xxxTemplate 中有体现，其实在 SpringFramework 中的最底层 IOC 容器模型，BeanFactory 和 ApplicationContext ，以及 SpringWebMvc 中的 HandlerMapping 、HandlerAdapter 等等，都有很多模板方法模式的体现。下面咱也举两个例子来体会。 ApplicationContext中体现的模板方法说到 ApplicationContext ，最经典的方法莫过于 AbstractApplicationContext 中的 refresh ：（只截取很少的一部分） 1public void refresh() throws BeansException, IllegalStateException &#123;2 synchronized (this.startupShutdownMonitor) &#123;3 // ......4 try &#123;5 // ......6 // Initialize other special beans in specific context subclasses.7 onRefresh();8 // ......9 &#125; // catch finally ......10 &#125;11&#125; 在这个方法中有一个动作是 onRefresh 方法，点进去发现它是一个空方法： 1/**2 * Template method which can be overridden to add context-specific refresh work.3 * Called on initialization of special beans, before instantiation of singletons.4 * &lt;p&gt;This implementation is empty.5 * @throws BeansException in case of errors6 * @see #refresh()7 */8protected void onRefresh() throws BeansException &#123;9 // For subclasses: do nothing by default.10&#125; 注意看文档注释的前两个单词：Template method ！！！文档注释已经告诉咱这是一个模板方法了！而且方法体中也说了，它默认不做任何事情，留给子类扩展使用。由此咱就可以了解 ApplicationContext 中最经典的模板方法模式设计之一了。 HandlerMapping中体现的模板方法在 DispatcherServlet 接收到客户端的请求，要进行实际处理时，需要先根据 uri 寻找能匹配的 HandlerMapping ，这一步它会委托 HandlerMapping 帮忙找（这里面涉及到委派了，下面会讲到），而这个寻找 HandlerMapping 的动作在 AbstractHandlerMapping 的 getHandler 方法中： 1public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;2 Object handler = getHandlerInternal(request);3 if (handler == null) &#123;4 handler = getDefaultHandler();5 &#125;6 // ......7&#125; 这里面第一句就会调另一个 getHandlerInternal 方法，而这个方法在 AbstractHandlerMapping 中是自己定义的抽象方法： 1protected abstract Object getHandlerInternal(HttpServletRequest request) throws Exception; 这就是非常经典的模板方法模式的体现了：父类 / 抽象类把逻辑步骤都定义出来，具体的动作让子类实现。 小结SpringFramework 中体现的模板方法模式非常多，包括各种 Template （ JdbcTemplate 、HibernateTemplate 、RedisTemplate 等），以及核心源码内部设计的模板方法（如 AbstractApplicationContext 中的 refresh 套 onRefresh 、AbstractHandlerMapping 中的 getHandler 套 getHandlerInternal 等），它设计的核心思想是父类 / 抽象类把逻辑步骤都定义出来，具体的动作让子类实现。 观察者模式观察者模式，也被称为发布订阅模式，其实它还有一个叫法：监听器模式。那说到监听器，是不是就立马想起来 SpringFramework 中的 ApplicationListener 了？对了，就这么回事，其实都不用展开讲，小伙伴们也能答得出来了。不过，想回答的漂亮，还需要额外知道一点点东西。 观察者模式的核心咱都知道，观察者模式的两大核心是：观察者、被观察主题。对应到 SpringFramework 中的概念分别是：事件、监听器。 不过我个人比较喜欢把 SpringFramework 的事件驱动核心概念划分为 4 个：事件源、事件、广播器、监听器。 事件源：发布事件的对象 事件：事件源发布的信息 广播器：事件真正广播给监听器的对象【即 ApplicationContext 】 ApplicationContext 接口有实现 ApplicationEventPublisher 接口，具备事件广播器的发布事件的能力 监听器：监听事件的对象 在 SpringFramework 中，事件源想要发布事件，需要注入事件广播器，通过事件广播器来广播事件。 SpringFramework使用监听器以下是一个最简单的监听器使用实例： 事件模型1public class ServiceEvent extends ApplicationEvent &#123;2 3 public ServiceEvent(Object source) &#123;4 super(source);5 &#125;6&#125; 事件源1@Service2public class EventService implements ApplicationContextAware &#123;3 4 private ApplicationContext ctx;5 6 public void publish() &#123;7 ctx.publishEvent(new ServiceEvent(this));8 &#125;9 10 @Override11 public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123;12 this.ctx = ctx;13 &#125;14&#125; 监听器1@Component2public class MyListener implements ApplicationListener&lt;ServiceEvent&gt; &#123;3 4 @Override5 public void onApplicationEvent(ServiceEvent event) &#123;6 System.out.println(\"监听到ServiceEvent事件：\" + event);7 &#125;8&#125; 小结SpringFramework 中实现的观察者模式就是事件驱动机制，可以通过自定义监听器，监听不同的事件，完成不同的业务处理。 适配器模式了解 SpringWebMvc 中 DispatcherServlet 的工作原理，应该对 HandlerAdapter 不陌生，它就是辅助执行 Controller 中具体方法的适配器。如果只答这一句当然够用，不过回答的再细致点，那自然是更好的。 DispatcherServlet委派HandlerAdapter在 DispatcherServlet 的 doDispatch 方法中，有一句代码是根据 HandlerMapping 中的 Handler 获取 HandlerAdapter ： 1HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); 这个 Handler 就是目标 Controller 中的目标方法，在适配的过程中它会寻找现有的所有 HandlerAdapter 是否能支持执行这个 Handler ，根据 RequestMappingHandlerMapping 的命名，自然也能猜得出来，真正负责执行目标 Controller 中方法的是 RequestMappingHandlerAdapter 。 HandlerAdapter执行Handler在 RequestMappingHandlerAdapter 中，执行目标 Controller 中方法的核心方法是 handle ： 1public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)2 throws Exception &#123;3 return handleInternal(request, response, (HandlerMethod) handler);4&#125; 看到了 handleInternal ，是不是又想到了模板方法？没错，就是这个设计。 在底层，核心的执行 Handler 的逻辑其实就是反射： 1protected Object doInvoke(Object... args) throws Exception &#123;2 ReflectionUtils.makeAccessible(getBridgedMethod());3 try &#123;4 // method.invoke5 return getBridgedMethod().invoke(getBean(), args);6 &#125; // catch ......7&#125; 由此可知，HandlerAdapter 的执行其实也没有很神秘，最终还是玩的反射而已。 小结SpringFramework 中的适配器模式，体现之一是 HandlerAdapter 辅助执行目标 Controller 中的方法，底层是借助反射执行。 装饰者模式装饰者跟代理、适配器都有些相似，不过装饰者更强调的是在原有的基础上附加额外的动作 / 方法 / 特性，而代理模式有控制内部对象访问的意思。 SpringFramework 中体现的装饰者模式，在核心源码中并没有体现，不过在缓存模块 spring-cache 中倒是有一个体现：TransactionAwareCacheDecorator 。 Bean的包装了解过 Bean 的创建流程，应该知道最底层的创建动作发生在 AbstractAutowireCapableBeanFactory 的 doCreateBean 中，而这里面第一波动作就把 BeanWrapper 都创建好了： 1protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)2 throws BeanCreationException &#123;3 // Instantiate the bean.4 BeanWrapper instanceWrapper = null;5 // ......6 if (instanceWrapper == null) &#123;7 instanceWrapper = createBeanInstance(beanName, mbd, args);8 &#125; 注意看，它创建的动作是 createBeanInstance ，意为“创建 bean 实例”，那就可以理解为：bean 对象已经在这个动作下实例化好了。深入这个方法，最终可以在 createBeanInstance 方法的最后一句 return 中看到 bean 实例的创建，以及 BeanWrapper 的包装： 1protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;2 // ......3 return instantiateBean(beanName, mbd);4&#125;56protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;7 try &#123;8 Object beanInstance;9 // 实例化对象......10 BeanWrapper bw = new BeanWrapperImpl(beanInstance);11 initBeanWrapper(bw);12 return bw;13 &#125; // catch ......14&#125; 看到下面的代码中，它把 bean 的实例对象包装为一个 BeanWrapper ，形成装饰者。 SpringCache的核心设计SpringCache 主做的是应用业务层级的缓存，它与 JSR107 有一定关系但又不同（Spring 自己实现了一套缓存，就是这个 SpringCache ）。 用一张简单的图解释 SpringCache 的核心，大概可以这样理解： 一个 CacheManager 中包含多个 Cache ，一个 Cache 可以简单理解为一个 Map&lt;String, T&gt; 。 从 Cache 接口的设计，也能看出来就是 Map 的思路：（核心方法） 1@Nullable2ValueWrapper get(Object key);34void put(Object key, @Nullable Object value); Cache的装饰者体现TransactionAwareCacheDecorator 作为装饰者，那肯定要实现 Cache 接口，并且组合一个 Cache 的对象： 1public class TransactionAwareCacheDecorator implements Cache &#123;23 private final Cache targetCache; 这里面，真正体现装饰者的位置是在 put 方法中： 1public void put(final Object key, @Nullable final Object value) &#123;2 if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;3 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() &#123;4 @Override5 public void afterCommit() &#123;6 TransactionAwareCacheDecorator.this.targetCache.put(key, value);7 &#125;8 &#125;);9 &#125;10 else &#123;11 this.targetCache.put(key, value);12 &#125;13&#125; 可以发现，它会在 put 之前，检查当前线程中是否存在已经开启的事务：如果存在事务，则会将 put 操作注册到事务结束后。 小结SpringFramework 中实现的装饰者模式，体现之一是在 SpringCache 缓存的存放逻辑中，如果执行缓存时的线程中存在事务，则缓存的保存会在事务结束后再执行。 外观模式外观模式算是比较简单的模式，它强调的是统一入口，内部组合。一个经典的体现是在 IOC 解析 Bean 的定义信息时使用的 BeanDefinitionLoader 。 在 BeanDefinitionLoader 中，它组合了 4 种不同类型的解析器： 1class BeanDefinitionLoader &#123;2 // 注解式Bean定义解析器3 private final AnnotatedBeanDefinitionReader annotatedReader;4 // xml文件的Bean定义解析器5 private final XmlBeanDefinitionReader xmlReader;6 // Groovy的Bean定义解析器7 private BeanDefinitionReader groovyReader;8 // 类路径的Bean定义扫描器9 private final ClassPathBeanDefinitionScanner scanner; 尽管组合的解析器很多，但最终暴露出来的方法是同样的名：load 。 1private int load(Class&lt;?&gt; source) &#123; /* ... */ &#125;2private int load(GroovyBeanDefinitionSource source) &#123; /* ... */ &#125;3private int load(Resource source) &#123; /* ... */ &#125;4private int load(Package source) &#123; /* ... */ &#125;5private int load(CharSequence source) &#123; /* ... */ &#125; 由此可以体现出很经典的外观模式。 委派模式委派模式本不属于 GoF23 中的设计模式，不过既然咱在前面也反复提到过几次，这里咱还是摘出来说两句。 在 DispatcherServlet 的核心工作流程中，委派模式体现在 HandlerMapping 、HandlerAdapter 、ViewResolver 接受 DispatcherServlet 的委派，如下面的整体流程图： 到这里，SpringFramework 中使用的设计模式就差不多整理完了，想要回答的尽可能全面、准确、有深度，小伙伴们要好好理解这些模式的设计、思想，以及 SpringFramework 中的源码实现，这样在被面试官问到才会更加游刃有余。 【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】","categories":[{"name":"SpringFramework","slug":"SpringFramework","permalink":"http://yoursite.com/categories/SpringFramework/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Spring中使用的设计模式，你都能说全吗？[上]","slug":"Spring中使用的设计模式，你都能说全吗？[上]","date":"2020-06-09T05:16:55.000Z","updated":"2020-06-28T07:06:53.647Z","comments":true,"path":"2020/06/09/Spring中使用的设计模式，你都能说全吗？[上]/","link":"","permalink":"http://yoursite.com/2020/06/09/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8A]/","excerpt":"","text":"这是 Spring 面试题系列的第二篇，本文的主题：Spring 中涉及到的设计模式，如何在面试中回答的尽可能全面、准确、有深度。 本篇只回答一个问题： Spring 中使用了哪些设计模式？分别都是如何实现的？首先作一个概述，从整体上讲，SpringFramework 中使用了 11 种设计模式： 单例模式+原型模式 工厂模式 代理模式 策略模式 模板方法模式 观察者模式 适配器模式 装饰者模式 外观模式 委派模式（不属于GoF23） 当然，如果只是这么回答，面试官会怎么想：你这。。。不会是在背答案吧！随便揪出一个来细问，可能就翻皮水了 ~ ~ 所以咱不光要知道用了啥，而且还要知道如何用的，在哪里用的，这样才能用自己真正的技术储备征服面试官。 下面咱详细的介绍 11 种设计模式的设计场景和原理。 由于 11 种设计模式全部展开篇幅过长，会分成两篇专栏介绍。 单例模式+原型模式SpringFramework 的 IOC 容器中放了很多很多的 Bean ，默认情况下，Bean 的作用域（ Scope ）是 singleton ，就是单实例的；如果显式声明作用域为 prototype ，那 Bean 的作用域就会变为每次获取都是一个新的，即原型 Bean 。这个知识点本应该在 SpringFramework 最基础阶段就应该知道的，咱也不多啰嗦。关键的问题是，如果我定义的 Bean 声明了 prototype ，那 SpringFramework 肯定知道我要搞原型 Bean ；但我定义 Bean 的时候没声明 Scope ，它怎么就给我默认成单实例的呢？ 下面咱先从最熟悉的 Bean 注册场景出发。（原型模式相对简单，内容已穿插在解释单例模式之中） Bean的注册xml方式注册Bean1&lt;bean class=\"com.example.demo.bean.Person\" scope=\"singleton\"/&gt; 这是最最简单的 Bean 的注册了，这里面如果显式声明了 scope=&quot;singleton&quot; 后，IDE 会报黄（警告）： 很明显它提示了默认值就是 singleton ，咱没必要再主动声明了。这个提示是 IDEA 智能识别的，咱不好找出处，不过咱可以点进去这个 scope ，看一眼 xsd 中的注释： 1&lt;xsd:attribute name=\"scope\" type=\"xsd:string\"&gt;2 &lt;xsd:annotation&gt;3 &lt;xsd:documentation&gt;&lt;![CDATA[4 The scope of this bean: typically \"singleton\" (one shared instance,5 which will be returned by all calls to getBean with the given id), ...... 很明显文档注释的第一句就说了：通常它是 singleton 的。 注解驱动注册Bean注解驱动的方式，都是使用一个 @Scope 注解来声明作用域的： 1@Scope2@Component3public class Person &#123;4 5&#125; 点开 @Scope 注解看源码，可以发现只标注 @Scope 注解，不声明作用域，默认值是空字符串（不是 singleton ）： 1public @interface Scope &#123;23 @AliasFor(\"scopeName\")4 String value() default \"\"; 这个地方可能就会有疑惑了，它声明的是空字符串，可是在 xml 中我配置的是 singleton 啊，这怎么不一样呢？莫慌，下面咱来解析这其中的原因。 默认的作用域标注对 SpringFramework 有一些深入了解的小伙伴应该能意识到我接下来要说什么了：BeanDefinition 。所有 Bean 的定义信息都被 SpringFramework 封装到 BeanDefinition 中了，而作用域的定义就在 BeanDefinition 的抽象实现类 AbstractBeanDefinition 中： 1public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor2 implements BeanDefinition, Cloneable &#123;34 public static final String SCOPE_DEFAULT = \"\"; 这里面一上来就声明了默认的作用域就是空字符串，不是 singleton 。 这个时候可能有的小伙伴就更迷惑了，这里面它都声明了单实例 Bean 是空字符串，那 singleton 还有个卵用呢？判断单实例 Bean 不是应该看作用域是否为 singleton 吗？ 哎，说到这里了，那咱就看看 BeanDefinition 中是如何获取作用域的： 1public String getScope() &#123;2 return this.scope;3&#125; 获取作用域的方式非常简单，这个没啥看的。但是！！！注意继续往下翻，紧跟着下面有一个方法叫 isSingleton ： 1/**2 * Return whether this a &lt;b&gt;Singleton&lt;/b&gt;, with a single shared instance3 * returned from all calls.4 * @see #SCOPE_SINGLETON5 */6@Override7public boolean isSingleton() &#123;8 return SCOPE_SINGLETON.equals(this.scope) || SCOPE_DEFAULT.equals(this.scope);9&#125; 看这里面的判断，它分为了两个部分：是否是 singleton ，或者是否为空串！那这就说得过去了吧，人家设置成空串，意义上也是单实例 Bean 。 Bean的实例化上面咱也知道了，默认情况下 Bean 是单实例的，那 SpringFramework 在 IOC 容器初始化的时候，是如何知道这些 Bean 是否是单实例的，同时初始化并保存的呢？下面咱跟进底层初始化逻辑中看一眼。 本部分只粗略介绍 Bean 的初始化流程，详细的解析可以参照我的 SpringBoot 源码小册 14 章详细学习。 在 AbstractBeanFactory 中，getBean 方法会调用到 doGetBean ，这个方法的篇幅非常长，这里只剪出框框： 1protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,2 @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123;3 final String beanName = transformedBeanName(name);4 Object bean;56 // Eagerly check singleton cache for manually registered singletons.7 // 最开始先检查单实例对象缓存池中是否已经有对应的bean了8 Object sharedInstance = getSingleton(beanName);9 // ......10 else &#123;11 // ......12 try &#123;13 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);14 // 检查 ......1516 // Create bean instance.17 if (mbd.isSingleton()) &#123;18 // 单实例Bean19 sharedInstance = getSingleton(beanName, () -&gt; &#123;20 try &#123;21 return createBean(beanName, mbd, args);22 &#125; // catch ......23 &#125;);24 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);25 &#125;2627 else if (mbd.isPrototype()) &#123;28 // 原型Bean29 // It's a prototype -&gt; create a new instance.30 Object prototypeInstance = null;31 try &#123;32 beforePrototypeCreation(beanName);33 // 必定创建全新的对象34 prototypeInstance = createBean(beanName, mbd, args);35 &#125;36 finally &#123;37 afterPrototypeCreation(beanName);38 &#125;39 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);40 &#125;4142 else &#123;43 // 自定义scope44 String scopeName = mbd.getScope();45 final Scope scope = this.scopes.get(scopeName);46 // ......47 &#125;48 &#125; // catch ......49 &#125;50 // ......51 return (T) bean;52&#125; 仔细阅读这个框框流程，一上来它就要先检查单实例对象的缓存池中是否有现成的 Bean 了，没有再往下走。那咱说创建流程的话还是往下走，在 else 块的 try 部分，它会取出当前 Bean 的 BeanDefinition 来判断作用域：如果是 singleton 单实例的，就执行 getSingleton 方法创建单实例对象（底层走 lambda 表达式中的 createBean 方法）；如果是 prototype 原型 Bean ，就执行原型 Bean 的创建流程（直接创建）；如果这些都不是，那就可以认定为自定义 scope ，使用特殊的初始化流程。 所以由此看下来，单实例 Bean 的创建核心方法还是 getSingleton 了，那咱就进到这里面看一眼：（还是只有大框框的流程哈） 1private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);23public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;4 Assert.notNull(beanName, \"Bean name must not be null\");5 synchronized (this.singletonObjects) &#123;6 Object singletonObject = this.singletonObjects.get(beanName);7 if (singletonObject == null) &#123;8 // 检查9 try &#123;10 singletonObject = singletonFactory.getObject();11 newSingleton = true;12 &#125; // catch finally ......13 if (newSingleton) &#123;14 addSingleton(beanName, singletonObject);15 &#125;16 &#125;17 return singletonObject;18 &#125;19&#125; 注意看这里面的设计：它会先去单实例对象缓存池中找是否已经有对应的 bean 了，如果没有，就执行创建 bean 的动作。在创建完成后，它还会将 bean 放入缓存池中，这样以后再取的时候就不会再二次创建了。 小结所以这里面的核心逻辑也就可以总结出来了： SpringFramework 中实现的单例模式，是在 BeanDefinition 中默认配置 singleton 的作用域，在 IOC 容器初始化阶段，将 Bean 创建好，放入单实例对象缓存池（ singletonObjects ）中，实现 Bean 的单实例。 工厂模式提起工厂模式，在 SpringFramework 中最容易联想到的就是 FactoryBean 了吧！但其实 SpringFramework 中不止这一个是工厂，还有很多种其他的，下面咱来列举。 FactoryBeanFactoryBean 本身是一个接口，它本身就是一个创建对象的工厂。如果一个类实现了 FactoryBean 接口，则它本身将不再是一个普通的 bean 对象，不会在实际的业务逻辑中起作用，而是由创建的对象来起作用。 FactoryBean 接口有三个方法： 1public interface FactoryBean&lt;T&gt; &#123;2 // 返回创建的对象3 @Nullable4 T getObject() throws Exception;56 // 返回创建的对象的类型（即泛型类型）7 @Nullable8 Class&lt;?&gt; getObjectType();910 // 创建的对象是单实例Bean还是原型Bean，默认单实例11 default boolean isSingleton() &#123;12 return true;13 &#125;14&#125; 静态工厂这种方式很像咱在最开始学习简单工厂模式中看到的核心工厂，比方说下面这样： 1public class CalculatorFactory &#123;2 // 简单工厂3 public static Calculator getCalculator(String operationType) &#123;4 switch (operationType) &#123;5 case \"+\": 6 return new AddCalculator();7 case \"-\":8 return new SubtractCalculator();9 default: 10 return null;11 &#125;12 &#125;13 14 // 静态工厂15 public static Calculator getAddCalculator() &#123;16 return new AddCalculator();17 &#125;18&#125; 在 SpringFramework 中使用静态工厂，就没有参数这个说法了，只需要声明工厂类和方法即可（所以上面的工厂中我额外写了一个方法）： 1&lt;bean id=\"addCalculator\" class=\"com.example.demo.bean.CalculatorFactory\" factory-method=\"getAddCalculator\"/&gt; 这样注册后得到的 bean ，类型是 AddCalculator 。 实例工厂实例工厂的使用方式与静态工厂很像，只不过静态工厂本身不会注册到 IOC 容器中，但实例工厂会一起注册到 IOC 容器。 调整上面的代码，就可以实现实例工厂的 Bean 注册： 1public class CalculatorFactory &#123;2 // 工厂方法3 public Calculator getAddCalculator() &#123;4 return new AddCalculator();5 &#125;6&#125; 1&lt;bean id=\"calculatorFactory\" class=\"com.example.demo.bean.CalculatorFactory\"/&gt;2&lt;bean id=\"addCalculator\" factory-bean=\"calculatorFactory\" factory-method=\"getAddCalculator\"/&gt; ObjectFactory这个类型可能有些小伙伴会感觉有些陌生，所以我放到了最后写。 1@FunctionalInterface2public interface ObjectFactory&lt;T&gt; &#123;3 T getObject() throws BeansException;4&#125; 结构比 FactoryBean 简单，当然也可以简单地将其理解为 FactoryBean ，但又与其不同。ObjectFactory 一般情况下会作为一个 Bean 注入到其他 Bean 中，在需要用对应的 bean 时主动调用 ObjectFactory 的 getObject 方法获取真正需要的 Bean ；FactoryBean 的 getObject 方法是在 SpringFramework 初始化 Bean 时调用的，所以由此也可以知道两者的调用时机也不一样。 其实这个接口在上面看 Bean 的实例化过程中就遇到过了，在 getSingleton 的两参数方法中，第二个参数就是 ObjectFactory 类型，由它就可以调用 createBean 创建出单实例对象。 小结SpringFramework 中的工厂模式包括内置的 FactoryBean 、ObjectFactory ，以及自定义声明的静态工厂、实例工厂。 代理模式咱都知道，SpringFramework 的两大核心：IOC 、AOP ，AOP 就是体现了代理模式的使用。不过如果只说 AOP 体现了代理模式，那这个也太没水准了，咱要回答的更多更全，才能让面试官意识到你真的有研究过，你真的很懂！ AOP的底层实现SpringFramework 中对 Bean 进行 AOP 增强生成代理对象，核心是一个 BeanPostProcessor ：AnnotationAwareAspectJAutoProxyCreator ，这个名字很长，不过很好记： Annotation：注解式， Aware：注入式 AspectJ：基于 AspectJ 的 AOP AutoProxy：自动代理 Creator：创建器 这样一拆分，是不是感觉容易理解多了呢？ 它的核心作用方法是父类 AbstractAutoProxyCreator 的 postProcessAfterInitialization 方法，底层会调用 wrapIfNessary 方法创建代理对象： 1public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) &#123;2 if (bean != null) &#123;3 Object cacheKey = getCacheKey(bean.getClass(), beanName);4 if (this.earlyProxyReferences.remove(cacheKey) != bean) &#123;5 // 创建AOP代理对象6 return wrapIfNecessary(bean, beanName, cacheKey);7 &#125;8 &#125;9 return bean;10&#125; 至于再往底下，这个就麻烦大了，这里简单总结一下吧，详尽的代理对象创建可以参考 SpringBoot 源码小册的 19 章学习。 被 AOP 增强的 Bean ，会在初始化阶段（此时对象已经创建）被 AnnotationAwareAspectJAutoProxyCreator 处理，整合该 Bean 可能被覆盖到的切面，最终根据 Bean 是否有接口实现，采用 jdk 动态代理或者 Cglib 动态代理构建生成代理对象。 代理对象的创建上面的总结中提到了最终的动态代理创建，这里可以带小伙伴看一眼最底层你们熟悉的创建代理对象的源码。 jdk 动态代理的创建，在 JdkDynamicAopProxy 中，有一个 getProxy 方法，底层实现如下： 1public Object getProxy(@Nullable ClassLoader classLoader) &#123;2 if (logger.isTraceEnabled()) &#123;3 logger.trace(\"Creating JDK dynamic proxy: \" + this.advised.getTargetSource());4 &#125;5 Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);6 findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);7 // jdk原生方法8 return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);9&#125; 看最后一句，是不是突然熟悉了！这个地方就可以在面试中拿出来吹一吹，这样面试官可能就真的认为你把这部分原理都搞明白了哦（狗头）。 Cglib 动态代理的创建，在 CglibAopProxy 的 createProxyClassAndInstance 方法中有创建代理对象的实现： 1protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) &#123;2 enhancer.setInterceptDuringConstruction(false);3 enhancer.setCallbacks(callbacks);4 return (this.constructorArgs != null &amp;&amp; this.constructorArgTypes != null ?5 enhancer.create(this.constructorArgTypes, this.constructorArgs) :6 enhancer.create());7&#125; 看到这里的 Enhancer#create() 方法，是不是又是熟悉的一幕呢？所以由此也知道，框架也只是在咱学过的基础上层层包装增强罢了，最底层的还是不变的。 小结SpringFramework 中的代理模式体现在 AOP 上，它通过后置处理器，整合切面（增强器 Advice ）的逻辑，将原有的 Bean （目标对象 Target ）使用 jdk 或者 Cglib 动态代理增强为代理 Bean 。 策略模式说起 SpringFramework 中实现的策略模式，其实刚刚就提到了：AOP 生成代理对象时，会根据原始 Bean 是否有接口实现，决定使用 jdk 动态代理还是 Cglib 动态代理，这就是典型的策略模式体现。 直接说原理吧，在 DefaultAopProxyFactory 中有策略模式的体现： 1public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;2 if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;3 Class&lt;?&gt; targetClass = config.getTargetClass();4 if (targetClass == null) &#123;5 throw new AopConfigException(\"TargetSource cannot determine target class: \" +6 \"Either an interface or a target is required for proxy creation.\");7 &#125;8 // 策略判断9 if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;10 return new JdkDynamicAopProxy(config);11 &#125;12 return new ObjenesisCglibAopProxy(config);13 &#125;14 else &#123;15 return new JdkDynamicAopProxy(config);16 &#125;17&#125; 中间的这个判断当前要代理的目标对象，类型是否是一个接口，或者目标对象是否为一个代理类。如果是二者之一，则可以直接使用 jdk 的动态代理即可，否则才会使用 Cglib 代理。 【篇幅限制，剩余 6 个设计模式的体现会放在下篇介绍 ~ 小伙伴们记得关注点赞呀，有源码学习需要的可以看我小册 ~ 奥利给】","categories":[{"name":"SpringFramework","slug":"SpringFramework","permalink":"http://yoursite.com/categories/SpringFramework/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Spring的IOC，你真的能解释清楚吗？","slug":"Spring的IOC，你真的能解释清楚吗？","date":"2020-05-18T04:50:55.000Z","updated":"2020-06-28T07:06:38.928Z","comments":true,"path":"2020/05/18/Spring的IOC，你真的能解释清楚吗？/","link":"","permalink":"http://yoursite.com/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/","excerpt":"","text":"一直以来，SpringFramework 作为 Java 企业级开发的老大哥，面试中也常被问到。虽说有些基础性的问题可能不那么特别被面试官和求职者重视，但如果真的问起来，能不能回答的准确、全面、有深度，还是很容易体现出水平的。 在接下来的一个系列中，我会慢慢盘点一些 Spring 中常见但不好回答全面的问题，跟小伙伴们分享。 本文主题：Spring 的 IOC 如何回答的尽可能全面、准确、有深度。 问：什么是IOC？这是一个看上去特别简单、感觉很无脑的问题，很多求职者在回答这个问题时会不加思考、快速回答出一个很简单但同时也没有什么含量的答案。 草率的回答 IOC 是控制反转，Inverse of Control 。 试问一句，亲，你在做名词翻译吗？ 就算真的是在做名词翻译，也不应该只是把这个简称的全称解释出来就完事吧，好歹的展开解释点东西也好吧，作为面试官不应该只想听到这么一点点吧。 方向偏了 IOC 是控制反转，它把对象间的依赖关系的维护权利交给了 Spring ，程序本身不再维护。 这里面大体上把 IOC 的核心思想解释出来了：对象间的依赖关系的维护权利发生了转移，但是请小伙伴们注意，我们在问 IOC ，这个问题仅仅是问 IOC 本身，与具体的技术无关。IOC 不止有 Spring ，只是当下最强大的、使用最广的是 Spring 而已。 所以小伙伴们在回答理论、概念等问题时，不要直接在概念解释中提到具体的技术，技术都是概念和理论的落地实现，不止一种。单把一种拉出来，面试官可能会觉得：你是不是只知道这个？ 一种参考回答 该答案仅供参考，可根据自身的知识储备动态调整。 IOC 全名控制反转 Inverse of Control，它是一种编程原则，它的设计和架构可以实现组件间的解耦，核心思想是将控制权转移出去。 这里面提到了几个点： 编程原则：它是一种理论，而非具体的某种技术落地 组件间的解耦：所谓耦合，就是上面提到的对象间的依赖关系；解耦，就是解除了对象间的依赖关系。 提到解耦，有可能面试官会继续问“什么是解耦”，也有可能不会问 “为什么用 Spring ”了 控制权的转移：IOC 为了实现解耦，将原有的对象间的主动依赖改为被动接收型依赖（由直接 new 变为 set ） 问：IOC与DI的区别如果对 IOC 的实现不是特别了解，或者只是用 SpringFramework 用的太习惯了，亦或是刻板的学习 SpringFramework ，那这个答案通常会是这样的： IOC 就是 DI 。 如果回答出这个答案，而面试官碰巧也跟你一样，那恭喜你“瞎猫碰到死耗子”了！因为这个回答真的大错特错啊，IOC 不止有 DI 的！ 正确的回答应该是： IOC 是一种思想、编程原则，DI 是 IOC 思想的一种实现方式。 IOC 的实现方式有依赖查找（ Dependency lookup ）和依赖注入（ Dependency Injection ）。 上面已经介绍过了，IOC 仅仅是一种思想，它的意图是想让对象间的依赖控制发生转换。用过 SpringFramework 的小伙伴都知道，你没有在哪个地方见过直接写 IOC 的代码，都是由一些实现方式来体现 IOC 的。 如果按照上面这样回答，可能会引来下面一个问题： 依赖查找和依赖注入分别都是什么？如何区分它们？针对这个问题，最好不要一上来就搬出代码解释，最好是先理论后代码。 一般情况下，对比依赖查找和依赖注入，通常可以从以下几个维度对比： 依赖查找 依赖注入 实现方式 使用上下文（容器）主动获取 依赖上下文被动接收 作用目标 通常是方法体内的局部变量，也可以是对象成员 通常是对象成员 API依赖 依赖 IOC 框架的 API（必须操纵容器的 API ） 可以不依赖（暴露 setter 方法即可） applicationContext.getBean(beanName) public void setXXX() { … } 问：SpringFramework中实现的IOC有什么？真的不会有小伙伴只能答出 ApplicationContext 吧，一开始学的时候应该知道还有个 BeanFactory 吧。这是 SpringFramework 中两个核心的 IOC 容器的抽象。BeanFactory 仅仅是提供了一个容器管理的基本能力，ApplicationContext 在此基础上做了更加完善、强大的扩展。具体的对比可以参照下表： Feature BeanFactory ApplicationContext Bean instantiation/wiring —— Bean的实例化和属性注入 Yes Yes Integrated lifecycle management —— 生命周期管理 No Yes Automatic BeanPostProcessor registration —— Bean后置处理器的支持 No Yes Automatic BeanFactoryPostProcessor registration —— BeanFactory后置处理器的支持 No Yes Convenient MessageSource access (for internalization) —— 消息转换服务（国际化） No Yes Built-in ApplicationEvent publication mechanism —— 事件发布机制（事件驱动） No Yes 下面提供一个比较完整的示例答案，小伙伴们可以根据自己的知识储备和理解，调整这里面的一些描述细节： BeanFactory 接口提供了一个抽象的配置和对象的管理机制，ApplicationContext 是 BeanFactory 的子接口，它简化了与 AOP 的整合、消息机制、事件机制，以及对 Web 环境的扩展（ WebApplicationContext 等），BeanFactory 是没有这些扩展的。 ApplicationContext 主要扩展了以下功能：（括号内的部分是解释扩展功能的一些简单描述或者原理底层实现，能回答出来更好） AOP的支持（ AnnotationAwareAspectJAutoProxyCreator 作用于 Bean 的初始化之后 ） 配置元信息（ BeanDefinition 、Environment 、注解等 ） 资源管理（ Resource 抽象 ） 事件驱动机制（ ApplicationEvent 、ApplicationListener ） 消息与国际化（ LocaleResolver ） Environment 抽象（SpringFramework 3.1以后） 问：依赖注入的注入方式？有什么区别？注意这个问题也是与 SpringFramework 无关的，注入的方式本身就应该是依赖注入的实现，至于框架的代码，那是人家对于这个方式的落地。 可从以下几个维度对比： 注入方式 被注入成员是否可变 是否依赖IOC框架的API 使用场景 构造器注入 不可变 否（xml、编程式注入不依赖） 不可变的固定注入 参数注入 不可变 是（只能通过标注注解来侵入式注入） 通常用于不可变的固定注入 setter注入 可变 否（xml、编程式注入不依赖） 可选属性的注入 基本上问这个问题的话，还可能会继续问另一个问题： 你觉得哪种方式好？为什么？“莽夫”应聘者一看终于来开放式问题了，赶紧开始自由发挥了： 我觉得参数注入好，因为我写习惯了，给参数打注解多舒服啊！ 你是这么说了，面试官咋想：就这？就这？？？进而对你的印象可能就会有所减分了。 这种问题，除了要表述主观看法之外，更多的是要根据一些既有的论述来辅助你的观点，最好的论述那一定是官方文档了。 SpringFramework 的官方文档在不同的版本推荐的注入方式是不同的： SpringFramework 4.0.2 及之前是推荐 setter 注入，理由是一个 Bean 有多个依赖时，构造器的参数列表会很长；而且如果 Bean 中依赖的属性不都是必需的话，注入会变得更麻烦； 4.0.3 及以后官方推荐构造器注入，理由是构造器注入的依赖是不可变的、完全初始化好的，且可以保证不为 null ； 当然 4.0.3 及以后的官方文档中也说了，如果真的出现构造器参数列表过长的情况，可能是这个 Bean 承担的责任太多，应该考虑组件的责任拆解。 问：组件注入的注解有什么？有什么区别？相信大多数小伙伴都能答出 @Autowired 和 @Resource 吧，如果答出这两个，那证明你应该用过，也会用。但你能回答出 @Inject ，证明你对这些注入的注解确实有了解。作为应聘者，在回答问题时一定是回答的尽可能全面为好，下面对这几种注解作一个对比： 注解 注入方式 是否支持@Primary 来源 Bean不存在时处理 @Autowired 根据类型注入 是 SpringFramework原生注解 可指定 required=false 来避免注入失败 @Resource 根据名称注入 否 JSR250规范 容器中不存在指定Bean会抛出异常 @Inject 根据类型注入 是 JSR330规范 ( 需要导jar包 ) 容器中不存在指定Bean会抛出异常 跟上面差不多，如果问到了这个问题，那就有可能继续被问到下面一个问题： 存在多个相同类型Bean时如何解决注入问题？可能大多数小伙伴都能答出以下几种解决方案： @Resource ：根据名称指定注入的 Bean @Qualifier ：配合 @Autowired 注解使用，如果被标注的成员 / 方法在根据类型注入时发现有多个相同类型的 Bean ，则会根据该注解声明的 name 寻找特定的 bean @Primary ：配合 @Bean 注解使用，如果有多个相同类型的 Bean 同时注册到 IOC 容器中，使用 @Autowired 、@Inject 注解时会注入标注 @Primary 注解的 bean 其实你还可以提另外一种方案：把注入的字段名与 bean 的名称保持一致，这样也可以解决注入时报不唯一 Bean 的问题。 以上几个问题是关于 SpringFramework 与 IOC 部分的一些常见问题，倒是问题都不太陌生，但是小伙伴们想回答的全面、有深度，还是需要下下功夫的。希望小伙伴们能有所收获，在面试中流利回答，斩获 offer ！ 问题整理不易，不点个赞支持一下作者吗？（可怜巴巴）","categories":[{"name":"SpringFramework","slug":"SpringFramework","permalink":"http://yoursite.com/categories/SpringFramework/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"IOC","slug":"IOC","permalink":"http://yoursite.com/tags/IOC/"}]},{"title":"嵌入式容器：嵌入式Tomcat的优化和配置","slug":"嵌入式容器：嵌入式Tomcat的优化和配置","date":"2019-12-02T12:17:59.000Z","updated":"2020-06-28T07:07:39.607Z","comments":true,"path":"2019/12/02/嵌入式容器：嵌入式Tomcat的优化和配置/","link":"","permalink":"http://yoursite.com/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"在以往的开发中我们可能会根据项目本身对 Tomcat 进行一些调整，以达到最大化利用 Tomcat 的目的。SpringBoot 使用嵌入式 Tomcat，再像之前那样做 Tomcat 性能调优就显得不那么现实了，为此我们需要了解如何在 SpringBoot 内部给嵌入式 Tomcat 做性能调优。本篇文章只做定性的解析，深入到量的控制本文不作详细探讨。 0. 调优前的准备为测试当前 SpringBoot 中嵌入式 Tomcat 的最大性能，需要一个压力测试工具来辅助我们测试性能，目前应用比较多的压测工具有 Bench 和 JMeter ，本文中使用 Bench 作为压测工具。 测试之前，咱先把工具准备好： Bench：https://www.apachelounge.com/download/ JMeter：http://jmeter.apache.org/download_jmeter.cgi 下载好之后，把这两个工具的环境变量都配置好，方便直接从控制台执行。 除此之外，把一开始的测试工程中加入一个测试的 DemoController ，用于接收请求压测（为模拟真实业务场景，会在 DemoController 中让线程随机阻塞 100 - 500ms ，以代替数据库连接和业务查询）。最后，把工程打成可执行jar包并启动，等待测试。 jar包启动的方式非常简单：java -jar demo-0.0.1-SNAPSHOT.jar （本文在进行压测时的物理环境：Windows10 + Intel Core i7-8750H） 1. 使用Bench进行压测在cmd中执行如下命令： ab -n 10000 -c 500 http://localhost:8080/test 执行完成后会在控制台打印测试报告：（报告中的指标解释已标注在行尾） 1This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;2Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/3Licensed to The Apache Software Foundation, http://www.apache.org/45Benchmarking localhost (be patient)6Completed 1000 requests7Completed 2000 requests8Completed 3000 requests9Completed 4000 requests10Completed 5000 requests11Completed 6000 requests12Completed 7000 requests13Completed 8000 requests14Completed 9000 requests15Completed 10000 requests16Finished 10000 requests171819Server Software:20Server Hostname: localhost // 主机名21Server Port: 8080 // 端口号2223Document Path: /test24Document Length: 4 bytes2526Concurrency Level: 500 // 并发量27Time taken for tests: 15.670 seconds // 所有请求的总耗时28Complete requests: 10000 // 成功的请求数29Failed requests: 030Total transferred: 1360000 bytes // 总传输数据量31HTML transferred: 40000 bytes // 总响应数据量32Requests per second: 638.17 [#/sec] (mean) // 【重要】每秒执行的请求数量（吞吐量）33Time per request: 783.493 [ms] (mean) // 【重要】客户端平均响应时间34Time per request: 1.567 [ms] (mean, across all concurrent requests) // 服务器平均请求等待时间35Transfer rate: 84.76 [Kbytes/sec] received // 每秒传输的数据量3637Connection Times (ms)38 min mean[+/-sd] median max39Connect: 0 0 0.2 0 140Processing: 105 738 135.1 742 99341Waiting: 105 738 135.2 742 99342Total: 105 738 135.1 742 9934344Percentage of the requests served within a certain time (ms)45 50% 74246 66% 81047 75% 84748 80% 86849 90% 90950 95% 93151 98% 94552 99% 95253 100% 993 (longest request) 在测试报告中有两个重要的指标需要咱来关注： Requests per second：每秒执行的请求数量（吞吐量） 吞吐量越高，代表性能越好 Time per request：客户端平均响应时间 响应时间越短，代表性能越好 在这里面测得的结果是 638.17 的吞吐量，783.493ms 的平均响应时间，这个响应时间比代码中控制的阻塞时间更长，说明 Tomcat 对500的并发已经有一些吃力了。 下面咱再用更大的并发量来测试效果： ab -n 50000 -c 2000 http://localhost:8080/test 测得的结果（截取主要部分）： 1Concurrency Level: 20002Time taken for tests: 75.689 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 660.60 [#/sec] (mean)8Time per request: 3027.564 [ms] (mean)9Time per request: 1.514 [ms] (mean, across all concurrent requests)10Transfer rate: 87.74 [Kbytes/sec] received 发现吞吐量没有什么太大的变化，但平均响应时间大幅提升，且大概为上面的4倍。可以看得出来，Tomcat 的处理速度已经远远跟不上请求到来的速度，需要进行性能调优。 2. 嵌入式Tomcat调优依据调优一定要有依据，咱根据现状和之前对 SpringBoot 的学习和原理剖析，应该知道配置大多都是两种形式： 声明式配置：application.properties 或 application.yml 编程式配置：XXXConfigurer 或 XXXCustomizer 其中，利用配置文件进行配置，最终会映射到 SpringBoot 中的一些 Properties 类中，例如 server.port 配置会映射到 ServerProperties 类中： 1@ConfigurationProperties(prefix = \"server\", ignoreUnknownFields = true)2public class ServerProperties &#123;3 private Integer port; 那我们来大体分析一下对于 Tomcat 的声明式配置，都有哪些可以控制的部分： 2.1 Tomcat的声明式配置在 ServerProperties 类中，有一个 Tomcat 的静态内部类： 1/**2 * Tomcat properties.3 */4public static class Tomcat &#123;5 // ...... 这里面就是配置嵌入式 Tomcat 的可以供我们配置的映射配置类。咱来看里面的核心属性： 1/**2 * Maximum amount of worker threads.3 * 最大工作线程数4 */5private int maxThreads = 200;67/**8 * Minimum amount of worker threads.9 * 最小工作线程数10 */11private int minSpareThreads = 10;1213/**14 * Maximum number of connections that the server accepts and processes at any15 * given time. Once the limit has been reached, the operating system may still16 * accept connections based on the \"acceptCount\" property.17 * 服务器最大连接数18 */19private int maxConnections = 10000;2021/**22 * Maximum queue length for incoming connection requests when all possible request23 * processing threads are in use.24 * 最大请求队列等待长度25 */26private int acceptCount = 100; 可以发现这里面的几个指标，分别控制连接数、线程数、等待数。 咱来分析为什么上面的吞吐量不够大：请求中的关键耗时动作是 Thread.sheep 卡线程，导致吞吐量变大。Thread.sleep 模拟了IO操作、数据库交互等非CPU高速计算的行为，在数据库交互时，CPU资源被浪费，导致无法处理后来的请求，出现资源利用率低的现象。为此，我们需要提高请求并发数，以此来提高CPU利用率。提高请求并发的方法在上面的几个参数中很明显是 maxThreads 。 3. 调整maxThreads从源码中很明显看到默认的最大线程数是200，我们在 application.properties 中修改值为 500： server.tomcat.max-threads=500 修改之后的测试： 1Concurrency Level: 20002Time taken for tests: 30.910 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 1617.61 [#/sec] (mean)8Time per request: 1236.391 [ms] (mean)9Time per request: 0.618 [ms] (mean, across all concurrent requests)10Transfer rate: 214.84 [Kbytes/sec] received 发现吞吐量有明显的提升，且吞吐量的放大倍数大概是前面线程数为 200 时的2.5倍。继续放大该值为 2000： server.tomcat.max-threads=2000 重新测试效果： 1Concurrency Level: 20002Time taken for tests: 12.050 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 4149.38 [#/sec] (mean)8Time per request: 482.000 [ms] (mean)9Time per request: 0.241 [ms] (mean, across all concurrent requests)10Transfer rate: 551.09 [Kbytes/sec] received 吞吐量又一次明显上升，但注意此时的吞吐量并没有扩大到上一次的 4 倍。继续放大该值为 10000： server.tomcat.max-threads=10000 重新测试效果： 1Concurrency Level: 20002Time taken for tests: 13.808 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 3621.22 [#/sec] (mean)8Time per request: 552.300 [ms] (mean)9Time per request: 0.276 [ms] (mean, across all concurrent requests)10Transfer rate: 480.94 [Kbytes/sec] received 发现吞吐量竟然下降了！为什么会出现这种现象呢？ 4. 现象解释要解释这个原因，就不得不提到 CPU 的工作原理了。当CPU的核心线程数小于当前应用线程时，CPU为了保证所有应用线程都正常执行，它会在多个线程中来回切换，以保证每个线程都能获得CPU时间。在一个确定的时间点中，一个CPU只能处理一个线程。 所以这个现象就可以这样解释：当开启的 Tomcat 线程过多时，CPU会消耗大量时间在这些 Tomcat 线程中来回切换，导致真正处理业务请求的时间变少，最终导致整体应用处理速度变慢。 由此也可以推出另一种可能：如果业务逻辑中有大量CPU处理工作（如运算、处理数据等），则CPU需要更多的时间用于计算，此时若 Tomcat 线程过多，则处理速度会更慢。 5. 总结由上面的情况可以总结出以下结论： 应用中大部分业务逻辑都是阻塞型处理（IO、数据库操作等），这种情况下CPU的压力较低，可以适当调大 maxThreads 的值大小。 应用中大部分业务逻辑都是数据处理和计算，这种情况下CPU的压力较大，应适当调小 maxThreads 的值大小。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"},{"name":"嵌入式容器","slug":"嵌入式容器","permalink":"http://yoursite.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8/"}]}]}