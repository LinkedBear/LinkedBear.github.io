{"meta":{"title":"LinkedBear的GitHub","subtitle":"","description":"LinkedBear的GitHub博客","author":"LinkedBear","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-12-02T11:52:50.000Z","updated":"2019-12-02T12:03:20.257Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一个平凡的码畜我不是什么有身份的人，在圈子里也没什么动静。我只是一个默默研究框架源码以及其中内部原理的草根研究者，闷头翻源码是我喜欢的事情，同样也是我的乐趣。平常工作中，我通常扮演偏架构和偏基础的组件研发，也不是什么很牛的组件贡献者。 机缘巧合的小册我有一个关系很好的小圈子，那些伙计鼓励我写一本 SpringBoot 的小册（毕竟那是我研究最多的框架，没有之一），机缘巧合之下，我联系到了掘金平台，从此开始了我的创作路。小册发布后评价都还不错，感谢小伙伴们的认可和对我的支持，我也会在后续有更多的产出。 寻找我的方式讲真，我也没什么名气，也没有太多的精力去运营公众号等自媒体，所以目前来讲能找到我的办法，可能只有借助掘金小册了。。。后续如果真的我慢慢做大了，那寻找我也会变得容易的多。"},{"title":"juejin","date":"2019-12-02T12:49:54.000Z","updated":"2019-12-02T12:59:58.707Z","comments":true,"path":"juejin/index.html","permalink":"http://yoursite.com/juejin/index.html","excerpt":"","text":"掘金小册的创作由来我有一个关系很好的小圈子，那些伙计鼓励我写一本 SpringBoot 的小册（毕竟那是我研究最多的框架，没有之一），机缘巧合之下，我联系到了掘金平台，从此开始了我的创作路。小册发布后评价都还不错，感谢小伙伴们的认可和对我的支持，我也会在后续有更多的产出。 SpringBoot小册SpringBoot 的小册虽说是第一本小册，里面的内容还是很多的，对 SpringFramework 和 SpringBoot 有深入理解的想法的小伙伴，你可以去读几篇体会一下，如果感觉你喜欢或者你需要的话，不妨买来看看(滑稽)，虽说不贵，但内容绝对超值（已得到多名小伙伴的反馈）。 跳转戳 → https://juejin.im/book/5da3bc3d6fb9a04e35597a76 后续计划SpringBoot 的下一站肯定是 SpringCloud 了，我在 SpringBoot 的最后一章也提到了，我的计划是2020年出 SpringCloud 的源码解读和原理分析的小册，后续如果有更多的计划也会及时更新。"}],"posts":[{"title":"嵌入式容器：嵌入式Tomcat的优化和配置","slug":"嵌入式容器：嵌入式Tomcat的优化和配置","date":"2019-12-02T12:17:59.000Z","updated":"2019-12-02T12:21:25.547Z","comments":true,"path":"2019/12/02/嵌入式容器：嵌入式Tomcat的优化和配置/","link":"","permalink":"http://yoursite.com/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"在以往的开发中我们可能会根据项目本身对 Tomcat 进行一些调整，以达到最大化利用 Tomcat 的目的。SpringBoot 使用嵌入式 Tomcat，再像之前那样做 Tomcat 性能调优就显得不那么现实了，为此我们需要了解如何在 SpringBoot 内部给嵌入式 Tomcat 做性能调优。本篇文章只做定性的解析，深入到量的控制本文不作详细探讨。 0. 调优前的准备为测试当前 SpringBoot 中嵌入式 Tomcat 的最大性能，需要一个压力测试工具来辅助我们测试性能，目前应用比较多的压测工具有 Bench 和 JMeter ，本文中使用 Bench 作为压测工具。 测试之前，咱先把工具准备好： Bench：https://www.apachelounge.com/download/ JMeter：http://jmeter.apache.org/download_jmeter.cgi 下载好之后，把这两个工具的环境变量都配置好，方便直接从控制台执行。 除此之外，把一开始的测试工程中加入一个测试的 DemoController ，用于接收请求压测（为模拟真实业务场景，会在 DemoController 中让线程随机阻塞 100 - 500ms ，以代替数据库连接和业务查询）。最后，把工程打成可执行jar包并启动，等待测试。 jar包启动的方式非常简单：java -jar demo-0.0.1-SNAPSHOT.jar （本文在进行压测时的物理环境：Windows10 + Intel Core i7-8750H） 1. 使用Bench进行压测在cmd中执行如下命令： ab -n 10000 -c 500 http://localhost:8080/test 执行完成后会在控制台打印测试报告：（报告中的指标解释已标注在行尾） 1This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;2Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/3Licensed to The Apache Software Foundation, http://www.apache.org/45Benchmarking localhost (be patient)6Completed 1000 requests7Completed 2000 requests8Completed 3000 requests9Completed 4000 requests10Completed 5000 requests11Completed 6000 requests12Completed 7000 requests13Completed 8000 requests14Completed 9000 requests15Completed 10000 requests16Finished 10000 requests171819Server Software:20Server Hostname: localhost // 主机名21Server Port: 8080 // 端口号2223Document Path: /test24Document Length: 4 bytes2526Concurrency Level: 500 // 并发量27Time taken for tests: 15.670 seconds // 所有请求的总耗时28Complete requests: 10000 // 成功的请求数29Failed requests: 030Total transferred: 1360000 bytes // 总传输数据量31HTML transferred: 40000 bytes // 总响应数据量32Requests per second: 638.17 [#/sec] (mean) // 【重要】每秒执行的请求数量（吞吐量）33Time per request: 783.493 [ms] (mean) // 【重要】客户端平均响应时间34Time per request: 1.567 [ms] (mean, across all concurrent requests) // 服务器平均请求等待时间35Transfer rate: 84.76 [Kbytes/sec] received // 每秒传输的数据量3637Connection Times (ms)38 min mean[+/-sd] median max39Connect: 0 0 0.2 0 140Processing: 105 738 135.1 742 99341Waiting: 105 738 135.2 742 99342Total: 105 738 135.1 742 9934344Percentage of the requests served within a certain time (ms)45 50% 74246 66% 81047 75% 84748 80% 86849 90% 90950 95% 93151 98% 94552 99% 95253 100% 993 (longest request) 在测试报告中有两个重要的指标需要咱来关注： Requests per second：每秒执行的请求数量（吞吐量） 吞吐量越高，代表性能越好 Time per request：客户端平均响应时间 响应时间越短，代表性能越好 在这里面测得的结果是 638.17 的吞吐量，783.493ms 的平均响应时间，这个响应时间比代码中控制的阻塞时间更长，说明 Tomcat 对500的并发已经有一些吃力了。 下面咱再用更大的并发量来测试效果： ab -n 50000 -c 2000 http://localhost:8080/test 测得的结果（截取主要部分）： 1Concurrency Level: 20002Time taken for tests: 75.689 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 660.60 [#/sec] (mean)8Time per request: 3027.564 [ms] (mean)9Time per request: 1.514 [ms] (mean, across all concurrent requests)10Transfer rate: 87.74 [Kbytes/sec] received 发现吞吐量没有什么太大的变化，但平均响应时间大幅提升，且大概为上面的4倍。可以看得出来，Tomcat 的处理速度已经远远跟不上请求到来的速度，需要进行性能调优。 2. 嵌入式Tomcat调优依据调优一定要有依据，咱根据现状和之前对 SpringBoot 的学习和原理剖析，应该知道配置大多都是两种形式： 声明式配置：application.properties 或 application.yml 编程式配置：XXXConfigurer 或 XXXCustomizer 其中，利用配置文件进行配置，最终会映射到 SpringBoot 中的一些 Properties 类中，例如 server.port 配置会映射到 ServerProperties 类中： 1@ConfigurationProperties(prefix = \"server\", ignoreUnknownFields = true)2public class ServerProperties &#123;3 private Integer port; 那我们来大体分析一下对于 Tomcat 的声明式配置，都有哪些可以控制的部分： 2.1 Tomcat的声明式配置在 ServerProperties 类中，有一个 Tomcat 的静态内部类： 1/**2 * Tomcat properties.3 */4public static class Tomcat &#123;5 // ...... 这里面就是配置嵌入式 Tomcat 的可以供我们配置的映射配置类。咱来看里面的核心属性： 1/**2 * Maximum amount of worker threads.3 * 最大工作线程数4 */5private int maxThreads = 200;67/**8 * Minimum amount of worker threads.9 * 最小工作线程数10 */11private int minSpareThreads = 10;1213/**14 * Maximum number of connections that the server accepts and processes at any15 * given time. Once the limit has been reached, the operating system may still16 * accept connections based on the \"acceptCount\" property.17 * 服务器最大连接数18 */19private int maxConnections = 10000;2021/**22 * Maximum queue length for incoming connection requests when all possible request23 * processing threads are in use.24 * 最大请求队列等待长度25 */26private int acceptCount = 100; 可以发现这里面的几个指标，分别控制连接数、线程数、等待数。 咱来分析为什么上面的吞吐量不够大：请求中的关键耗时动作是 Thread.sheep 卡线程，导致吞吐量变大。Thread.sleep 模拟了IO操作、数据库交互等非CPU高速计算的行为，在数据库交互时，CPU资源被浪费，导致无法处理后来的请求，出现资源利用率低的现象。为此，我们需要提高请求并发数，以此来提高CPU利用率。提高请求并发的方法在上面的几个参数中很明显是 maxThreads 。 3. 调整maxThreads从源码中很明显看到默认的最大线程数是200，我们在 application.properties 中修改值为 500： server.tomcat.max-threads=500 修改之后的测试： 1Concurrency Level: 20002Time taken for tests: 30.910 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 1617.61 [#/sec] (mean)8Time per request: 1236.391 [ms] (mean)9Time per request: 0.618 [ms] (mean, across all concurrent requests)10Transfer rate: 214.84 [Kbytes/sec] received 发现吞吐量有明显的提升，且吞吐量的放大倍数大概是前面线程数为 200 时的2.5倍。继续放大该值为 2000： server.tomcat.max-threads=2000 重新测试效果： 1Concurrency Level: 20002Time taken for tests: 12.050 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 4149.38 [#/sec] (mean)8Time per request: 482.000 [ms] (mean)9Time per request: 0.241 [ms] (mean, across all concurrent requests)10Transfer rate: 551.09 [Kbytes/sec] received 吞吐量又一次明显上升，但注意此时的吞吐量并没有扩大到上一次的 4 倍。继续放大该值为 10000： server.tomcat.max-threads=10000 重新测试效果： 1Concurrency Level: 20002Time taken for tests: 13.808 seconds3Complete requests: 500004Failed requests: 05Total transferred: 6800000 bytes6HTML transferred: 200000 bytes7Requests per second: 3621.22 [#/sec] (mean)8Time per request: 552.300 [ms] (mean)9Time per request: 0.276 [ms] (mean, across all concurrent requests)10Transfer rate: 480.94 [Kbytes/sec] received 发现吞吐量竟然下降了！为什么会出现这种现象呢？ 4. 现象解释要解释这个原因，就不得不提到 CPU 的工作原理了。当CPU的核心线程数小于当前应用线程时，CPU为了保证所有应用线程都正常执行，它会在多个线程中来回切换，以保证每个线程都能获得CPU时间。在一个确定的时间点中，一个CPU只能处理一个线程。 所以这个现象就可以这样解释：当开启的 Tomcat 线程过多时，CPU会消耗大量时间在这些 Tomcat 线程中来回切换，导致真正处理业务请求的时间变少，最终导致整体应用处理速度变慢。 由此也可以推出另一种可能：如果业务逻辑中有大量CPU处理工作（如运算、处理数据等），则CPU需要更多的时间用于计算，此时若 Tomcat 线程过多，则处理速度会更慢。 5. 总结由上面的情况可以总结出以下结论： 应用中大部分业务逻辑都是阻塞型处理（IO、数据库操作等），这种情况下CPU的压力较低，可以适当调大 maxThreads 的值大小。 应用中大部分业务逻辑都是数据处理和计算，这种情况下CPU的压力较大，应适当调小 maxThreads 的值大小。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"Tomcat, 嵌入式容器, SpringBoot","slug":"Tomcat-嵌入式容器-SpringBoot","permalink":"http://yoursite.com/tags/Tomcat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8-SpringBoot/"}]}]}