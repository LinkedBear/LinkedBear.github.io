<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【不懂就问】SpringFramework中的注解声明式事务怎么被Shiro搞失效了</title>
      <link href="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/"/>
      <url>/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>【<strong>“不懂就问”</strong>，是一个新的系列，主要整理我的小册群里遇到的一些比较有意思的 / 有难度的 / 容易被讨论起来的问题，并给出问题的解析和方案等等。喜欢的小伙伴们可以点赞关注我鸭 ~ ~ 学习源码可以看看我的小册 ~ ~】</p><p>近期我在 SpringBoot 的小册交流群里碰见一个问题，感觉蛮有意思的，拿出来跟小伙伴们分享一下。</p><h2 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h2><p>那位小伙伴的项目中，有<strong>一部分 Service 的注解事务一直不起作用</strong>，但也只是一部分起作用，<strong>也有一部分是好的</strong>。而且更奇怪的是，如果他把一个事务不起作用的 ServiceImpl 代码完整的抄一遍到新的复制类里头，那个类居然是有事务的！</p><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>咱回想一下，按常理来讲，SpringFramework 中的事务不生效，大概有这么几种情况：</p><ul><li><code>@Transactional</code> 注解标注在非 public 方法上</li><li><code>@Transactional</code> 注解标注在接口上，但实现类使用 Cglib 代理</li><li><code>@Transactional</code> 注解标注抛出 <code>Exception</code> ，默认不捕捉</li><li>service 方法中自行 <code>try-catch</code> 了异常但没有再抛出 <code>RuntimeException</code> </li><li>原生 SSM 开发中，父子容器一起包扫描，会导致子容器先扫描到 service 并注册到子容器中但不加载事务，之后虽然父容器也扫描到 service 但因为子容器中的 controller 已经注入了没有事务代理的 service ，会导致事务失效</li><li>声明式事务的配置必须由父 IOC 容器加载，SpringWebMvc 的子 IOC 容器加载不生效</li></ul><p>除此之外，如果使用的关系型数据库是 MySQL ，还要关注是否为 InnoDB 引擎（ MyISAM 不支持事务）。</p><p>结果小伙伴一通分析，发现这上面罗列的情况都没有出现，排查难度进一步加大。</p><h2 id="新的关注点"><a href="#新的关注点" class="headerlink" title="新的关注点"></a>新的关注点</h2><p>隔了大概半天吧，那位小伙伴突然发现了一点问题：他们的项目使用了 <strong>Shiro</strong> 作为权限校验框架，而且那些<strong>事务失效的 Service 刚好就是被 Shiro 中自定义 Realm 依赖的 Service</strong> ！有了这个线索，下面排查起来就容易一些了。</p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>咱也自己搞一套，看看是不是像他说的那样吧！</p><h4 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h4><p>为了快速复现这个问题，咱使用 SpringBoot + <code>shiro-spring-boot-web-starter</code> 构建。( SpringBoot 版本只要在 2.x 就可以，本文测试功能选用 2.2.8 )</p><h5 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h5><p>关键的依赖有下面 4 个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.199<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure><h5 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h5><p>Shiro 的自定义策略核心就是 <strong><code>Realm</code></strong> ，咱也不整那些花里胡哨的，直接糊弄下算了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (token.getPrincipal() == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        String name = token.getPrincipal().toString();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 请求数据库查询是否存在用户，这里省略</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(name, <span class="string">"123456"</span>, getName());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 请求数据库/缓存加载用户的权限，这里暂时使用一组假数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        authorizationInfo.addStringPermissions(Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> authorizationInfo;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><p>只声明 Realm 还不够，需要定义几个 Bean 来补充必需的组件才行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 自定义Realm注册</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> CustomRealm <span class="title">authorizer</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomRealm();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 动态代理创建器（上面没有导入AOP）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">advisorAutoProxyCreator</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        advisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> advisorAutoProxyCreator;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 过滤器定义，此处选择全部放行，方便调试</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterChainDefinition <span class="title">filterChainDefinition</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        DefaultShiroFilterChainDefinition filterChainDefinition = <span class="keyword">new</span> DefaultShiroFilterChainDefinition();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        filterChainDefinition.addPathDefinition(<span class="string">"/**"</span>, <span class="string">"anon"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> filterChainDefinition;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h5><p>快速搭建临时测试的、结构很简单的数据库，选择 h2 内存数据库更为合适。</p><p><code>application.properties</code> 中配置 h2 的数据源及初始化数据库的 SQL ：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">org.h2.Driver</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:h2:mem:shiro-test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">sa</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">sa</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">h2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.schema</span>=<span class="string">classpath:sql/schema.sql</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.data</span>=<span class="string">classpath:sql/data.sql</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.h2.console.settings.web-allow-others</span>=<span class="string">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.h2.console.path</span>=<span class="string">/h2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.h2.console.enabled</span>=<span class="string">true</span></span></pre></td></tr></table></figure><p><code>resources</code> 目录下创建 sql 文件夹，并创建两个 .sql 文件，分别声明数据库表的结构和数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> sys_department (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">---</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idaaa'</span>, <span class="string">'testaaa'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idbbb'</span>, <span class="string">'testbbb'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idccc'</span>, <span class="string">'testccc'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sys_department (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="string">'idddd'</span>, <span class="string">'testddd'</span>);</span></pre></td></tr></table></figure><h4 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h4><p>下面就可以按照三层架构来写一些很简单的测试代码了。</p><h5 id="DemoDao"><a href="#DemoDao" class="headerlink" title="DemoDao"></a>DemoDao</h5><p>这里咱就不整合 MyBatis / Hibernate 了，直接使用原生的 <code>JdbcTemplate</code> 就可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoDao</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    JdbcTemplate jdbcTemplate;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; findAll() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(<span class="string">"select * from sys_department"</span>, <span class="keyword">new</span> ColumnMapRowMapper());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(String name)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> jdbcTemplate.update(<span class="string">"insert into sys_department (id, name) values (?, ?)"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>, <span class="string">""</span>), name);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> jdbcTemplate.update(<span class="string">"update sys_department set name = ? where id = ?"</span>, name, id);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="DemoService-DemoService2"><a href="#DemoService-DemoService2" class="headerlink" title="DemoService + DemoService2"></a>DemoService + DemoService2</h5><p>声明一个会触发抛出运行时异常的方法，并标注 <code>@Transactional</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    DemoDao demoDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">doTransaction</span>() </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        demoDao.save(<span class="string">"aaaaaaaa"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        demoDao.update(<span class="string">"18"</span>, <span class="string">"ccc"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><code>DemoService2</code> 同样的代码，仅仅是类名不同，代码不再贴出。</p><h5 id="DemoController"><a href="#DemoController" class="headerlink" title="DemoController"></a>DemoController</h5><p>Controller 里面同时依赖这两个 Service ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    DemoService demoService;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    DemoService2 demoService2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/doTransaction"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doTransaction</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        demoService.doTransaction();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"doTransaction"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/doTransaction2"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doTransaction2</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        demoService2.doTransaction();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"doTransaction2"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="Realm依赖Service"><a href="#Realm依赖Service" class="headerlink" title="Realm依赖Service"></a>Realm依赖Service</h4><p>最后，让自定义的 Realm 依赖咱刚写的 <code>DemoService</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    DemoService demoService;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr></table></figure><h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>运行 SpringBoot 的主启动类，在浏览器输入 <code>http://localhost:8080/h2</code> 输入刚才在 properties 文件中声明的配置，即可打开 h2 数据库的管理台。</p><p>执行 <code>SELECT * FROM SYS_DEPARTMENT</code> ，可以发现数据已经成功初始化了：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592959256988.png" alt="1592959256988"></p><p>下面测试事务，在浏览器输入 <code>localhost:8080/doTransaction</code> ，浏览器自然会报除零异常，但刷新数据库，会发现数据库真的多了一条 insert 过去的数据！请求 <code>/doTransaction2</code> 则不会插入新的数据。</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592959284044.png" alt="1592959284044"></p><p>到这里，问题就真的发生了，下面要想办法解决这个问题才行。</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>既然两个 Service 在代码上完全一致，只是一个被 Realm 依赖了，一个没有依赖而已，那总不能是这两个 Service 本来就不一样吧！</p><h4 id="检查两个Service对象"><a href="#检查两个Service对象" class="headerlink" title="检查两个Service对象"></a>检查两个Service对象</h4><p>将断点打在 <code>/doTransaction</code> 对应的方法上，Debug 重新启动工程，待断点落下后，发现被 Realm 依赖的 <code>DemoService</code> 不是代理对象，而没有被 Realm 依赖的 <code>DemoService2</code> 经过事务的增强，成为了一个代理对象：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592916608297.png" alt="1592916608297"></p><p>所以由此就可以看到问题所在了吧！上面的那个 <code>DemoService</code> 都没经过事务代理，凭什么能支持事务呢？？？</p><h4 id="检查Service的创建时机"><a href="#检查Service的创建时机" class="headerlink" title="检查Service的创建时机"></a>检查Service的创建时机</h4><p>既然两个 Service 都不是一个样的，那咱就看看这俩对象都啥时候创建的吧！给 <code>DemoService</code> 上显式的添加上无参构造方法，方便过会 Debug ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoService</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"DemoService constructor run ......"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><p>重新以 Debug 运行，等断点打在构造方法中，观察方法调用栈：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592917238145.png" alt="1592917238145"></p><p>看上去还比较正常吧，但如果往下拉到底，这问题就太严重了：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592917282785.png" alt="1592917282785"></p><p>哦，合着我这个 <code>DemoService</code> 在 <strong><code>refresh</code> 方法的后置处理器注册步骤就已经创建好了</strong>啊！小伙伴们要知道，SpringFramework 中 <code>ApplicationContext</code> 的初始化流程，一定是<strong>先把后置处理器都注册好了，再创建单实例 Bean</strong> 。但是这里很明显是后置处理器还没完全处理完，就引发单实例 Bean 的创建了！</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>问题终于找明白了，咋解决呢？其实网上有的是现成的文章了：</p><p><a href="https://blog.csdn.net/hzw2312/article/details/81030277" target="_blank" rel="noopener">spring boot shiro 事务无效</a></p><p><a href="https://blog.csdn.net/yucaifu1989/article/details/79206369" target="_blank" rel="noopener">shiro导致springboot事务不起效解决办法</a></p><p><a href="https://blog.csdn.net/keliii/article/details/80051688" target="_blank" rel="noopener">spring + shiro 配置中部分事务失效分析及解决方案</a></p><p>总的来看，解决方案的核心在于：如何让 <code>Realm</code> 创建时不立即依赖创建 <code>DemoService</code> ，所以就有两种解决方案了：要么延迟初始化 <code>DemoService</code> ，要么<strong>把自定义的 <code>Realm</code> 和 <code>SecurityManager</code> 放在一个额外的空间，利用监听器机制创建它们</strong> 。具体的实现可以参照上面文章的写法，这里就不赘述了。</p><h2 id="原理扩展"><a href="#原理扩展" class="headerlink" title="原理扩展"></a>原理扩展</h2><p>解决问题之后，如果能从这里面了解到一点更深入的原理知识，想必那是最好不过了。下面就这个问题出现的原因，以及上面 <code>@Lazy</code> 方案的原理，咱都深入解析一下。</p><h4 id="Shiro提早创建Realm的原因"><a href="#Shiro提早创建Realm的原因" class="headerlink" title="Shiro提早创建Realm的原因"></a>Shiro提早创建Realm的原因</h4><p>既然上面看到了方法调用栈中，<code>DemoService</code> 被自定义 <code>Realm</code> 依赖后在 <code>ApplicationContext</code> 的 <code>refresh</code> 阶段的 <strong><code>registerBeanPostProcessors</code></strong> 中就已经被触发创建，可它为什么非要搞这一出呢？自定义 <code>Realm</code> 放到 <strong><code>finishBeanFactoryInitialization</code></strong> 中统一创建不好吗？下面咱通过 Debug 研究问题的成因。</p><h5 id="Debug运行"><a href="#Debug运行" class="headerlink" title="Debug运行"></a>Debug运行</h5><p><code>DemoService</code> 中的断点不要去掉，重新 Debug 让断点停在那里，翻到最底下的调用栈，查看那个正在创建的 <code>BeanPostProcessor</code> ，发现它的名称是 <code>shiroEventBusAwareBeanPostProcessor</code> ：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592959800675.png" alt="1592959800675"></p><h5 id="Shiro的后置处理器创建"><a href="#Shiro的后置处理器创建" class="headerlink" title="Shiro的后置处理器创建"></a>Shiro的后置处理器创建</h5><p>翻开创建 <code>shiroEventBusAwareBeanPostProcessor</code> 的位置，在 <code>ShiroBeanAutoConfiguration</code> 中，它又依赖了一个 <code>EventBus</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ShiroEventBusBeanPostProcessor <span class="title">shiroEventBusAwareBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.shiroEventBusAwareBeanPostProcessor();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ShiroEventBusBeanPostProcessor <span class="title">shiroEventBusAwareBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ShiroEventBusBeanPostProcessor(eventBus());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>顺着方法调用栈往上爬，找到下一个 <code>doCreateBean</code> ，发现确实有创建 <code>eventBus</code> 的部分：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592962300364.png" alt="1592962300364"></p><p>再往上爬，发现这上面有一个 <code>wrapIfNecessary</code> 方法的调用，很明显这是要搞 <strong>AOP</strong> 增强了啊：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592962353901.png" alt="1592962353901"></p><p>AOP 的增强需要先获取到增强器，继续往上爬方法调用，在 <code>findAdvisorBeans</code> 方法中找到了两个适配的增强器：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592962931169.png" alt="1592962931169"></p><p>上面的是 Shiro 的授权相关的增强器，下面是 SpringFramework 中的事务控制增强器。</p><h5 id="触发AOP增强器的创建"><a href="#触发AOP增强器的创建" class="headerlink" title="触发AOP增强器的创建"></a>触发AOP增强器的创建</h5><p>根据迭代顺序，先取出下面的事务控制增强器 <code>TransactionAdvisor</code> ，由于获取到增强器的 Bean 也是需要走统一的 <code>getBean</code> 方法，所以在方法调用栈中，咱又一次看到了 <code>getBean</code> 方法，继续往下创建。</p><p>由于在 SpringFramework 中，使用 <code>@Configuration</code> + <code>@Bean</code> 声明的 Bean ，都是要<strong>先把配置类初始化好，才能创建 Bean</strong> 。所以继续往上爬调用栈时，会发现它并没有接着创建 Shiro 的增强器 <code>authorizationAttributeSourceAdvisor</code> ，而是先初始化了声明有 <code>TransactionAttributeSourceAdvisor</code> 的配置类 <code>ProxyTransactionManagementConfiguration</code> ：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592963447497.png" alt="1592963447497"></p><p>再往上走，发现又出现了一次 <code>wrapIfNecessary</code> 方法，说明<strong>配置类也会被 AOP 增强</strong>。那就重复一遍上面的步骤，继续遇到这两个增强器。</p><p>这个时候可能有小伙伴产生疑问了：这次创建就是因为上面的 <code>TransactionAttributeSourceAdvisor</code> 创建才跟过来的，这次还要再创建，这是闹哪出呢？放心，咱都想到这个问题了，人家写 SpringFramework 的大佬们能想不到吗？所以在创建之前，它加了一个判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果当前bean正在创建，则跳过</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        logger.trace(<span class="string">"Skipping currently created advisor '"</span> + name + <span class="string">"'"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor<span class="class">.<span class="keyword">class</span>))</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><p>这里巧妙的利用了 <strong><code>singletonsCurrentlyInCreation</code></strong> 这个集合，判断了当前增强器是否在创建，这样就不会出现重复创建无限死循环的问题了。</p><blockquote><p><code>singletonsCurrentlyInCreation</code> 的存放是在 <code>getSingleton</code> 方法调用时就已经放进去了，所以能很稳妥的记录下当前正在创建的所有 Bean ，防止死循环重复创建。</p></blockquote><h5 id="Shiro增强器的创建"><a href="#Shiro增强器的创建" class="headerlink" title="Shiro增强器的创建"></a>Shiro增强器的创建</h5><p>上面的事务控制增强器跳过去了，那就可以创建 Shiro 的增强器了：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592963883656.png" alt="1592963883656"></p><p>这次没有再出现那些幺蛾子，但是这个增强器本身依赖一个 <code>SecurityManager</code> ：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592963942464.png" alt="1592963942464"></p><p>那就继续创建呗，创建 <code>SecurityManager</code> 的过程中又出现了新的依赖：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592964032857.png" alt="1592964032857"></p><p>这个 <code>authorizer</code> ，就是咱上面在 <code>ShiroConfiguration</code> 中注册的自定义 <code>Realm</code> 。</p><p>看到这里了，后续的步骤想必不用我说小伙伴们也能自己想到了吧：<strong>Realm 的创建又需要依赖 <code>DemoService</code> ，而 <code>DemoService</code> 在创建时由于事务控制增强器还没有创建好，所以无法代理 <code>DemoService</code> ，最终注入到 Realm 的 <code>DemoService</code> 就是不带事务的</strong>。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>捋一捋整个流程哈，整个创建过程经历了以下几个层级的依赖创建：</p><ol><li><p><code>ApplicationContext</code> 的 <code>refresh</code> 方法要创建 <code>BeanPostProcessor</code> </p></li><li><p><code>ShiroEventBusBeanPostProcessor</code> 的创建需要依赖 <code>EventBus</code></p></li><li><p><code>EventBus</code> 创建时需要被 AOP 增强，触发 AOP 增强器的创建逻辑</p><blockquote><p>此时 AOP 增强器有 2 个，分别是事务控制增强器，和 Shiro 的增强器</p></blockquote></li><li><p>首先创建事务控制的 AOP 增强器 <code>TransactionAttributeSourceAdvisor</code> ，由于它定义在配置类中，又触发配置类的创建</p></li><li><p>配置类创建时也要被 AOP 增强，再一次触发 AOP 增强器的创建逻辑</p><blockquote><p>此时事务控制增强器正在被创建，所以被跳过了</p></blockquote></li><li><p>触发 Shiro 增强器的创建，而 Shiro 增强器又依赖 <code>SecurityManager</code></p></li><li><p><code>SecurityManager</code> 又依赖 <code>authorizer</code> ，也就是自定义的 <code>Realm</code> </p></li><li><p>自定义 <code>Realm</code> 依赖 <code>DemoService</code> ，触发 <code>DemoService</code> 的创建</p></li><li><p><code>DemoService</code> 创建后要被事务 AOP 增强，但此时事务控制增强器还没有完全创建好，所以无法代理，导致 <code>DemoService</code> 不带事务</p></li></ol><h4 id="Lazy解决该问题的原理"><a href="#Lazy解决该问题的原理" class="headerlink" title="@Lazy解决该问题的原理"></a>@Lazy解决该问题的原理</h4><p>上面解决方案的第三篇文章，他提到可以用 <code>@Lazy</code> 注解解决问题，我在翻文章时有人说不能用（他把 <code>@Lazy</code> 注解标注到 <code>DemoService</code> 类上了），讲道理可能是他不会用才这么说的（￣へ￣）。其实用 <code>@Lazy</code> 注解是完全可行的，不过标注的位置要对，真正要标注的位置是自定义 <code>Realm</code> 的 <code>DemoService</code> 成员上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">DemoService demoService;</span></pre></td></tr></table></figure><p>下面咱解释下为什么 <code>@Lazy</code> 标注在自定义 <code>Realm</code> 的依赖上好用，标注在 <code>DemoService</code> 类上不好用。</p><h5 id="测试-Lazy标注在DemoService上"><a href="#测试-Lazy标注在DemoService上" class="headerlink" title="测试-@Lazy标注在DemoService上"></a>测试-@Lazy标注在DemoService上</h5><p>将 <code>@Lazy</code> 注解标注到 <code>DemoService</code> 的类上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span></span></span></pre></td></tr></table></figure><p>重新 Debug ，发现断点落在 <code>DemoService</code> 的构造方法时，<code>refresh</code> 的动作仍然停在 <code>registerBeanPostProcessors</code> 步骤，说明将 <code>@Lazy</code> 标注在 <code>DemoService</code> 上是不可行的，这也就是上面我提的那个文章里说 <code>@Lazy</code> 不可行。</p><h5 id="测试-Lazy标注在自定义Realm的依赖上"><a href="#测试-Lazy标注在自定义Realm的依赖上" class="headerlink" title="测试-@Lazy标注在自定义Realm的依赖上"></a>测试-@Lazy标注在自定义Realm的依赖上</h5><p>去掉上面 <code>DemoService</code> 类上的 <code>@Lazy</code> ，在自定义 <code>Realm</code> 的 <code>DemoService</code> 依赖上标注，重新 Debug，观察断点停下时 <code>refresh</code> 执行的步骤：</p><p><img src="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/1592966236460.png" alt="1592966236460"></p><p>可以发现已经到了可以正常初始化单实例 Bean 的时机了，此时创建的 <code>DemoService</code> 就不会有问题了。</p><p>放行断点，待应用启动完成后，浏览器再发送 <code>/doTransaction</code> 的请求，发现这次事务已经生效了。</p><p>到这里，就验证了 <code>@Lazy</code> 的正确使用方法。</p><p>但是！！！不要着急！下面咱再扩展一点原理哈 ~ ~ ~</p><p>想一下，此时这个 <code>DemoService</code> 是啥玩意触发创建的？</p><p>答案很明显是 <strong><code>DemoController</code></strong> ，因为 Controller 还依赖着 Service 呢。</p><h5 id="测试-Lazy标注Realm-Controller"><a href="#测试-Lazy标注Realm-Controller" class="headerlink" title="测试-@Lazy标注Realm+Controller"></a>测试-@Lazy标注Realm+Controller</h5><p>继续测试，把自定义 <code>Realm</code> 和 <code>DemoController</code> 两个类的 <code>DemoService</code> 依赖都标注上 <code>@Lazy</code> ，重新 Debug ，待断点停下后，想一下此时 <code>DemoService</code> 又是谁触发它创建的呢？</p><p>答案也不难猜，是 <strong>IOC 容器本身</strong>创建的，因为 <code>DemoService</code> 所有被依赖的关系都延迟加载了，但 <strong>IOC 容器本身还要预先创建好所有的单实例 Bean</strong> ，所以 <code>DemoService</code> 还是在 IOC 容器启动的过程中创建了。</p><h5 id="测试-Lazy全标注"><a href="#测试-Lazy全标注" class="headerlink" title="测试-@Lazy全标注"></a>测试-@Lazy全标注</h5><p>继续，这次把 <code>DemoService</code> 上也标注上 <code>@Lazy</code> ，重新 Debug ，这次应用没有落在断点上直接启动了，说明 IOC 容器本身发现 <code>DemoService</code> 也可以延迟创建，就跳过去了，所以 IOC 容器初始化的全过程中 <code>DemoService</code> 都没有创建。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>总结一下 <code>@Lazy</code> 的使用规则和对应的原理：</p><ul><li><code>@Lazy</code> 标注在 Bean 的类上：告诉 IOC 容器，在<strong>容器初始化阶段不要实例化</strong>我</li><li><code>@Lazy</code> 标注在其他 Bean 的依赖上：告诉 IOC 容器，在创建这个标注了 <code>@Lazy</code> 的 Bean 时，<strong>不要立即处理</strong>我标注的这个<strong>依赖</strong></li></ul><p>本文涉及到的所有源码可以从 GitHub 中找到：<a href="https://github.com/LinkedBear/juejin-posts-sources" target="_blank" rel="noopener">https://github.com/LinkedBear/juejin-posts-sources</a></p><p>【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】</p>]]></content>
      
      
      <categories>
          
          <category> 不懂就问 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Shiro </tag>
            
            <tag> 声明式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中使用的设计模式，你都能说全吗？[下]</title>
      <link href="/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F%5B%E4%B8%8B%5D/"/>
      <url>/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F%5B%E4%B8%8B%5D/</url>
      
        <content type="html"><![CDATA[<p>这是 Spring 面试题系列的第二篇 【Spring 中的设计模式】 下半部分，</p><p>本篇只回答一个问题：</p><h2 id="Spring-中使用了哪些设计模式？分别都是如何实现的？"><a href="#Spring-中使用了哪些设计模式？分别都是如何实现的？" class="headerlink" title="Spring 中使用了哪些设计模式？分别都是如何实现的？"></a>Spring 中使用了哪些设计模式？分别都是如何实现的？</h2><p>回顾一下上一篇的概述，从整体上讲，SpringFramework 中使用了 11 种设计模式：</p><ul><li><strong>单例模式+原型模式</strong></li><li><strong>工厂模式</strong></li><li><strong>代理模式</strong></li><li><strong>策略模式</strong></li><li><strong>模板方法模式</strong></li><li><strong>观察者模式</strong></li><li><strong>适配器模式</strong></li><li><strong>装饰者模式</strong></li><li><strong>外观模式</strong></li><li><strong>委派模式</strong>（不属于GoF23）</li></ul><p>这一篇咱把下面的 6 个设计模式也详细解析一下。</p><blockquote><p>喜欢本文的小伙伴不要忘记点赞呀 ~ ~ ~ 三克油！！！</p></blockquote><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式，在 SpringFramework 中使用的那是相当的多啊！即便是初学 SpringFramework ，在学习到 jdbc 部分，也应该接触过一个模板方法模式的体现，就是 <code>JdbcTemplate</code> 的回调机制：（贴两个比较常见的经典方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result(query(sql, <span class="keyword">new</span> RowMapperResultSetExtractor&lt;&gt;(rowMapper)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql) <span class="keyword">throws</span> DataAccessException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> query(sql, getColumnMapRowMapper());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在调用时，只需要一句话就够了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; datas = jdbcTemplate.queryForList(<span class="string">"select * from user"</span>);</span></pre></td></tr></table></figure><p>小伙伴们可能会一脸懵，这么个方法就体现模板方法模式了吗？我也看不出来啊？莫慌，下面咱先回顾下原生 jdbc 的操作步骤，慢慢自然就明白了。</p><h4 id="原生jdbc使用步骤"><a href="#原生jdbc使用步骤" class="headerlink" title="原生jdbc使用步骤"></a>原生jdbc使用步骤</h4><p>原生的 jdbc 操作需要以下这么多步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册驱动</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">PreparedStatement statement = connection.prepareStatement(<span class="string">"select * from user"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装结果数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; datas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    data.put(<span class="string">"id"</span>, resultSet.getString(<span class="string">"id"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    data.put(<span class="string">"name"</span>, resultSet.getString(<span class="string">"name"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    datas.add(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">resultSet.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">statement.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">connection.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回/输出数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">System.out.println(datas);</span></pre></td></tr></table></figure><p>但是，这里面的操作有很多是重复的，所以这一段代码可以抽取为几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; encapsulate(ResultSet resultSet) <span class="keyword">throws</span> SQLException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; datas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        data.put(<span class="string">"id"</span>, resultSet.getString(<span class="string">"id"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        data.put(<span class="string">"name"</span>, resultSet.getString(<span class="string">"name"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        datas.add(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> datas;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection connection, PreparedStatement statement, ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    resultSet.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    statement.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    connection.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>如此下来，主干代码就只剩下这些了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Connection connection = getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    PreparedStatement statement = connection.prepareStatement(<span class="string">"select * from user"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装结果数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; datas = encapsulate(resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    close(connection, statement, resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回/输出数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    System.out.println(datas);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>那最后稍微调整一下，就可以成为一个通用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; query(String sql, List&lt;Object&gt; params) <span class="keyword">throws</span> Exception &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Connection connection = getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    PreparedStatement statement = connection.prepareStatement(sql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 填充占位符参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        statement.setObject(i + <span class="number">1</span>, params.get(i));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装结果数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; datas = encapsulate(resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    close(connection, statement, resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> datas;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>目前这个方法已经可以通用了，不过只能返回 Map ，如果想返回模型类对象怎么办呢？这样咱就可以扩展一个自定义结果集封装的方法，让调用者自己决定如何封装。再次改动的代码可以像如下优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql, List&lt;Object&gt; params, Function&lt;ResultSet, List&lt;T&gt;&gt; encapsulate)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Connection connection = getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    PreparedStatement statement = connection.prepareStatement(sql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 填充占位符参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        statement.setObject(i + <span class="number">1</span>, params.get(i));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装结果数据（借助Function接口实现结果集封装）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    List&lt;T&gt; datas = encapsulate.apply(resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    close(connection, statement, resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> datas;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看最后一个参数，我让方法的调用者传一个 <code>Function&lt;ResultSet, List&lt;T&gt;&gt;</code> 类型的自定义处理逻辑，这样返回的数据究竟是什么类型我也就不用管了，完全由调用者自己决定。</p><p>到这里，模板方法模式就得以体现了，整个查询的动作我只需要让方法调用者传 SQL 、SQL 中可能出现的参数，以及自定义的结果集封装逻辑，其余的动作都不需要方法调用者关注。</p><p>可是，这跟 <code>JdbcTemplate</code> 又有什么关系呢？？？</p><h4 id="JdbcTemplate中体现的模板方法"><a href="#JdbcTemplate中体现的模板方法" class="headerlink" title="JdbcTemplate中体现的模板方法"></a>JdbcTemplate中体现的模板方法</h4><p>我上面不是摘出来一个 <code>JdbcTemplate</code> 的方法嘛：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result(query(sql, <span class="keyword">new</span> RowMapperResultSetExtractor&lt;&gt;(rowMapper)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>咱点进去看 <code>query</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// assert logger ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title">StatementCallback</span>&lt;<span class="title">T</span>&gt;, <span class="title">SqlProvider</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            ResultSet rs = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                rs = stmt.executeQuery(sql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> rse.extractData(rs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                JdbcUtils.closeResultSet(rs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> sql;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> execute(<span class="keyword">new</span> QueryStatementCallback());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>注意看方法参数列表的最后一个：<code>ResultSetExtractor</code> ，它是一个函数式接口，而且它只有一个方法，就是<strong>根据结果集返回泛型类型的数据</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetExtractor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">extractData</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException, DataAccessException</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>是不是这个设计跟我上面演示的思路基本一致了？这就是 <code>JdbcTemplate</code> 中体现的模板方法模式。</p><p>除了这些 <code>xxxTemplate</code> 中有体现，其实在 SpringFramework 中的最底层 IOC 容器模型，<code>BeanFactory</code> 和 <code>ApplicationContext</code> ，以及 SpringWebMvc 中的 <code>HandlerMapping</code> 、<code>HandlerAdapter</code> 等等，都有很多模板方法模式的体现。下面咱也举两个例子来体会。</p><h4 id="ApplicationContext中体现的模板方法"><a href="#ApplicationContext中体现的模板方法" class="headerlink" title="ApplicationContext中体现的模板方法"></a>ApplicationContext中体现的模板方法</h4><p>说到 <code>ApplicationContext</code> ，最经典的方法莫过于 <code>AbstractApplicationContext</code> 中的 <code>refresh</code> ：（只截取很少的一部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            onRefresh();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="comment">// catch finally ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在这个方法中有一个动作是 <code>onRefresh</code> 方法，点进去发现它是一个空方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Template method which can be overridden to add context-specific refresh work.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Called on initialization of special beans, before instantiation of singletons.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * &lt;p&gt;This implementation is empty.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of errors</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// For subclasses: do nothing by default.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>注意看文档注释的前两个单词：<strong>Template method</strong> ！！！文档注释已经告诉咱这是一个模板方法了！而且方法体中也说了，<strong>它默认不做任何事情，留给子类扩展使用。</strong>由此咱就可以了解 <code>ApplicationContext</code> 中最经典的模板方法模式设计之一了。</p><h4 id="HandlerMapping中体现的模板方法"><a href="#HandlerMapping中体现的模板方法" class="headerlink" title="HandlerMapping中体现的模板方法"></a>HandlerMapping中体现的模板方法</h4><p>在 <code>DispatcherServlet</code> 接收到客户端的请求，要进行实际处理时，需要先根据 uri 寻找能匹配的 <code>HandlerMapping</code> ，这一步它会委托 <code>HandlerMapping</code> 帮忙找（这里面涉及到委派了，下面会讲到），而这个寻找 <code>HandlerMapping</code> 的动作在 <code>AbstractHandlerMapping</code> 的 <code>getHandler</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Object handler = getHandlerInternal(request);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        handler = getDefaultHandler();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里面第一句就会调另一个 <code>getHandlerInternal</code> 方法，而这个方法在 <code>AbstractHandlerMapping</code> 中是自己定义的抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span></pre></td></tr></table></figure><p>这就是非常经典的模板方法模式的体现了：<strong>父类 / 抽象类把逻辑步骤都定义出来，具体的动作让子类实现</strong>。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中体现的模板方法模式非常多，包括各种 Template （ <code>JdbcTemplate</code> 、<code>HibernateTemplate</code> 、<code>RedisTemplate</code> 等），以及核心源码内部设计的模板方法（如 <code>AbstractApplicationContext</code> 中的 <code>refresh</code> 套 <code>onRefresh</code> 、<code>AbstractHandlerMapping</code> 中的 <code>getHandler</code> 套 <code>getHandlerInternal</code> 等），它设计的核心思想是父类 / 抽象类把逻辑步骤都定义出来，具体的动作让子类实现。</strong></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><strong>观察者模式</strong>，也被称为<strong>发布订阅模式</strong>，其实它还有一个叫法：<strong>监听器模式</strong>。那说到监听器，是不是就立马想起来 SpringFramework 中的 <strong><code>ApplicationListener</code></strong> 了？对了，就这么回事，其实都不用展开讲，小伙伴们也能答得出来了。不过，想回答的漂亮，还需要额外知道一点点东西。</p><h4 id="观察者模式的核心"><a href="#观察者模式的核心" class="headerlink" title="观察者模式的核心"></a>观察者模式的核心</h4><p>咱都知道，观察者模式的两大核心是：<strong>观察者、被观察主题</strong>。对应到 SpringFramework 中的概念分别是：<strong>事件、监听器</strong>。</p><p>不过我个人比较喜欢把 SpringFramework 的事件驱动核心概念划分为 4 个：<strong>事件源、事件、广播器、监听器</strong>。</p><ul><li><strong>事件源：发布事件的对象</strong></li><li><strong>事件：事件源发布的信息</strong></li><li><strong>广播器：事件真正广播给监听器的对象</strong>【即 <strong><code>ApplicationContext</code></strong> 】<ul><li><code>ApplicationContext</code> 接口有实现 <code>ApplicationEventPublisher</code> 接口，具备<strong>事件广播器的发布事件的能力</strong></li></ul></li><li><strong>监听器：监听事件的对象</strong></li></ul><p>在 SpringFramework 中，<strong>事件源想要发布事件，需要注入事件广播器，通过事件广播器来广播事件</strong>。</p><h4 id="SpringFramework使用监听器"><a href="#SpringFramework使用监听器" class="headerlink" title="SpringFramework使用监听器"></a>SpringFramework使用监听器</h4><p>以下是一个最简单的监听器使用实例：</p><h5 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceEvent</span><span class="params">(Object source)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">super</span>(source);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventService</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ApplicationContext ctx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        ctx.publishEvent(<span class="keyword">new</span> ServiceEvent(<span class="keyword">this</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext ctx)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h5 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ServiceEvent</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ServiceEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"监听到ServiceEvent事件："</span> + event);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中实现的观察者模式就是事件驱动机制，可以通过自定义监听器，监听不同的事件，完成不同的业务处理。</strong></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>了解 SpringWebMvc 中 <code>DispatcherServlet</code> 的工作原理，应该对 <code>HandlerAdapter</code> 不陌生，它就是辅助执行 Controller 中具体方法的<strong>适配器</strong>。如果只答这一句当然够用，不过回答的再细致点，那自然是更好的。</p><h4 id="DispatcherServlet委派HandlerAdapter"><a href="#DispatcherServlet委派HandlerAdapter" class="headerlink" title="DispatcherServlet委派HandlerAdapter"></a>DispatcherServlet委派HandlerAdapter</h4><p>在 <code>DispatcherServlet</code> 的 <code>doDispatch</code> 方法中，有一句代码是根据 <code>HandlerMapping</code> 中的 <code>Handler</code> 获取 <code>HandlerAdapter</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span></pre></td></tr></table></figure><p>这个 <strong>Handler</strong> 就是<strong>目标 Controller 中的目标方法</strong>，在适配的过程中它会寻找现有的所有 <code>HandlerAdapter</code> 是否能支持执行这个 Handler ，根据 <code>RequestMappingHandlerMapping</code> 的命名，自然也能猜得出来，真正负责执行目标 Controller 中方法的是 <strong><code>RequestMappingHandlerAdapter</code></strong> 。</p><h4 id="HandlerAdapter执行Handler"><a href="#HandlerAdapter执行Handler" class="headerlink" title="HandlerAdapter执行Handler"></a>HandlerAdapter执行Handler</h4><p>在 <code>RequestMappingHandlerAdapter</code> 中，执行目标 Controller 中方法的核心方法是 <code>handle</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看到了 <code>handleInternal</code> ，是不是又想到了<strong>模板方法</strong>？没错，就是这个设计。</p><p>在底层，核心的执行 Handler 的逻辑其实就是<strong>反射</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ReflectionUtils.makeAccessible(getBridgedMethod());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// method.invoke</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>由此可知，<code>HandlerAdapter</code> 的执行其实也没有很神秘，最终还是玩的反射而已。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中的适配器模式，体现之一是 <code>HandlerAdapter</code> 辅助执行目标 Controller 中的方法，底层是借助反射执行。</strong></p><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰者跟代理、适配器都有些相似，不过<strong>装饰者</strong>更强调的是<strong>在原有的基础上附加额外的动作 / 方法 / 特性</strong>，而<strong>代理模式</strong>有<strong>控制内部对象访问</strong>的意思。</p><p>SpringFramework 中体现的装饰者模式，在核心源码中并没有体现，不过在缓存模块 spring-cache 中倒是有一个体现：<strong><code>TransactionAwareCacheDecorator</code></strong> 。</p><h4 id="Bean的包装"><a href="#Bean的包装" class="headerlink" title="Bean的包装"></a>Bean的包装</h4><p>了解过 Bean 的创建流程，应该知道最底层的创建动作发生在 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>doCreateBean</code>  中，而这里面第一波动作就把 <code>BeanWrapper</code> 都创建好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Instantiate the bean.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure><p>注意看，它创建的动作是 <code>createBeanInstance</code> ，意为“创建 bean 实例”，那就可以理解为：<strong>bean 对象已经在这个动作下实例化好了</strong>。深入这个方法，最终可以在 <code>createBeanInstance</code> 方法的最后一句 return 中看到 bean 实例的创建，以及 <code>BeanWrapper</code> 的包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        Object beanInstance;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 实例化对象......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        initBeanWrapper(bw);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> bw;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看到下面的代码中，它把 bean 的实例对象包装为一个 <code>BeanWrapper</code> ，形成装饰者。</p><h4 id="SpringCache的核心设计"><a href="#SpringCache的核心设计" class="headerlink" title="SpringCache的核心设计"></a>SpringCache的核心设计</h4><p>SpringCache 主做的是应用业务层级的缓存，它与 JSR107 有一定关系但又不同（Spring 自己实现了一套缓存，就是这个 SpringCache ）。</p><p>用一张简单的图解释 SpringCache 的核心，大概可以这样理解：</p><p><img src="/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8B]/1592051318911.png" alt></p><p>一个 <code>CacheManager</code> 中包含多个 <code>Cache</code> ，一个 <code>Cache</code> 可以简单理解为一个 <strong>Map&lt;String, T&gt;</strong> 。</p><p>从 <code>Cache</code> 接口的设计，也能看出来就是 <strong><code>Map</code></strong> 的思路：（核心方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">ValueWrapper <span class="title">get</span><span class="params">(Object key)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Object key, @Nullable Object value)</span></span>;</span></pre></td></tr></table></figure><h4 id="Cache的装饰者体现"><a href="#Cache的装饰者体现" class="headerlink" title="Cache的装饰者体现"></a>Cache的装饰者体现</h4><p><code>TransactionAwareCacheDecorator</code> 作为装饰者，那肯定要实现 Cache 接口，并且组合一个 Cache 的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAwareCacheDecorator</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache targetCache;</span></pre></td></tr></table></figure><p>这里面，真正体现装饰者的位置是在 <code>put</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">final</span> Object key, @Nullable <span class="keyword">final</span> Object value)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                TransactionAwareCacheDecorator.<span class="keyword">this</span>.targetCache.put(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.targetCache.put(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可以发现，它会在 <strong>put 之前，检查当前线程中是否存在已经开启的事务</strong>：如果存在事务，则会将 put 操作注册到<strong>事务结束后</strong>。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中实现的装饰者模式，体现之一是在 SpringCache 缓存的存放逻辑中，如果执行缓存时的线程中存在事务，则缓存的保存会在事务结束后再执行。</strong></p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式算是比较简单的模式，它强调的是<strong>统一入口，内部组合</strong>。一个经典的体现是在 IOC 解析 Bean 的定义信息时使用的 <code>BeanDefinitionLoader</code> 。</p><p>在 <code>BeanDefinitionLoader</code> 中，它组合了 4 种不同类型的解析器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionLoader</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 注解式Bean定义解析器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader annotatedReader;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// xml文件的Bean定义解析器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader xmlReader;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Groovy的Bean定义解析器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BeanDefinitionReader groovyReader;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 类路径的Bean定义扫描器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span></pre></td></tr></table></figure><p>尽管组合的解析器很多，但最终暴露出来的方法是同样的名：<code>load</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Class&lt;?&gt; source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(GroovyBeanDefinitionSource source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Resource source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Package source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(CharSequence source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr></table></figure><p>由此可以体现出很经典的外观模式。</p><h3 id="委派模式"><a href="#委派模式" class="headerlink" title="委派模式"></a>委派模式</h3><p>委派模式本不属于 GoF23 中的设计模式，不过既然咱在前面也反复提到过几次，这里咱还是摘出来说两句。</p><p>在 <code>DispatcherServlet</code> 的核心工作流程中，委派模式体现在 <code>HandlerMapping</code> 、<code>HandlerAdapter</code> 、<code>ViewResolver</code> 接受 <code>DispatcherServlet</code> 的委派，如下面的整体流程图：</p><p><img src="/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8B]/DispatcherServlet%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt></p><p>到这里，SpringFramework 中使用的设计模式就差不多整理完了，想要回答的尽可能全面、准确、有深度，小伙伴们要好好理解这些模式的设计、思想，以及 SpringFramework 中的源码实现，这样在被面试官问到才会更加游刃有余。</p><p>【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】</p>]]></content>
      
      
      <categories>
          
          <category> SpringFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中使用的设计模式，你都能说全吗？[上]</title>
      <link href="/2020/06/09/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F%5B%E4%B8%8A%5D/"/>
      <url>/2020/06/09/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F%5B%E4%B8%8A%5D/</url>
      
        <content type="html"><![CDATA[<p>这是 Spring 面试题系列的第二篇，本文的主题：Spring 中涉及到的<strong>设计模式</strong>，如何在面试中回答的尽可能全面、准确、有深度。</p><p>本篇只回答一个问题：</p><h2 id="Spring-中使用了哪些设计模式？分别都是如何实现的？"><a href="#Spring-中使用了哪些设计模式？分别都是如何实现的？" class="headerlink" title="Spring 中使用了哪些设计模式？分别都是如何实现的？"></a>Spring 中使用了哪些设计模式？分别都是如何实现的？</h2><p>首先作一个概述，从整体上讲，SpringFramework 中使用了 11 种设计模式：</p><ul><li><strong>单例模式+原型模式</strong></li><li><strong>工厂模式</strong></li><li><strong>代理模式</strong></li><li><strong>策略模式</strong></li><li><strong>模板方法模式</strong></li><li><strong>观察者模式</strong></li><li><strong>适配器模式</strong></li><li><strong>装饰者模式</strong></li><li><strong>外观模式</strong></li><li><strong>委派模式</strong>（不属于GoF23）</li></ul><p>当然，如果只是这么回答，面试官会怎么想：你这。。。不会是在<strong>背答案</strong>吧！随便揪出一个来细问，可能就翻皮水了 ~ ~ 所以咱不光要知道用了啥，而且还要知道如何用的，在哪里用的，这样才能用自己真正的技术储备征服面试官。</p><p>下面咱详细的介绍 11 种设计模式的设计场景和原理。</p><blockquote><p>由于 11 种设计模式全部展开篇幅过长，会分成两篇专栏介绍。</p></blockquote><h3 id="单例模式-原型模式"><a href="#单例模式-原型模式" class="headerlink" title="单例模式+原型模式"></a>单例模式+原型模式</h3><p>SpringFramework 的 IOC 容器中放了很多很多的 Bean ，默认情况下，Bean 的作用域（ Scope ）是 <strong><code>singleton</code></strong> ，就是单实例的；如果显式声明作用域为 <strong><code>prototype</code></strong> ，那 Bean 的作用域就会变为每次获取都是一个新的，即原型 Bean 。这个知识点本应该在 SpringFramework 最基础阶段就应该知道的，咱也不多啰嗦。关键的问题是，如果我定义的 Bean 声明了 prototype ，那 SpringFramework 肯定知道我要搞原型 Bean ；但我定义 Bean 的时候没声明 Scope ，它怎么就给我默认成单实例的呢？</p><p>下面咱先从最熟悉的 Bean 注册场景出发。（原型模式相对简单，内容已穿插在解释单例模式之中）</p><h4 id="Bean的注册"><a href="#Bean的注册" class="headerlink" title="Bean的注册"></a>Bean的注册</h4><h5 id="xml方式注册Bean"><a href="#xml方式注册Bean" class="headerlink" title="xml方式注册Bean"></a>xml方式注册Bean</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.demo.bean.Person"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span></pre></td></tr></table></figure><p>这是最最简单的 Bean 的注册了，这里面如果显式声明了 <code>scope=&quot;singleton&quot;</code> 后，IDE 会报黄（警告）：</p><p><img src="/2020/06/09/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8A]/Snipaste_2020-06-09_10-03-38.png" alt></p><p>很明显它提示了默认值就是 <code>singleton</code> ，咱没必要再主动声明了。这个提示是 IDEA 智能识别的，咱不好找出处，不过咱可以点进去这个 scope ，看一眼 xsd 中的注释：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"scope"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>&lt;![CDATA[</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">The scope of this bean: typically "singleton" (one shared instance,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">which will be returned by all calls to getBean with the given id), ......</span></pre></td></tr></table></figure><p>很明显文档注释的第一句就说了：<strong>通常它是 <code>singleton</code> 的</strong>。</p><h5 id="注解驱动注册Bean"><a href="#注解驱动注册Bean" class="headerlink" title="注解驱动注册Bean"></a>注解驱动注册Bean</h5><p>注解驱动的方式，都是使用一个 <code>@Scope</code> 注解来声明作用域的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>点开 <code>@Scope</code> 注解看源码，可以发现只标注 <code>@Scope</code> 注解，不声明作用域，默认值是空字符串（不是 <code>singleton</code> ）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scope &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"scopeName"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span></pre></td></tr></table></figure><p>这个地方可能就会有疑惑了，它声明的是空字符串，可是在 xml 中我配置的是 <code>singleton</code> 啊，这怎么不一样呢？莫慌，下面咱来解析这其中的原因。</p><h5 id="默认的作用域标注"><a href="#默认的作用域标注" class="headerlink" title="默认的作用域标注"></a>默认的作用域标注</h5><p>对 SpringFramework 有一些深入了解的小伙伴应该能意识到我接下来要说什么了：<strong><code>BeanDefinition</code></strong> 。所有 Bean 的定义信息都被 SpringFramework 封装到 <code>BeanDefinition</code> 中了，而作用域的定义就在 <code>BeanDefinition</code> 的抽象实现类 <strong><code>AbstractBeanDefinition</code></strong> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanMetadataAttributeAccessor</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BeanDefinition</span>, <span class="title">Cloneable</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCOPE_DEFAULT = <span class="string">""</span>;</span></pre></td></tr></table></figure><p>这里面一上来就声明了默认的作用域就是空字符串，不是 <code>singleton</code> 。</p><p>这个时候可能有的小伙伴就更迷惑了，这里面它都声明了单实例 Bean 是空字符串，那 <code>singleton</code> 还有个卵用呢？判断单实例 Bean 不是应该看作用域是否为 <code>singleton</code> 吗？</p><p>哎，说到这里了，那咱就看看 <code>BeanDefinition</code> 中是如何获取作用域的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getScope</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.scope;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>获取作用域的方式非常简单，这个没啥看的。但是！！！注意继续往下翻，紧跟着下面有一个方法叫 <strong><code>isSingleton</code></strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Return whether this a &lt;b&gt;Singleton&lt;/b&gt;, with a single shared instance</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * returned from all calls.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@see</span> #SCOPE_SINGLETON</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> SCOPE_SINGLETON.equals(<span class="keyword">this</span>.scope) || SCOPE_DEFAULT.equals(<span class="keyword">this</span>.scope);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看这里面的判断，它分为了两个部分：<strong>是否是 singleton ，或者是否为空串！</strong>那这就说得过去了吧，人家设置成空串，意义上也是单实例 Bean 。</p><h4 id="Bean的实例化"><a href="#Bean的实例化" class="headerlink" title="Bean的实例化"></a>Bean的实例化</h4><p>上面咱也知道了，默认情况下 Bean 是单实例的，那 SpringFramework 在 IOC 容器初始化的时候，是如何知道这些 Bean 是否是单实例的，同时初始化并保存的呢？下面咱跟进底层初始化逻辑中看一眼。</p><blockquote><p>本部分只粗略介绍 Bean 的初始化流程，详细的解析可以参照我的 SpringBoot 源码小册 14 章详细学习。</p></blockquote><p>在 <code>AbstractBeanFactory</code> 中，<code>getBean</code> 方法会调用到 <strong><code>doGetBean</code></strong> ，这个方法的篇幅非常长，这里只剪出框框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    Object bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 最开始先检查单实例对象缓存池中是否已经有对应的bean了</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    Object sharedInstance = getSingleton(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 检查 ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Create bean instance.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 单实例Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                    &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 原型Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// It's a prototype -&gt; create a new instance.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                    beforePrototypeCreation(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// 必定创建全新的对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">                    afterPrototypeCreation(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 自定义scope</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">                String scopeName = mbd.getScope();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (T) bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>仔细阅读这个框框流程，一上来它就要先检查单实例对象的缓存池中是否有现成的 Bean 了，没有再往下走。那咱说创建流程的话还是往下走，在 else 块的 try 部分，它会取出当前 Bean 的 <code>BeanDefinition</code> 来判断作用域：如果是 <strong>singleton 单实例</strong>的，就<strong>执行 <code>getSingleton</code> 方法创建单实例对象</strong>（底层走 lambda 表达式中的 <code>createBean</code> 方法）；如果是 <strong>prototype</strong> 原型 Bean ，就执行原型 Bean 的创建流程（直接创建）；如果这些都不是，那就可以认定为<strong>自定义 scope</strong> ，使用特殊的初始化流程。</p><p>所以由此看下来，单实例 Bean 的创建核心方法还是 <code>getSingleton</code> 了，那咱就进到这里面看一眼：（还是只有大框框的流程哈）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 检查</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                singletonObject = singletonFactory.getObject();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                newSingleton = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="comment">// catch finally ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                addSingleton(beanName, singletonObject);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> singletonObject;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>注意看这里面的设计：它会先去单实例对象缓存池中找是否已经有对应的 bean 了，如果没有，就执行创建 bean 的动作。在<strong>创建完成后</strong>，它还会<strong>将 bean 放入缓存池</strong>中，这样以后再取的时候就不会再二次创建了。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>所以这里面的核心逻辑也就可以总结出来了：</p><p><strong>SpringFramework 中实现的单例模式，是在 <code>BeanDefinition</code> 中默认配置 singleton 的作用域，在 IOC 容器初始化阶段，将 Bean 创建好，放入单实例对象缓存池（ <code>singletonObjects</code> ）中，实现 Bean 的单实例。</strong></p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>提起工厂模式，在 SpringFramework 中最容易联想到的就是 <code>FactoryBean</code> 了吧！但其实 SpringFramework 中不止这一个是工厂，还有很多种其他的，下面咱来列举。</p><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p><code>FactoryBean</code> 本身是一个接口，它本身就是一个创建对象的工厂。如果一个类实现了 <code>FactoryBean</code> 接口，则它本身将不再是一个普通的 bean 对象，不会在实际的业务逻辑中起作用，而是由创建的对象来起作用。</p><p><code>FactoryBean</code> 接口有三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回创建的对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回创建的对象的类型（即泛型类型）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    Class&lt;?&gt; getObjectType();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 创建的对象是单实例Bean还是原型Bean，默认单实例</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h4 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h4><p>这种方式很像咱在最开始学习<strong>简单工厂模式</strong>中看到的核心工厂，比方说下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 简单工厂</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calculator <span class="title">getCalculator</span><span class="params">(String operationType)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">switch</span> (operationType) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> AddCalculator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SubtractCalculator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">default</span>: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 静态工厂</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calculator <span class="title">getAddCalculator</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AddCalculator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>在 SpringFramework 中使用静态工厂，就没有参数这个说法了，只需要声明工厂类和方法即可（所以上面的工厂中我额外写了一个方法）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"addCalculator"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.bean.CalculatorFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAddCalculator"</span>/&gt;</span></span></pre></td></tr></table></figure><p>这样注册后得到的 bean ，类型是 <code>AddCalculator</code> 。</p><h4 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h4><p>实例工厂的使用方式与静态工厂很像，只不过<strong>静态工厂本身不会注册到 IOC 容器中，但实例工厂会一起注册到 IOC 容器</strong>。</p><p>调整上面的代码，就可以实现实例工厂的 Bean 注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 工厂方法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Calculator <span class="title">getAddCalculator</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AddCalculator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"calculatorFactory"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.bean.CalculatorFactory"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"addCalculator"</span> <span class="attr">factory-bean</span>=<span class="string">"calculatorFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAddCalculator"</span>/&gt;</span></span></pre></td></tr></table></figure><h4 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h4><p>这个类型可能有些小伙伴会感觉有些陌生，所以我放到了最后写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>结构比 <code>FactoryBean</code> 简单，当然也可以简单地将其理解为 <code>FactoryBean</code> ，但又与其不同。<code>ObjectFactory</code> 一般情况下会<strong>作为一个 Bean 注入到其他 Bean 中</strong>，在需要用对应的 bean 时主动调用 <code>ObjectFactory</code> 的 <code>getObject</code> 方法<strong>获取真正需要的 Bean</strong> ；<code>FactoryBean</code> 的 <code>getObject</code> 方法是在 SpringFramework 初始化 Bean 时调用的，所以由此也可以知道两者的<strong>调用时机也不一样</strong>。</p><p>其实这个接口在上面看 <strong>Bean 的实例化过程</strong>中就遇到过了，在 <code>getSingleton</code> 的两参数方法中，第二个参数就是 <code>ObjectFactory</code> 类型，由它就可以调用 <code>createBean</code> 创建出单实例对象。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中的工厂模式包括内置的 <code>FactoryBean</code> 、<code>ObjectFactory</code> ，以及自定义声明的静态工厂、实例工厂。</strong></p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>咱都知道，SpringFramework 的两大核心：IOC 、AOP ，AOP 就是体现了代理模式的使用。不过如果只说 AOP 体现了代理模式，那这个也太没水准了，咱要回答的更多更全，才能让面试官意识到你真的有研究过，你真的很懂！</p><h4 id="AOP的底层实现"><a href="#AOP的底层实现" class="headerlink" title="AOP的底层实现"></a>AOP的底层实现</h4><p>SpringFramework 中对 Bean 进行 AOP 增强生成代理对象，核心是一个 <code>BeanPostProcessor</code> ：<strong><code>AnnotationAwareAspectJAutoProxyCreator</code></strong> ，这个名字很长，不过很好记：</p><ul><li>Annotation：注解式，</li><li>Aware：注入式</li><li>AspectJ：基于 AspectJ 的 AOP</li><li>AutoProxy：自动代理</li><li>Creator：创建器</li></ul><p>这样一拆分，是不是感觉容易理解多了呢？</p><p>它的核心作用方法是父类 <code>AbstractAutoProxyCreator</code> 的 <strong><code>postProcessAfterInitialization</code></strong> 方法，底层会调用 <code>wrapIfNessary</code> 方法创建代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 创建AOP代理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>至于再往底下，这个就麻烦大了，这里简单总结一下吧，详尽的代理对象创建可以参考 SpringBoot 源码小册的 19 章学习。</p><p><strong>被 AOP 增强的 Bean ，会在初始化阶段（此时对象已经创建）被 <code>AnnotationAwareAspectJAutoProxyCreator</code> 处理，整合该 Bean 可能被覆盖到的切面，最终根据 Bean 是否有接口实现，采用 jdk 动态代理或者 Cglib 动态代理构建生成代理对象。</strong></p><h4 id="代理对象的创建"><a href="#代理对象的创建" class="headerlink" title="代理对象的创建"></a>代理对象的创建</h4><p>上面的总结中提到了最终的动态代理创建，这里可以带小伙伴看一眼最底层你们熟悉的创建代理对象的源码。</p><p>jdk 动态代理的创建，在 <strong><code>JdkDynamicAopProxy</code></strong> 中，有一个 <code>getProxy</code> 方法，底层实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        logger.trace(<span class="string">"Creating JDK dynamic proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// jdk原生方法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看最后一句，是不是突然熟悉了！这个地方就可以在面试中拿出来吹一吹，这样面试官可能就真的认为你把这部分原理都搞明白了哦（狗头）。</p><p>Cglib 动态代理的创建，在 <code>CglibAopProxy</code> 的 <code>createProxyClassAndInstance</code> 方法中有创建代理对象的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    enhancer.setInterceptDuringConstruction(<span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    enhancer.setCallbacks(callbacks);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.constructorArgTypes != <span class="keyword">null</span> ?</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            enhancer.create(<span class="keyword">this</span>.constructorArgTypes, <span class="keyword">this</span>.constructorArgs) :</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            enhancer.create());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>看到这里的 <code>Enhancer#create()</code> 方法，是不是又是熟悉的一幕呢？所以由此也知道，框架也只是在咱学过的基础上层层包装增强罢了，最底层的还是不变的。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中的代理模式体现在 AOP 上，它通过后置处理器，整合切面（增强器 Advice ）的逻辑，将原有的 Bean （目标对象 Target ）使用 jdk 或者 Cglib 动态代理增强为代理 Bean 。</strong></p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>说起 SpringFramework 中实现的策略模式，其实刚刚就提到了：AOP 生成代理对象时，会<strong>根据原始 Bean 是否有接口实现，决定使用 jdk 动态代理还是 Cglib 动态代理</strong>，这就是典型的策略模式体现。</p><p>直接说原理吧，在 <code>DefaultAopProxyFactory</code> 中有策略模式的体现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                    <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 策略判断</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>中间的这个判断当前要代理的目标对象，类型是否是一个接口，或者目标对象是否为一个代理类。如果是二者之一，则可以直接使用 jdk 的动态代理即可，否则才会使用 Cglib 代理。</p><p>【篇幅限制，剩余 6 个设计模式的体现会放在下篇介绍 ~ 小伙伴们记得关注点赞呀，有源码学习需要的可以看我小册 ~ 奥利给】</p>]]></content>
      
      
      <categories>
          
          <category> SpringFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的IOC，你真的能解释清楚吗？</title>
      <link href="/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/"/>
      <url>/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>一直以来，SpringFramework 作为 Java 企业级开发的老大哥，面试中也常被问到。虽说有些基础性的问题可能不那么特别被面试官和求职者重视，但如果真的问起来，能不能回答的准确、全面、有深度，还是很容易体现出水平的。</p><p>在接下来的一个系列中，我会慢慢盘点一些 Spring 中常见但不好回答全面的问题，跟小伙伴们分享。</p><p>本文主题：Spring 的 IOC 如何回答的尽可能全面、准确、有深度。</p><h2 id="问：什么是IOC？"><a href="#问：什么是IOC？" class="headerlink" title="问：什么是IOC？"></a>问：什么是IOC？</h2><p>这是一个看上去特别简单、感觉很无脑的问题，很多求职者在回答这个问题时会不加思考、快速回答出一个很简单但同时也没有什么含量的答案。</p><h4 id="草率的回答"><a href="#草率的回答" class="headerlink" title="草率的回答"></a>草率的回答</h4><ul><li>IOC 是控制反转，Inverse of Control 。</li></ul><p>试问一句，亲，你在做名词翻译吗？</p><p><img src="/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/%E8%A1%A8%E6%83%85%E5%8C%85-%EF%BC%9F%EF%BC%9F%EF%BC%9F.jpg" alt></p><p>就算真的是在做名词翻译，也不应该只是把这个简称的全称解释出来就完事吧，好歹的展开解释点东西也好吧，作为<strong>面试官不应该只想听到这么一点点</strong>吧。</p><h4 id="方向偏了"><a href="#方向偏了" class="headerlink" title="方向偏了"></a>方向偏了</h4><ul><li>IOC 是控制反转，它把对象间的依赖关系的维护权利交给了 Spring ，程序本身不再维护。</li></ul><p>这里面大体上把 IOC 的核心思想解释出来了：<strong>对象间的依赖关系的维护权利发生了转移</strong>，但是请小伙伴们注意，我们在问 IOC ，<strong>这个问题仅仅是问 IOC 本身，与具体的技术无关</strong>。<strong>IOC 不止有 Spring</strong> ，只是当下最强大的、使用最广的是 Spring 而已。</p><p>所以小伙伴们在<strong>回答理论、概念等问题时，不要直接在概念解释中提到具体的技术，技术都是概念和理论的落地实现，不止一种</strong>。单把一种拉出来，面试官可能会觉得：你是不是只知道这个？</p><h4 id="一种参考回答"><a href="#一种参考回答" class="headerlink" title="一种参考回答"></a>一种参考回答</h4><blockquote><p>该答案仅供参考，可根据自身的知识储备动态调整。</p></blockquote><p>IOC 全名<strong>控制反转</strong> Inverse of Control，它是一种<strong>编程原则</strong>，它的设计和架构可以实现<strong>组件间的解耦</strong>，核心思想是<strong>将控制权转移出去</strong>。</p><p>这里面提到了几个点：</p><ul><li>编程原则：它是一种<strong>理论</strong>，而非具体的某种技术落地</li><li>组件间的解耦：所谓<strong>耦合</strong>，就是上面提到的<strong>对象间的依赖关系</strong>；<strong>解耦</strong>，就是<strong>解除了对象间的依赖关系</strong>。<ul><li>提到解耦，有可能面试官会继续问“什么是解耦”，也有可能不会问 “为什么用 Spring ”了</li></ul></li><li>控制权的转移：IOC 为了实现解耦，将原有的对象间的<strong>主动依赖改为被动接收型依赖</strong>（由直接 new 变为 set ）</li></ul><h2 id="问：IOC与DI的区别"><a href="#问：IOC与DI的区别" class="headerlink" title="问：IOC与DI的区别"></a>问：IOC与DI的区别</h2><p>如果对 IOC 的实现不是特别了解，或者只是用 SpringFramework 用的太习惯了，亦或是刻板的学习 SpringFramework ，那这个答案通常会是这样的：</p><ul><li>IOC 就是 DI 。</li></ul><p>如果回答出这个答案，而面试官碰巧也跟你一样，那恭喜你“瞎猫碰到死耗子”了！因为这个回答真的<strong>大错特错</strong>啊，IOC 不止有 DI 的！</p><p>正确的回答应该是：</p><ul><li><strong>IOC 是一种思想、编程原则，DI 是 IOC 思想的一种实现方式。</strong></li><li><strong>IOC 的实现方式有依赖查找（ Dependency lookup ）和依赖注入（ Dependency Injection ）。</strong></li></ul><p>上面已经介绍过了，IOC 仅仅是一种思想，它的意图是想让对象间的依赖控制发生转换。用过 SpringFramework 的小伙伴都知道，你没有在哪个地方见过直接写 IOC 的代码，都是由一些实现方式来体现 IOC 的。</p><p>如果按照上面这样回答，可能会引来下面一个问题：</p><h3 id="依赖查找和依赖注入分别都是什么？如何区分它们？"><a href="#依赖查找和依赖注入分别都是什么？如何区分它们？" class="headerlink" title="依赖查找和依赖注入分别都是什么？如何区分它们？"></a>依赖查找和依赖注入分别都是什么？如何区分它们？</h3><p>针对这个问题，最好不要一上来就搬出代码解释，最好是先理论后代码。</p><p>一般情况下，对比依赖查找和依赖注入，通常可以从以下几个维度对比：</p><table><thead><tr><th></th><th>依赖查找</th><th>依赖注入</th></tr></thead><tbody><tr><td>实现方式</td><td>使用上下文（容器）主动获取</td><td>依赖上下文被动接收</td></tr><tr><td>作用目标</td><td>通常是方法体内的局部变量，也可以是对象成员</td><td>通常是对象成员</td></tr><tr><td>API依赖</td><td>依赖 IOC 框架的 API（必须操纵容器的 API ）</td><td>可以不依赖（暴露 setter 方法即可）</td></tr><tr><td></td><td>applicationContext.getBean(beanName)</td><td>public void setXXX() { … }</td></tr></tbody></table><h2 id="问：SpringFramework中实现的IOC有什么？"><a href="#问：SpringFramework中实现的IOC有什么？" class="headerlink" title="问：SpringFramework中实现的IOC有什么？"></a>问：SpringFramework中实现的IOC有什么？</h2><p>真的不会有小伙伴只能答出 <code>ApplicationContext</code> 吧，一开始学的时候应该知道还有个 <code>BeanFactory</code> 吧。这是 SpringFramework 中两个核心的 IOC 容器的抽象。<code>BeanFactory</code> 仅仅是提供了一个容器管理的基本能力，<code>ApplicationContext</code> 在此基础上做了更加完善、强大的扩展。具体的对比可以参照下表：</p><table><thead><tr><th align="left">Feature</th><th align="left"><code>BeanFactory</code></th><th align="left"><code>ApplicationContext</code></th></tr></thead><tbody><tr><td align="left">Bean instantiation/wiring —— Bean的实例化和属性注入</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Integrated lifecycle management —— 生命周期管理</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Automatic <code>BeanPostProcessor</code> registration —— Bean后置处理器的支持</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Automatic <code>BeanFactoryPostProcessor</code> registration —— BeanFactory后置处理器的支持</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Convenient <code>MessageSource</code> access (for internalization) —— 消息转换服务（国际化）</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Built-in <code>ApplicationEvent</code> publication mechanism —— 事件发布机制（事件驱动）</td><td align="left">No</td><td align="left">Yes</td></tr></tbody></table><p>下面提供一个比较完整的示例答案，小伙伴们可以根据自己的知识储备和理解，调整这里面的一些描述细节：</p><p><code>BeanFactory</code> 接口提供了一个<strong>抽象的配置和对象的管理机制</strong>，<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口，它<strong>简化了与 AOP 的整合、消息机制、事件机制</strong>，以及<strong>对 Web 环境的扩展</strong>（ <code>WebApplicationContext</code> 等），<code>BeanFactory</code> 是没有这些扩展的。</p><p><code>ApplicationContext</code> 主要扩展了以下功能：（括号内的部分是解释扩展功能的一些简单描述或者原理底层实现，能回答出来更好）</p><ul><li><strong>AOP的支持</strong>（ <code>AnnotationAwareAspectJAutoProxyCreator</code> 作用于 Bean 的初始化之后 ）</li><li><strong>配置元信息</strong>（ <code>BeanDefinition</code> 、<code>Environment</code> 、注解等 ）</li><li><strong>资源管理</strong>（ <code>Resource</code> 抽象 ）</li><li><strong>事件驱动机制</strong>（ <code>ApplicationEvent</code> 、<code>ApplicationListener</code> ）</li><li><strong>消息与国际化</strong>（ <code>LocaleResolver</code> ）</li><li><strong><code>Environment</code> 抽象</strong>（SpringFramework 3.1以后）</li></ul><h2 id="问：依赖注入的注入方式？有什么区别？"><a href="#问：依赖注入的注入方式？有什么区别？" class="headerlink" title="问：依赖注入的注入方式？有什么区别？"></a>问：依赖注入的注入方式？有什么区别？</h2><p>注意这个问题也是与 SpringFramework 无关的，注入的方式本身就应该是依赖注入的实现，至于框架的代码，那是人家对于这个方式的落地。</p><p>可从以下几个维度对比：</p><table><thead><tr><th>注入方式</th><th>被注入成员是否可变</th><th>是否依赖IOC框架的API</th><th>使用场景</th></tr></thead><tbody><tr><td>构造器注入</td><td>不可变</td><td>否（xml、编程式注入不依赖）</td><td>不可变的固定注入</td></tr><tr><td>参数注入</td><td>不可变</td><td>是（只能通过标注注解来侵入式注入）</td><td>通常用于不可变的固定注入</td></tr><tr><td>setter注入</td><td>可变</td><td>否（xml、编程式注入不依赖）</td><td>可选属性的注入</td></tr></tbody></table><p>基本上问这个问题的话，还可能会继续问另一个问题：</p><h3 id="你觉得哪种方式好？为什么？"><a href="#你觉得哪种方式好？为什么？" class="headerlink" title="你觉得哪种方式好？为什么？"></a>你觉得哪种方式好？为什么？</h3><p>“莽夫”应聘者一看终于来开放式问题了，赶紧开始自由发挥了：</p><blockquote><p>我觉得参数注入好，因为我写习惯了，给参数打注解多舒服啊！</p></blockquote><p>你是这么说了，面试官咋想：就这？就这？？？进而对你的印象可能就会有所减分了。</p><p>这种问题，除了要表述主观看法之外，更多的是要<strong>根据一些既有的论述来辅助你的观点</strong>，最好的论述那一定是官方文档了。</p><p>SpringFramework 的官方文档在不同的版本推荐的注入方式是不同的：</p><ul><li>SpringFramework <strong>4.0.2</strong> 及之前是推荐 setter 注入，理由是<strong>一个 Bean 有多个依赖时，构造器的参数列表会很长</strong>；而且如果 <strong>Bean 中依赖的属性不都是必需的话，注入会变得更麻烦</strong>；</li><li><strong>4.0.3</strong> 及以后官方推荐构造器注入，理由是<strong>构造器注入的依赖是不可变的、完全初始化好的，且可以保证不为 null</strong> ；</li><li>当然 <strong>4.0.3</strong> 及以后的官方文档中也说了，如果<strong>真的出现构造器参数列表过长的情况，可能是这个 Bean 承担的责任太多，应该考虑组件的责任拆解</strong>。</li></ul><h2 id="问：组件注入的注解有什么？有什么区别？"><a href="#问：组件注入的注解有什么？有什么区别？" class="headerlink" title="问：组件注入的注解有什么？有什么区别？"></a>问：组件注入的注解有什么？有什么区别？</h2><p>相信大多数小伙伴都能答出 <code>@Autowired</code> 和 <code>@Resource</code> 吧，如果答出这两个，那证明你应该用过，也会用。但你能回答出 <code>@Inject</code> ，证明你对这些注入的注解确实有了解。作为应聘者，在回答问题时一定是回答的<strong>尽可能全面</strong>为好，下面对这几种注解作一个对比：</p><table><thead><tr><th>注解</th><th>注入方式</th><th>是否支持@Primary</th><th>来源</th><th>Bean不存在时处理</th></tr></thead><tbody><tr><td>@Autowired</td><td>根据类型注入</td><td>是</td><td>SpringFramework原生注解</td><td>可指定 required=false 来避免注入失败</td></tr><tr><td>@Resource</td><td>根据名称注入</td><td>否</td><td>JSR250规范</td><td>容器中不存在指定Bean会抛出异常</td></tr><tr><td>@Inject</td><td>根据类型注入</td><td>是</td><td>JSR330规范 ( 需要导jar包 )</td><td>容器中不存在指定Bean会抛出异常</td></tr></tbody></table><p>跟上面差不多，如果问到了这个问题，那就有可能继续被问到下面一个问题：</p><h3 id="存在多个相同类型Bean时如何解决注入问题？"><a href="#存在多个相同类型Bean时如何解决注入问题？" class="headerlink" title="存在多个相同类型Bean时如何解决注入问题？"></a>存在多个相同类型Bean时如何解决注入问题？</h3><p>可能大多数小伙伴都能答出以下几种解决方案：</p><ul><li><code>@Resource</code> ：根据名称指定注入的 Bean</li><li><code>@Qualifier</code> ：配合 <code>@Autowired</code> 注解使用，如果被标注的成员 / 方法在根据类型注入时发现有多个相同类型的 Bean ，则会根据该注解声明的 name 寻找特定的 bean</li><li><code>@Primary</code> ：配合 <code>@Bean</code> 注解使用，如果有多个相同类型的 Bean 同时注册到 IOC 容器中，使用 <code>@Autowired</code> 、<code>@Inject</code> 注解时会注入标注 <code>@Primary</code> 注解的 bean</li></ul><p>其实你还可以提另外一种方案：把<strong>注入的字段名与 bean 的名称保持一致</strong>，这样也可以解决注入时报不唯一 Bean 的问题。</p><p>以上几个问题是关于 SpringFramework 与 IOC 部分的一些常见问题，倒是问题都不太陌生，但是小伙伴们想回答的全面、有深度，还是需要下下功夫的。希望小伙伴们能有所收获，在面试中流利回答，斩获 offer ！</p><hr><p>问题整理不易，不点个赞支持一下作者吗？（可怜巴巴）</p>]]></content>
      
      
      <categories>
          
          <category> SpringFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务发现-EurekaServer的初始化和启动原理</title>
      <link href="/2020/01/04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-EurekaServer%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2020/01/04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-EurekaServer%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>刚学习 SpringCloud 的时候先要学习注册中心，也就是服务发现与治理。SpringCloudNetflix 的方案是使用 Eureka，咱也都很清楚了，下面咱先搭建一个只有 EurekaServer 的工程。</p><p>pom依赖只需要两个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure><p>启动类上标注 <code>@EnableEurekaServer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        SpringApplication.run(EurekaServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><code>application.yml</code> 中配置一些最基础的信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">application:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">instance:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka-server</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">client:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">service-url:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9000/eureka/</span></span></pre></td></tr></table></figure><p>之后运行主启动类，EurekaServer 便会运行在9000端口上。</p><p>如果不标注 <code>@EnableEurekaServer</code> 注解，即便导入依赖也不会启动 EurekaServer，说明真正打开 EurekaServer 的是 <code>@EnableEurekaServer</code> 注解。</p><h2 id="1-EnableEurekaServer"><a href="#1-EnableEurekaServer" class="headerlink" title="1. @EnableEurekaServer"></a>1. @EnableEurekaServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(EurekaServerMarkerConfiguration<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableEurekaServer</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>它的文档注释非常简单：</p><blockquote><p>Annotation to activate Eureka Server related configuration.</p><p>用于激活 EurekaServer 相关配置的注解。</p></blockquote><p>它被标注了一个 <code>@Import</code> 注解，导入的是一个 <code>EurekaServerMarkerConfiguration</code> 的配置类。</p><blockquote><p>如果小伙伴对 @Import 注解还不是很了解，可以移步我的 《<a href="https://juejin.im/book/5da3bc3d6fb9a04e35597a76" target="_blank" rel="noopener">SpringBoot源码解读与原理分析</a>》小册，先了解 SpringFramework 的基础。</p></blockquote><h2 id="2-EurekaServerMarkerConfiguration"><a href="#2-EurekaServerMarkerConfiguration" class="headerlink" title="2. EurekaServerMarkerConfiguration"></a>2. EurekaServerMarkerConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerMarkerConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Marker <span class="title">eurekaServerMarkerBean</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Marker();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Marker</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这段源码看上去莫名其妙的，它是一个配置类，然后它定义了一个 <code>Marker</code> 的内部类，又注册了一个Bean，但这光秃秃的，也没点别的逻辑，它到底想干啥？果然还是得靠文档注释：</p><blockquote><p>Responsible for adding in a marker bean to activate EurekaServerAutoConfiguration.</p><p>负责添加标记Bean来激活 <code>EurekaServerAutoConfiguration</code> 。</p></blockquote><p>好吧，原来它的作用是<strong>给IOC容器中添加一个标记，代表要启用 <code>EurekaServerAutoConfiguration</code> 的自动配置类</strong>。</p><p>那咱就移步 <code>EurekaServerAutoConfiguration</code> 来看它的定义了。</p><h2 id="3-EurekaServerAutoConfiguration"><a href="#3-EurekaServerAutoConfiguration" class="headerlink" title="3. EurekaServerAutoConfiguration"></a>3. EurekaServerAutoConfiguration</h2><p>看到 AutoConfiguration 结尾的类，咱马上要想到：这个类肯定在 <code>spring.factories</code> 文件标注好了，不然没法生效。</p><p>果然，在 <code>spring-cloud-netflix-eureka-server</code> 的 jar 包中发现了一个 <code>spring.factories</code> 文件，而文件内部的声明就是如此的简单：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration</span></span></pre></td></tr></table></figure><p>没得跑，来看它的定义和声明吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(EurekaServerInitializerConfiguration<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class">@<span class="title">ConditionalOnBean</span>(<span class="title">EurekaServerMarkerConfiguration</span>.<span class="title">Marker</span>.<span class="title">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(</span>&#123; EurekaDashboardProperties<span class="class">.<span class="keyword">class</span>,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">InstanceRegistryProperties</span>.<span class="title">class</span> &#125;)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">@PropertySource("classpath:/eureka/server.properties")</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span></span></pre></td></tr></table></figure><p>注意看 <code>@ConditionalOnBean</code> 的条件：必须IOC容器中有一个 <code>EurekaServerMarkerConfiguration.Marker</code> 类型的 Bean，该配置类才会生效！（原来它是这样做自动配置开关的）</p><p>注意到它继承了 <code>WebMvcConfigurerAdapter</code> ，但全篇没有找到跟 <code>WebMvcConfigurer</code> 相关的部分，也没重写对应的方法。那它这是几个意思？这个时候咱要了解一个小背景：</p><blockquote><p>在 SpringFramework5.0+ 后，因为接口可以直接声明 default 方法，所以 <code>WebMvcConfigurerAdapter</code> 被废弃（被标注 <code>@Deprecated</code>），替代方案是直接实现 <code>WebMvcConfigurer</code> 接口。</p></blockquote><p>那既然是这样， 它还继承着这个适配器类，那咱可以大概猜测：它应该是旧版本的遗留。</p><p>回到正题，咱看 <code>EurekaServerAutoConfiguration</code> 的类定义声明上还有什么值得注意的。除了上面说的，那就只剩下一个了：它导入了一个 <code>EurekaServerInitializerConfiguration</code> 。</p><h2 id="4-EurekaServerInitializerConfiguration"><a href="#4-EurekaServerInitializerConfiguration" class="headerlink" title="4. EurekaServerInitializerConfiguration"></a>4. EurekaServerInitializerConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerInitializerConfiguration</span> <span class="keyword">implements</span> <span class="title">ServletContextAware</span>, <span class="title">SmartLifecycle</span>, <span class="title">Ordered</span></span></span></pre></td></tr></table></figure><p>注意它实现了 <code>SmartLifecycle</code> 接口，之前咱在《SpringBoot源码解读与原理分析》原理小册中提到过（第16篇 12.2.2章节），如果小伙伴们对这部分不了解，可以移步我的 《<a href="https://juejin.im/book/5da3bc3d6fb9a04e35597a76" target="_blank" rel="noopener">SpringBoot源码解读与原理分析</a>》小册，这里咱直接说，它的核心方法是 <code>start</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> is this class even needed now?</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 初始化、启动 EurekaServer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                eurekaServerBootstrap.contextInitialized(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                        EurekaServerInitializerConfiguration.<span class="keyword">this</span>.servletContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                log.info(<span class="string">"Started Eureka Server"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 发布Eureka已注册的事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                publish(<span class="keyword">new</span> EurekaRegistryAvailableEvent(getEurekaServerConfig()));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 修改 EurekaServer 的运行状态</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                EurekaServerInitializerConfiguration.<span class="keyword">this</span>.running = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 发布Eureka已启动的事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                publish(<span class="keyword">new</span> EurekaServerStartedEvent(getEurekaServerConfig()));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;).start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>（至此应该进一步意识到为什么上面 <code>EurekaServerAutoConfiguration</code> 继承了一个过时的类，<code>Runnable</code> 都没换成 Lambda 表达式。。。当然也跟 Eureka 1.x 不继续更新有关吧）</p><p>这个 <code>start</code> 方法只干了一件事，起一个新的线程来启动 EurekaServer 。这里面核心的 <strong>run</strong> 方法执行了这么几件事，都已经标注在源码中了。</p><p>这里面最重要的步骤就是第一步：<strong>初始化、启动 EurekaServer</strong> 。</p><p>在继续展开这部分源码之前，要带小伙伴了解一点前置知识。</p><p>EurekaServer 本身应该是一个完整的 Servlet 应用，在原生的 EurekaServer 中，<code>EurekaServerBootstrap</code> 这个类会实现 <code>ServletContextListener</code> 接口（Servlet3.0规范）来引导启动 EurekaServer 。SpringBoot 应用一般使用嵌入式 Web 容器，没有所谓 Servlet3.0 规范作用的机会了，所以需要另外的启动方式，于是 SpringCloud 在整合这部分时，借助了IOC容器中支持的 <code>LifeCycle</code> 机制，来以此触发 EurekaServer 的启动。</p><h3 id="4-0-eurekaServerBootstrap-contextInitialized：初始化、启动EurekaServer"><a href="#4-0-eurekaServerBootstrap-contextInitialized：初始化、启动EurekaServer" class="headerlink" title="4.0 eurekaServerBootstrap.contextInitialized：初始化、启动EurekaServer"></a>4.0 eurekaServerBootstrap.contextInitialized：初始化、启动EurekaServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContext context)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        initEurekaEnvironment();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        initEurekaServerContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        context.setAttribute(EurekaServerContext<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">this</span>.<span class="title">serverContext</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里面又分为两个部分，依此来看：</p><h3 id="4-1-initEurekaEnvironment：初始化Eureka的运行环境"><a href="#4-1-initEurekaEnvironment：初始化Eureka的运行环境" class="headerlink" title="4.1 initEurekaEnvironment：初始化Eureka的运行环境"></a>4.1 initEurekaEnvironment：初始化Eureka的运行环境</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST = <span class="string">"test"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT = <span class="string">"default"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    log.info(<span class="string">"Setting the eureka configuration.."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Eureka的数据中心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    String dataCenter = ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            .getString(EUREKA_DATACENTER);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (dataCenter == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        log.info(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                <span class="string">"Eureka data center value eureka.datacenter is not set, defaulting to default"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Eureka运行环境</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    String environment = ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            .getString(EUREKA_ENVIRONMENT);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        log.info(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                <span class="string">"Eureka environment value eureka.environment is not set, defaulting to test"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, environment);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里面的逻辑咱乍一看，貌似都长得差不多啊，都是 <strong>获取 → 判断 → 设置</strong> ，而且它们都有对应的默认值（源码中已标注）。至于这部分是干嘛的呢，咱不得不关注一下 <code>setProperty</code> 方法中的两个常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_DATACENTER = <span class="string">"archaius.deployment.datacenter"</span>;</span></pre></td></tr></table></figure><p>配置项的前缀是 <code>archaius</code> ，它是 Netflix 旗下的一个配置管理组件（提到这里，是不是产生了一种感觉：它会不会跟 SpringCloudConfig 有关系？然而并不是，当引入 SpringCloudConfig 时，archaius 并不会带进来），这个组件可以实现更强大的动态配置，它的基底是 <strong>Apache</strong> 的 <code>commons-configuration</code> ：</p><p>![](服务发现-EurekaServer的初始化和启动原理/3. archaius的底层依赖是commons-configuration.png)</p><p>对于这个组件，小册不展开研究了，小伙伴们只需要知道有这么回事就可以了，下面的才是重点。</p><h3 id="4-2-initEurekaServerContext：初始化EurekaServer的运行上下文"><a href="#4-2-initEurekaServerContext：初始化EurekaServer的运行上下文" class="headerlink" title="4.2 initEurekaServerContext：初始化EurekaServer的运行上下文"></a>4.2 initEurekaServerContext：初始化EurekaServer的运行上下文</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// For backward compatibility  兼容低版本Eureka</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    JsonXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            XStream.PRIORITY_VERY_HIGH);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    XmlXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            XStream.PRIORITY_VERY_HIGH);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (isAws(<span class="keyword">this</span>.applicationInfoManager.getInfo())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.awsBinder = <span class="keyword">new</span> AwsBinderDelegate(<span class="keyword">this</span>.eurekaServerConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">this</span>.eurekaClientConfig, <span class="keyword">this</span>.registry, <span class="keyword">this</span>.applicationInfoManager);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.awsBinder.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 注册EurekaServerContextHolder，通过它可以很方便的获取EurekaServerContext</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    EurekaServerContextHolder.initialize(<span class="keyword">this</span>.serverContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    log.info(<span class="string">"Initialized server context"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Copy registry from neighboring eureka node</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Eureka复制集群节点注册表</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> registryCount = <span class="keyword">this</span>.registry.syncUp();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.registry.openForTraffic(<span class="keyword">this</span>.applicationInfoManager, registryCount);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Register all monitoring statistics.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    EurekaMonitors.registerAllStats();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>前面的一大段都是为了低版本兼容而做的一些额外工作，咱不关心这些。中间又是注册了一个 注册<code>EurekaServerContextHolder</code> 的组件，通过它可以直接获取 <code>EurekaServerContext</code> （它的内部使用简单的单例实现，实现非常简单，小伙伴可自行查看）。</p><p>注意最后几行，倒数第二个单行注释的内容：</p><blockquote><p>Copy registry from neighboring eureka node。</p><p>从相邻的eureka节点复制注册表。</p></blockquote><p>节点复制注册表？这很明显是为了 Eureka 集群而设计的！由此可知 Eureka 集群能保证后起来的节点也不会出问题，是这里同步了注册表啊！这一步的操作非常复杂，咱后续另开一篇解释。</p><p>除了这部分之外，<code>EurekaServerInitializerConfiguration</code> 已经没有要配置的组件，回到 <code>EurekaServerAutoConfiguration</code> 中。</p><h2 id="5-EurekaServerAutoConfiguration中配置的核心组件"><a href="#5-EurekaServerAutoConfiguration中配置的核心组件" class="headerlink" title="5. EurekaServerAutoConfiguration中配置的核心组件"></a>5. EurekaServerAutoConfiguration中配置的核心组件</h2><h3 id="5-1-EurekaController"><a href="#5-1-EurekaController" class="headerlink" title="5.1 EurekaController"></a>5.1 EurekaController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"eureka.dashboard"</span>, name = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaController <span class="title">eurekaController</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EurekaController(<span class="keyword">this</span>.applicationInfoManager);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>呦，一看这是个 Controller ，有木有立马想到自己写的那些 Controller ？赶紧点进去瞅一眼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;eureka.dashboard.path:/&#125;"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaController</span></span></span></pre></td></tr></table></figure><p>哇塞果然是我们熟悉的 SpringWebMvc 的内容！既然是一个 Controller ，那它肯定能给咱定义了一些处理方法，不然咱咋看到的 Eureka 控制台呢？翻看源码，它这里面定义了两个处理方法，分别是： <code>status</code> - 获取当前 EurekaServer 的状态（即控制台）、<code>lastn</code> - 获取当前 EurekaServer 上服务注册动态历史记录。这部分咱不展开描述了，有兴趣的小伙伴们可以深入这个类来研究。</p><h3 id="5-2-PeerAwareInstanceRegistry"><a href="#5-2-PeerAwareInstanceRegistry" class="headerlink" title="5.2 PeerAwareInstanceRegistry"></a>5.2 PeerAwareInstanceRegistry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PeerAwareInstanceRegistry <span class="title">peerAwareInstanceRegistry</span><span class="params">(ServerCodecs serverCodecs)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.eurekaClient.getApplications(); <span class="comment">// force initialization</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InstanceRegistry(<span class="keyword">this</span>.eurekaServerConfig, <span class="keyword">this</span>.eurekaClientConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            serverCodecs, <span class="keyword">this</span>.eurekaClient,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.instanceRegistryProperties.getExpectedNumberOfClientsSendingRenews(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.instanceRegistryProperties.getDefaultOpenForTrafficCount());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个 <code>PeerAwareInstanceRegistry</code> 很重要，它是 <strong>EurekaServer 集群中节点之间同步微服务实例注册表的核心组件</strong>（这里默认小伙伴已经对 EurekaServer 的集群配置及相关基础都了解了）。集群节点同步注册表的内容咱会另起一篇研究，这里咱只是看一下这个类的继承结构，方面后续看到时不至于不认识：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceRegistry</span> <span class="keyword">extends</span> <span class="title">PeerAwareInstanceRegistryImpl</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">PeerAwareInstanceRegistryImpl</span> <span class="keyword">extends</span> <span class="title">AbstractInstanceRegistry</span> <span class="keyword">implements</span> <span class="title">PeerAwareInstanceRegistry</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">AbstractInstanceRegistry</span> <span class="keyword">implements</span> <span class="title">InstanceRegistry</span></span></span></pre></td></tr></table></figure><p>这里面继承的两个类 <code>PeerAwareInstanceRegistryImpl</code> 、<code>AbstractInstanceRegistry</code> ，它们将会在后续研究节点同步时有重要作用，包括里面涉及的功能会在后面的组件（<code>EurekaServerContext</code> 等）发挥功能时带着一起解释。</p><h3 id="5-3-PeerEurekaNodes"><a href="#5-3-PeerEurekaNodes" class="headerlink" title="5.3 PeerEurekaNodes"></a>5.3 PeerEurekaNodes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PeerEurekaNodes <span class="title">peerEurekaNodes</span><span class="params">(PeerAwareInstanceRegistry registry, ServerCodecs serverCodecs,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        ReplicationClientAdditionalFilters replicationClientAdditionalFilters)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RefreshablePeerEurekaNodes(registry, <span class="keyword">this</span>.eurekaServerConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.eurekaClientConfig, serverCodecs, <span class="keyword">this</span>.applicationInfoManager,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            replicationClientAdditionalFilters);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个 <code>PeerEurekaNodes</code> 可以理解成<strong>微服务实例的节点集合</strong>。换言之，一个 <code>PeerEurekaNode</code> 就是一个微服务节点实例的包装，<code>PeerEurekaNodes</code> 就是这组 <code>PeerEurekaNode</code> 的集合，这种节点是可以被 EurekaServer 集群中的各个注册中心节点共享的（<code>PeerAwareInstanceRegistry</code>）。翻开 PeerEurekaNodes 的结构，可以发现它的结构中有这么几样东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</span></pre></td></tr></table></figure><ul><li><code>PeerAwareInstanceRegistry</code> ：集群间节点同步的核心组件</li><li><code>List&lt;PeerEurekaNode&gt;</code> ：节点集合</li><li><code>peerEurekaNodeUrls</code> ：所有节点所在url</li><li><code>ScheduledExecutorService</code> ：执行定时任务的线程池</li></ul><p>另外 <code>PeerEurekaNodes</code> 还提供了一个 <code>start</code> 和 <code>shutdown</code> 方法：</p><h4 id="5-3-1-start"><a href="#5-3-1-start" class="headerlink" title="5.3.1 start"></a>5.3.1 start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    taskExecutor = Executors.newSingleThreadScheduledExecutor(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">new</span> ThreadFactory() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                    Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                    thread.setDaemon(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">return</span> thread;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        updatePeerEurekaNodes(resolvePeerUrls());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                    updatePeerEurekaNodes(resolvePeerUrls());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        taskExecutor.scheduleWithFixedDelay(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                peersUpdateTask,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                TimeUnit.MILLISECONDS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ...... log ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可以发现 start 方法的核心是<strong>借助线程池完成定时任务</strong>。定时任务的内容是中间那一段实现了 <code>Runnable</code> 接口的匿名内部类，它会执行一个 <code>updatePeerEurekaNodes</code> 方法来更新集群节点。下面定时任务的执行时间，借助IDEA跳转到 <code>EurekaServerConfigBean</code> 中发现默认的配置是 10 分钟，即<strong>每隔10分钟会同步一次集群节点</strong>。至于 <code>updatePeerEurekaNodes</code> 的具体实现，咱同样放到后面跟节点同步放在一起来解析。</p><h4 id="5-3-2-shutdown"><a href="#5-3-2-shutdown" class="headerlink" title="5.3.2 shutdown"></a>5.3.2 shutdown</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    taskExecutor.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    List&lt;PeerEurekaNode&gt; toRemove = <span class="keyword">this</span>.peerEurekaNodes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = Collections.emptyList();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.peerEurekaNodeUrls = Collections.emptySet();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (PeerEurekaNode node : toRemove) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        node.shutDown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个方法的内容比较简单，它会把线程池的定时任务停掉，并移除掉当前所有的服务节点信息。它被调用的时机是下面要解析的 <code>EurekaServerContext</code> 。</p><h3 id="5-4-EurekaServerContext"><a href="#5-4-EurekaServerContext" class="headerlink" title="5.4 EurekaServerContext"></a>5.4 EurekaServerContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaServerContext <span class="title">eurekaServerContext</span><span class="params">(ServerCodecs serverCodecs,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        PeerAwareInstanceRegistry registry, PeerEurekaNodes peerEurekaNodes)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultEurekaServerContext(<span class="keyword">this</span>.eurekaServerConfig, serverCodecs,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            registry, peerEurekaNodes, <span class="keyword">this</span>.applicationInfoManager);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>它创建了一个 <code>DefaultEurekaServerContext</code> ，文档注释原文翻译：</p><blockquote><p>Represent the local server context and exposes getters to components of the local server such as the registry.</p><p>表示本地服务器上下文，并将 getter 方法暴露给本地服务器的组件（例如注册表）。</p></blockquote><p>可以大概的意识到，它确实跟 SpringFramework 的 <code>ApplicationContext</code> 差不太多哈，可以这么简单地理解吧，咱还是看看里面比较特殊的内容。</p><p>进入到 <code>DefaultEurekaServerContext</code> 中，果然发现了两个特殊的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Initializing ..."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    peerEurekaNodes.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        registry.init(peerEurekaNodes);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Initialized"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Shutting down ..."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    registry.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    peerEurekaNodes.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Shut down"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>果然，是 <code>EurekaServerContext</code> 的初始化，带动 <code>PeerEurekaNodes</code> 的初始化，<code>EurekaServerContext</code> 的销毁带动 <code>PeerEurekaNodes</code> 的销毁。除了带动 <code>PeerEurekaNodes</code> 之前，还有一个 <code>PeerAwareInstanceRegistry</code> 也带动初始化了，看一眼它的 <code>init</code> 方法吧：</p><h4 id="5-4-1-PeerAwareInstanceRegistry-init"><a href="#5-4-1-PeerAwareInstanceRegistry-init" class="headerlink" title="5.4.1 PeerAwareInstanceRegistry#init"></a>5.4.1 PeerAwareInstanceRegistry#init</h4><p>关键部分注释已标注在源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(PeerEurekaNodes peerEurekaNodes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 5.4.1.1 启动续订租约的频率统计器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.numberOfReplicationsLastMin.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = peerEurekaNodes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    initializedResponseCache();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 5.4.1.2 开启续订租约最低阈值检查的定时任务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    scheduleRenewalThresholdUpdateTask();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 5.4.1.3 初始化远程分区注册中心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    initRemoteRegionRegistry();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Monitors.registerObject(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        logger.warn(<span class="string">"Cannot register the JMX monitor for the InstanceRegistry :"</span>, e);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>源码标注了三个关键的环节，一一来看：</p><h5 id="5-4-1-1-numberOfReplicationsLastMin-start-：启动续订租约的频率统计器"><a href="#5-4-1-1-numberOfReplicationsLastMin-start-：启动续订租约的频率统计器" class="headerlink" title="5.4.1.1 numberOfReplicationsLastMin.start()：启动续订租约的频率统计器"></a>5.4.1.1 numberOfReplicationsLastMin.start()：启动续订租约的频率统计器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong currentBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sampleInterval;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!isActive) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// Zero out the current bucket.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                    lastBucket.set(currentBucket.getAndSet(<span class="number">0</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                    logger.error(<span class="string">"Cannot reset the Measured Rate"</span>, e);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;, sampleInterval, sampleInterval);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        isActive = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个方法实现不难理解，它会隔一段时间重置 <code>lastBucket</code> 和 <code>currentBucket</code> 的值为0，那时间间隔是多少呢？翻看整个类，发现只有构造方法可以设置时间间隔：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MeasuredRate</span><span class="params">(<span class="keyword">long</span> sampleInterval)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.sampleInterval = sampleInterval;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.timer = <span class="keyword">new</span> Timer(<span class="string">"Eureka-MeasureRateTimer"</span>, <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.isActive = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>借助IDEA，发现设置 <code>sampleInterval</code> 的值有两处，但值都是一样的：<code>new MeasuredRate(1000 * 60 * 1);</code> ，也就是<strong>1分钟重置一次</strong>。可关键的问题是，它这个操作是干嘛呢？为啥非得一分钟统计一次续约次数呢？实际上，这个计算次数会体现在 Eureka 的控制台，以及配合 <strong>Servo</strong> 完成<strong>续约次数监控</strong>（说白了，咱这看着没啥用，微服务监控和治理还是管用的，不然为什么 Eureka 被称为<strong>服务发现与治理</strong>的框架呢）。</p><h5 id="5-4-1-2-scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务"><a href="#5-4-1-2-scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务" class="headerlink" title="5.4.1.2 scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务"></a>5.4.1.2 scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> renewalThresholdUpdateIntervalMs = <span class="number">15</span> * MINUTES;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleRenewalThresholdUpdateTask</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                       <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                           updateRenewalThreshold();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                       &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                   &#125;, serverConfig.getRenewalThresholdUpdateIntervalMs(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            serverConfig.getRenewalThresholdUpdateIntervalMs());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>又是一个定时任务，配置项中的默认时间间隔可以发现是15分钟。那定时任务中执行的核心方法是 <code>updateRenewalThreshold</code> 方法，跳转过去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRenewalThreshold</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        Applications apps = eurekaClient.getApplications();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isRegisterable(instance)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    ++count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Update threshold only if the threshold is greater than the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// current expected threshold or if self preservation is disabled.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((count) &gt; (serverConfig.getRenewalPercentThreshold() * expectedNumberOfClientsSendingRenews)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                    || (!<span class="keyword">this</span>.isSelfPreservationModeEnabled())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">this</span>.expectedNumberOfClientsSendingRenews = count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                updateRenewsPerMinThreshold();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        logger.info(<span class="string">"Current renewal threshold is : &#123;&#125;"</span>, numberOfRenewsPerMinThreshold);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>上面的 for 循环很明显是检查当前已经注册到本地的服务实例是否还保持连接，由于该方法一定会返回 true （可翻看该部分实现，全部都是 <code>return true</code>），故上面统计的 count 就是所有的微服务实例数量。</p><p>下面的同步代码块中，它会检查统计好的数量是否比预期的多，如果统计好的服务实例数比预期的数量多，证明出现了<strong>新的服务注册</strong>，要替换下一次统计的期望数量值，以及重新计算接下来心跳的数量统计。心跳的数量统计方法 <code>updateRenewsPerMinThreshold()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> expectedClientRenewalIntervalSeconds = <span class="number">30</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> renewalPercentThreshold = <span class="number">0.85</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateRenewsPerMinThreshold</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfClientsSendingRenews</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            * (<span class="number">60.0</span> / serverConfig.getExpectedClientRenewalIntervalSeconds())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            * serverConfig.getRenewalPercentThreshold());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可以看出来它的计算数是：<strong>每隔30秒发一次心跳</strong>（一分钟心跳两次），而且必须所有的服务实例的心跳总数要达到前面计算数量的85%才算整体微服务正常，其实这也就是 <strong>EurekaServer 的自我保护机制</strong>。</p><h5 id="5-4-1-3-initRemoteRegionRegistry：初始化远程分区注册中心"><a href="#5-4-1-3-initRemoteRegionRegistry：初始化远程分区注册中心" class="headerlink" title="5.4.1.3 initRemoteRegionRegistry：初始化远程分区注册中心"></a>5.4.1.3 initRemoteRegionRegistry：初始化远程分区注册中心</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initRemoteRegionRegistry</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Map&lt;String, String&gt; remoteRegionUrlsWithName = serverConfig.getRemoteRegionUrlsWithName();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!remoteRegionUrlsWithName.isEmpty()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        allKnownRemoteRegions = <span class="keyword">new</span> String[remoteRegionUrlsWithName.size()];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> remoteRegionArrayIndex = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; remoteRegionUrlWithName : remoteRegionUrlsWithName.entrySet()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            RemoteRegionRegistry remoteRegionRegistry = <span class="keyword">new</span> RemoteRegionRegistry(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    serverConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                    clientConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                    serverCodecs,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    remoteRegionUrlWithName.getKey(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">new</span> URL(remoteRegionUrlWithName.getValue()));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            regionNameVSRemoteRegistry.put(remoteRegionUrlWithName.getKey(), remoteRegionRegistry);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            allKnownRemoteRegions[remoteRegionArrayIndex++] = remoteRegionUrlWithName.getKey();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Finished initializing remote region registries. All known remote regions: &#123;&#125;"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            (Object) allKnownRemoteRegions);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里面提到了一个概念：<code>RemoteRegionRegistry</code> ，它的文档注释原文翻译：</p><blockquote><p>Handles all registry operations that needs to be done on a eureka service running in an other region. The primary operations include fetching registry information from remote region and fetching delta information on a periodic basis.</p><p>处理在其他区域中运行的eureka服务上需要完成的所有注册表操作。主要操作包括从远程区域中获取注册表信息以及定期获取增量信息。</p></blockquote><p>文档注释的解释看着似懂非懂，它没有把这个类的作用完全解释清楚。实际上这里涉及到 Eureka 的服务分区，这个咱留到后面解释 Eureka 的高级特性时再聊。</p><h4 id="5-4-2-PeerAwareInstanceRegistry-shutdown"><a href="#5-4-2-PeerAwareInstanceRegistry-shutdown" class="headerlink" title="5.4.2 PeerAwareInstanceRegistry#shutdown"></a>5.4.2 PeerAwareInstanceRegistry#shutdown</h4><p>当 <code>EurekaServerContext</code> 被销毁时，会回调 <code>@PreDestory</code> 标注的 <code>shutdown</code> 方法，而这个方法又调到 <code>PeerAwareInstanceRegistry</code> 的 <code>shutdown</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        DefaultMonitorRegistry.getInstance().unregister(Monitors.newObjectMonitor(<span class="keyword">this</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch .......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        peerEurekaNodes.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch .......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    numberOfReplicationsLastMin.stop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">super</span>.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这里它干的事情不算麻烦，它首先利用 <code>DefaultMonitorRegistry</code> 做了一个注销操作，<code>DefaultMonitorRegistry</code> 这个组件本身来源于 <strong>servo</strong> 包，它是做监控使用，那自然能猜出来这部分是<strong>关闭监控</strong>。接下来它会把那些微服务节点实例全部注销，停止计数器监控，最后回调父类的 <code>shutdown</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    deltaRetentionTimer.cancel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    evictionTimer.cancel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    renewsLastMin.stop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>可以发现也是跟监控相关的组件停止，不再赘述。</p><h3 id="5-5-EurekaServerBootstrap"><a href="#5-5-EurekaServerBootstrap" class="headerlink" title="5.5 EurekaServerBootstrap"></a>5.5 EurekaServerBootstrap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaServerBootstrap <span class="title">eurekaServerBootstrap</span><span class="params">(PeerAwareInstanceRegistry registry,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        EurekaServerContext serverContext)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EurekaServerBootstrap(<span class="keyword">this</span>.applicationInfoManager,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.eurekaClientConfig, <span class="keyword">this</span>.eurekaServerConfig, registry,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            serverContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个咱上面已经提过了，有了 <code>EurekaServerBootstrap</code> 才能引导启动 <code>EurekaServer</code> 。</p><h3 id="5-6-ServletContainer"><a href="#5-6-ServletContainer" class="headerlink" title="5.6 ServletContainer"></a>5.6 ServletContainer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">jerseyFilterRegistration</span><span class="params">(javax.ws.rs.core.Application eurekaJerseyApp)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    bean.setFilter(<span class="keyword">new</span> ServletContainer(eurekaJerseyApp));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    bean.setOrder(Ordered.LOWEST_PRECEDENCE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    bean.setUrlPatterns(Collections.singletonList(EurekaConstants.DEFAULT_PREFIX + <span class="string">"/*"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>它注册的 <code>FilterRegistrationBean</code> 我在之前的《<a href="https://juejin.im/book/5da3bc3d6fb9a04e35597a76" target="_blank" rel="noopener">SpringBoot源码解读与原理分析</a>》中有提过（第6章4.1.2节），这里咱直接说核心的 <code>Filter</code> 是 <code>ServletContainer</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.jersey.spi.container.servlet;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContainer</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> <span class="keyword">implements</span> <span class="title">Filter</span></span></span></pre></td></tr></table></figure><p>注意它所在的包，里面有一个很关键的词：<strong>jersey</strong> ，它是一个类似于 SpringWebMvc 的框架，由于 Eureka 本身也是一个 Servlet 应用，只是它使用的 Web 层框架不是 SpringWebMvc 而是 Jersey 而已，Jersey 在 Eureka 的远程请求、心跳包发送等环节起到至关重要的作用，后续咱会详细解释。</p><h3 id="5-7-Application"><a href="#5-7-Application" class="headerlink" title="5.7 Application"></a>5.7 Application</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> javax.ws.rs.core.<span class="function">Application <span class="title">jerseyApplication</span><span class="params">(Environment environment,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        ResourceLoader resourceLoader)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个类的创建咱不是很关心，瞅一眼这个类的子类，发现全部都是来自 <strong>Jersey</strong> 的：</p><p>![](服务发现-EurekaServer的初始化和启动原理/3. Application下面的子类全部都是jersey的.png)</p><p>而且上面的 <code>ServletContainer</code> 中正好也用到了这个 <code>Application</code> ，那大概也明白它是配合上面的过滤器使用，后续咱会跟上面的 <strong>Jersey</strong> 一起解释。</p><h3 id="5-8-HttpTraceFilter"><a href="#5-8-HttpTraceFilter" class="headerlink" title="5.8 HttpTraceFilter"></a>5.8 HttpTraceFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">traceFilterRegistration</span><span class="params">(@Qualifier(<span class="string">"httpTraceFilter"</span>)</span> Filter filter) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    bean.setFilter(filter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    bean.setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">10</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>它注册了一个名为 <code>httpTraceFilter</code> 的过滤器，借助IDEA发现这个过滤器来自 <code>HttpTraceAutoConfiguration</code> 的内部类 <code>ServletTraceFilterConfiguration</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletTraceFilterConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> HttpTraceFilter <span class="title">httpTraceFilter</span><span class="params">(HttpTraceRepository repository, HttpExchangeTracer tracer)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpTraceFilter(repository, tracer);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>这个过滤器的作用也很容易猜想，<strong>trace</strong> 的概念咱从日志系统里也接触过，它打印的内容非常非常多，且涵盖了上面的几乎所有级别。这个类的文档注释也恰好印证了我们的猜想：</p><blockquote><p>Servlet Filter that logs all requests to an HttpTraceRepository.</p><p>记录所有请求日志的Servlet过滤器。</p></blockquote><h2 id="6-EurekaServerConfigBeanConfiguration"><a href="#6-EurekaServerConfigBeanConfiguration" class="headerlink" title="6. EurekaServerConfigBeanConfiguration"></a>6. EurekaServerConfigBeanConfiguration</h2><p><code>EurekaServerAutoConfiguration</code> 还有一个内部的配置类：<code>EurekaServerConfigBeanConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerConfigBeanConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> EurekaServerConfig <span class="title">eurekaServerConfig</span><span class="params">(EurekaClientConfig clientConfig)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        EurekaServerConfigBean server = <span class="keyword">new</span> EurekaServerConfigBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Set a sensible default if we are supposed to replicate</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            server.setRegistrySyncRetries(<span class="number">5</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> server;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>它就是注册了默认的 EurekaServer 的配置模型，这个模型类里的配置咱上面也看到一些了，后面的部分咱还会接触它，先有一个印象即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><code>@EnableEurekaServer</code> 注解会激活 EurekaServer 的自动配置，核心是向IOC容器注册一个 <code>Marker</code> 的内部类。</li><li><code>EurekaServerInitializerConfiguration</code> 负责 EurekaServer 的初始化，初始化的过程包括本身初始化、运行环境初始化、运行上下文的初始化。</li><li><code>EurekaServerAutoConfiguration</code> 注册的核心组件包括展示控制台的 Controller 、微服务节点实例的模型和管理组件、<code>EurekaServerContext</code>、<code>EurekaServerBootstrap</code>（启动引导类）、两个过滤器。</li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EurekaServer </tag>
            
            <tag> SpringCloudNetflix </tag>
            
            <tag> 服务发现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式容器：嵌入式Tomcat的优化和配置</title>
      <link href="/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在以往的开发中我们可能会根据项目本身对 Tomcat 进行一些调整，以达到最大化利用 Tomcat 的目的。SpringBoot 使用嵌入式 Tomcat，再像之前那样做 Tomcat 性能调优就显得不那么现实了，为此我们需要了解如何在 SpringBoot 内部给嵌入式 Tomcat 做性能调优。本篇文章只做定<strong>性</strong>的解析，深入到<strong>量</strong>的控制本文不作详细探讨。</p><h2 id="0-调优前的准备"><a href="#0-调优前的准备" class="headerlink" title="0. 调优前的准备"></a>0. 调优前的准备</h2><p>为测试当前 SpringBoot 中嵌入式 Tomcat 的最大性能，需要一个压力测试工具来辅助我们测试性能，目前应用比较多的压测工具有 <strong>Bench</strong> 和 <strong>JMeter</strong> ，本文中使用 <code>Bench</code> 作为压测工具。</p><p>测试之前，咱先把工具准备好：</p><ul><li>Bench：<a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">https://www.apachelounge.com/download/</a></li><li>JMeter：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></li></ul><p>下载好之后，把这两个工具的环境变量都配置好，方便直接从控制台执行。</p><p>除此之外，把一开始的测试工程中加入一个测试的 <code>DemoController</code> ，用于接收请求压测（为模拟真实业务场景，会在 <code>DemoController</code> 中让线程随机阻塞 <code>100 - 500ms</code> ，以代替数据库连接和业务查询）。最后，把工程打成可执行jar包并启动，等待测试。</p><p>jar包启动的方式非常简单：<code>java -jar demo-0.0.1-SNAPSHOT.jar</code> </p><p>（本文在进行压测时的物理环境：Windows10 + Intel Core i7-8750H）</p><h2 id="1-使用Bench进行压测"><a href="#1-使用Bench进行压测" class="headerlink" title="1. 使用Bench进行压测"></a>1. 使用Bench进行压测</h2><p>在cmd中执行如下命令：</p><p><code>ab -n 10000 -c 500 http://localhost:8080/test</code></p><p>执行完成后会在控制台打印测试报告：（<strong>报告中的指标解释已标注在行尾</strong>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="string">This</span> <span class="string">is</span> <span class="string">ApacheBench,</span> <span class="string">Version</span> <span class="number">2.3</span> <span class="string">&lt;$Revision:</span> <span class="number">1843412</span> <span class="string">$&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">Copyright</span> <span class="number">1996</span> <span class="string">Adam</span> <span class="string">Twiss,</span> <span class="string">Zeus</span> <span class="string">Technology</span> <span class="string">Ltd,</span> <span class="string">http://www.zeustech.net/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="string">Licensed</span> <span class="string">to</span> <span class="string">The</span> <span class="string">Apache</span> <span class="string">Software</span> <span class="string">Foundation,</span> <span class="string">http://www.apache.org/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">Benchmarking</span> <span class="string">localhost</span> <span class="string">(be</span> <span class="string">patient)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">1000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">2000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">3000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">4000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">5000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">6000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">7000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">8000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">9000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="string">Completed</span> <span class="number">10000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="string">Finished</span> <span class="number">10000</span> <span class="string">requests</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Server Software:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Server Hostname:</span>        <span class="string">localhost</span> <span class="string">//</span> <span class="string">主机名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Server Port:</span>            <span class="number">8080</span>      <span class="string">//</span> <span class="string">端口号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Document Path:</span>          <span class="string">/test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Document Length:</span>        <span class="number">4</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">500</span>            <span class="string">//</span> <span class="string">并发量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">15.670</span> <span class="string">seconds</span> <span class="string">//</span> <span class="string">所有请求的总耗时</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">10000</span>          <span class="string">//</span> <span class="string">成功的请求数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">1360000</span> <span class="string">bytes</span>  <span class="string">//</span> <span class="string">总传输数据量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">40000</span> <span class="string">bytes</span>    <span class="string">//</span> <span class="string">总响应数据量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">638.17</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span> <span class="string">//</span> <span class="string">【重要】每秒执行的请求数量（吞吐量）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">783.493</span> <span class="string">[ms]</span> <span class="string">(mean)</span>   <span class="string">//</span> <span class="string">【重要】客户端平均响应时间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">1.567</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span> <span class="string">//</span> <span class="string">服务器平均请求等待时间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">84.76</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span> <span class="string">//</span> <span class="string">每秒传输的数据量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="string">Connection</span> <span class="string">Times</span> <span class="string">(ms)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">              <span class="string">min</span>  <span class="string">mean[+/-sd]</span> <span class="string">median</span>   <span class="string">max</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Connect:</span>        <span class="number">0</span>    <span class="number">0</span>   <span class="number">0.2</span>      <span class="number">0</span>       <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Processing:</span>   <span class="number">105</span>  <span class="number">738</span> <span class="number">135.1</span>    <span class="number">742</span>     <span class="number">993</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Waiting:</span>      <span class="number">105</span>  <span class="number">738</span> <span class="number">135.2</span>    <span class="number">742</span>     <span class="number">993</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total:</span>        <span class="number">105</span>  <span class="number">738</span> <span class="number">135.1</span>    <span class="number">742</span>     <span class="number">993</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="string">Percentage</span> <span class="string">of</span> <span class="string">the</span> <span class="string">requests</span> <span class="string">served</span> <span class="string">within</span> <span class="string">a</span> <span class="string">certain</span> <span class="string">time</span> <span class="string">(ms)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">  <span class="number">50</span><span class="string">%</span>    <span class="number">742</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">  <span class="number">66</span><span class="string">%</span>    <span class="number">810</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">  <span class="number">75</span><span class="string">%</span>    <span class="number">847</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">  <span class="number">80</span><span class="string">%</span>    <span class="number">868</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">  <span class="number">90</span><span class="string">%</span>    <span class="number">909</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">  <span class="number">95</span><span class="string">%</span>    <span class="number">931</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">  <span class="number">98</span><span class="string">%</span>    <span class="number">945</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">  <span class="number">99</span><span class="string">%</span>    <span class="number">952</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"> <span class="number">100</span><span class="string">%</span>    <span class="number">993</span> <span class="string">(longest</span> <span class="string">request)</span></span></pre></td></tr></table></figure><p>在测试报告中有两个重要的指标需要咱来关注：</p><ul><li><strong>Requests per second</strong>：每秒执行的请求数量（吞吐量）<ul><li>吞吐量越高，代表性能越好</li></ul></li><li><strong>Time per request</strong>：客户端平均响应时间<ul><li>响应时间越短，代表性能越好</li></ul></li></ul><p>在这里面测得的结果是 638.17 的吞吐量，783.493ms 的平均响应时间，这个响应时间比代码中控制的阻塞时间更长，说明 Tomcat 对500的并发已经有一些吃力了。</p><p>下面咱再用更大的并发量来测试效果：</p><p><code>ab -n 50000 -c 2000 http://localhost:8080/test</code></p><p>测得的结果（截取主要部分）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">75.689</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">660.60</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">3027.564</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">1.514</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">87.74</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>发现<strong>吞吐量没有什么太大的变化</strong>，但<strong>平均响应时间大幅提升，且大概为上面的4倍</strong>。可以看得出来，Tomcat 的处理速度已经远远跟不上请求到来的速度，需要进行性能调优。</p><h2 id="2-嵌入式Tomcat调优依据"><a href="#2-嵌入式Tomcat调优依据" class="headerlink" title="2. 嵌入式Tomcat调优依据"></a>2. 嵌入式Tomcat调优依据</h2><p>调优一定要有依据，咱根据现状和之前对 SpringBoot 的学习和原理剖析，应该知道配置大多都是两种形式：</p><ul><li>声明式配置：<code>application.properties</code> 或 <code>application.yml</code></li><li>编程式配置：<code>XXXConfigurer</code> 或 <code>XXXCustomizer</code></li></ul><p>其中，利用配置文件进行配置，最终会映射到 SpringBoot 中的一些 Properties 类中，例如 <code>server.port</code> 配置会映射到 <code>ServerProperties</code> 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"server"</span>, ignoreUnknownFields = <span class="keyword">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Integer port;</span></pre></td></tr></table></figure><p>那我们来大体分析一下对于 Tomcat 的声明式配置，都有哪些可以控制的部分：</p><h3 id="2-1-Tomcat的声明式配置"><a href="#2-1-Tomcat的声明式配置" class="headerlink" title="2.1 Tomcat的声明式配置"></a>2.1 Tomcat的声明式配置</h3><p>在 <code>ServerProperties</code> 类中，有一个 Tomcat 的静态内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Tomcat properties.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tomcat</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// ......</span></span></pre></td></tr></table></figure><p>这里面就是配置嵌入式 Tomcat 的可以供我们配置的映射配置类。咱来看里面的核心属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Maximum amount of worker threads.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 最大工作线程数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxThreads = <span class="number">200</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Minimum amount of worker threads.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 最小工作线程数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minSpareThreads = <span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Maximum number of connections that the server accepts and processes at any</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * given time. Once the limit has been reached, the operating system may still</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * accept connections based on the "acceptCount" property.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 服务器最大连接数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxConnections = <span class="number">10000</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Maximum queue length for incoming connection requests when all possible request</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * processing threads are in use.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 最大请求队列等待长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> acceptCount = <span class="number">100</span>;</span></pre></td></tr></table></figure><p>可以发现这里面的几个指标，分别控制连接数、线程数、等待数。</p><p>咱来分析为什么上面的吞吐量不够大：请求中的关键耗时动作是 <code>Thread.sheep</code> 卡线程，导致吞吐量变大。<code>Thread.sleep</code> 模拟了IO操作、数据库交互等<strong>非CPU高速计算的行为</strong>，在数据库交互时，CPU资源被浪费，导致无法处理后来的请求，出现资源利用率低的现象。为此，我们需要提高请求并发数，以此来提高CPU利用率。提高请求并发的方法在上面的几个参数中很明显是 <strong><code>maxThreads</code></strong> 。</p><h2 id="3-调整maxThreads"><a href="#3-调整maxThreads" class="headerlink" title="3. 调整maxThreads"></a>3. 调整maxThreads</h2><p>从源码中很明显看到默认的最大线程数是200，我们在 <code>application.properties</code> 中修改值为 500：</p><p><code>server.tomcat.max-threads=500</code></p><p>修改之后的测试：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">30.910</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">1617.61</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">1236.391</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">0.618</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">214.84</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>发现吞吐量有明显的提升，且吞吐量的放大倍数大概是前面线程数为 200 时的2.5倍。继续放大该值为 2000：</p><p><code>server.tomcat.max-threads=2000</code></p><p>重新测试效果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">12.050</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">4149.38</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">482.000</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">0.241</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">551.09</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>吞吐量又一次明显上升，但注意此时的吞吐量并没有扩大到上一次的 4 倍。继续放大该值为 10000：</p><p><code>server.tomcat.max-threads=10000</code></p><p>重新测试效果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Concurrency Level:</span>      <span class="number">2000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time taken for tests:</span>   <span class="number">13.808</span> <span class="string">seconds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Complete requests:</span>      <span class="number">50000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Failed requests:</span>        <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Total transferred:</span>      <span class="number">6800000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">HTML transferred:</span>       <span class="number">200000</span> <span class="string">bytes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Requests per second:</span>    <span class="number">3621.22</span> <span class="string">[#/sec]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">552.300</span> <span class="string">[ms]</span> <span class="string">(mean)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Time per request:</span>       <span class="number">0.276</span> <span class="string">[ms]</span> <span class="string">(mean,</span> <span class="string">across</span> <span class="string">all</span> <span class="string">concurrent</span> <span class="string">requests)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="attr">Transfer rate:</span>          <span class="number">480.94</span> <span class="string">[Kbytes/sec]</span> <span class="string">received</span></span></pre></td></tr></table></figure><p>发现吞吐量竟然下降了！为什么会出现这种现象呢？</p><h2 id="4-现象解释"><a href="#4-现象解释" class="headerlink" title="4. 现象解释"></a>4. 现象解释</h2><p>要解释这个原因，就不得不提到 CPU 的工作原理了。当CPU的<strong>核心线程数</strong>小于当前应用线程时，CPU为了保证所有应用线程都正常执行，它会<strong>在多个线程中来回切换</strong>，以保证每个线程都能获得CPU时间。在一个确定的时间点中，一个CPU只能处理一个线程。</p><p>所以这个现象就可以这样解释：当开启的 Tomcat 线程过多时，CPU会消耗大量时间在这些 Tomcat 线程中来回切换，导致真正处理业务请求的时间变少，最终导致整体应用处理速度变慢。</p><p>由此也可以推出另一种可能：如果业务逻辑中有大量CPU处理工作（如运算、处理数据等），则CPU需要更多的时间用于计算，此时若 Tomcat 线程过多，则处理速度会更慢。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>由上面的情况可以总结出以下结论：</p><ul><li>应用中大部分业务逻辑都是阻塞型处理（IO、数据库操作等），这种情况下CPU的压力较低，可以适当调大 <code>maxThreads</code> 的值大小。</li><li>应用中大部分业务逻辑都是数据处理和计算，这种情况下CPU的压力较大，应适当调小 <code>maxThreads</code> 的值大小。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Tomcat </tag>
            
            <tag> 嵌入式容器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
