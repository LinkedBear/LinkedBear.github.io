<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="LinkedBear的GitHub博客"><meta name="keywords" content="LinkedBear, SpringBoot, 源码"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>服务发现-EurekaServer的初始化和启动原理 | LinkedBear的GitHub</title><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">服务发现-EurekaServer的初始化和启动原理</h1><a id="logo" href="/.">LinkedBear的GitHub</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 所有文章</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/juejin/"><i class="fa fa-rss"> 掘金小册</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">服务发现-EurekaServer的初始化和启动原理</h1><div class="post-meta"><a href="/2019/12/04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-EurekaServer%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/#comments" class="comment-count"></a><p><span class="date">Dec 04, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>刚学习 SpringCloud 的时候先要学习注册中心，也就是服务发现与治理。SpringCloudNetflix 的方案是使用 Eureka，咱也都很清楚了，下面咱先搭建一个只有 EurekaServer 的工程。</p>
<p>pom依赖只需要两个：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>

<p>启动类上标注 <code>@EnableEurekaServer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        SpringApplication.run(EurekaServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>application.yml</code> 中配置一些最基础的信息：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">application:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">instance:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka-server</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">client:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">service-url:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9000/eureka/</span></span></pre></td></tr></table></figure>

<p>之后运行主启动类，EurekaServer 便会运行在9000端口上。</p>
<p>如果不标注 <code>@EnableEurekaServer</code> 注解，即便导入依赖也不会启动 EurekaServer，说明真正打开 EurekaServer 的是 <code>@EnableEurekaServer</code> 注解。</p>
<h2 id="1-EnableEurekaServer"><a href="#1-EnableEurekaServer" class="headerlink" title="1. @EnableEurekaServer"></a>1. @EnableEurekaServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(EurekaServerMarkerConfiguration<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableEurekaServer</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>它的文档注释非常简单：</p>
<blockquote>
<p>Annotation to activate Eureka Server related configuration.</p>
<p>用于激活 EurekaServer 相关配置的注解。</p>
</blockquote>
<p>它被标注了一个 <code>@Import</code> 注解，导入的是一个 <code>EurekaServerMarkerConfiguration</code> 的配置类。</p>
<blockquote>
<p>如果小伙伴对 @Import 注解还不是很了解，可以移步我的 《<a href="https://juejin.im/book/5da3bc3d6fb9a04e35597a76" target="_blank" rel="noopener">SpringBoot源码解读与原理分析</a>》小册，先了解 SpringFramework 的基础。</p>
</blockquote>
<h2 id="2-EurekaServerMarkerConfiguration"><a href="#2-EurekaServerMarkerConfiguration" class="headerlink" title="2. EurekaServerMarkerConfiguration"></a>2. EurekaServerMarkerConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerMarkerConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> Marker <span class="title">eurekaServerMarkerBean</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Marker();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Marker</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这段源码看上去莫名其妙的，它是一个配置类，然后它定义了一个 <code>Marker</code> 的内部类，又注册了一个Bean，但这光秃秃的，也没点别的逻辑，它到底想干啥？果然还是得靠文档注释：</p>
<blockquote>
<p>Responsible for adding in a marker bean to activate EurekaServerAutoConfiguration.</p>
<p>负责添加标记Bean来激活 <code>EurekaServerAutoConfiguration</code> 。</p>
</blockquote>
<p>好吧，原来它的作用是<strong>给IOC容器中添加一个标记，代表要启用 <code>EurekaServerAutoConfiguration</code> 的自动配置类</strong>。</p>
<p>那咱就移步 <code>EurekaServerAutoConfiguration</code> 来看它的定义了。</p>
<h2 id="3-EurekaServerAutoConfiguration"><a href="#3-EurekaServerAutoConfiguration" class="headerlink" title="3. EurekaServerAutoConfiguration"></a>3. EurekaServerAutoConfiguration</h2><p>看到 AutoConfiguration 结尾的类，咱马上要想到：这个类肯定在 <code>spring.factories</code> 文件标注好了，不然没法生效。</p>
<p>果然，在 <code>spring-cloud-netflix-eureka-server</code> 的 jar 包中发现了一个 <code>spring.factories</code> 文件，而文件内部的声明就是如此的简单：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration</span></span></pre></td></tr></table></figure>

<p>没得跑，来看它的定义和声明吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(EurekaServerInitializerConfiguration<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class">@<span class="title">ConditionalOnBean</span>(<span class="title">EurekaServerMarkerConfiguration</span>.<span class="title">Marker</span>.<span class="title">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(</span>&#123; EurekaDashboardProperties<span class="class">.<span class="keyword">class</span>,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class">		<span class="title">InstanceRegistryProperties</span>.<span class="title">class</span> &#125;)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">@PropertySource("classpath:/eureka/server.properties")</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span></span></pre></td></tr></table></figure>

<p>注意看 <code>@ConditionalOnBean</code> 的条件：必须IOC容器中有一个 <code>EurekaServerMarkerConfiguration.Marker</code> 类型的 Bean，该配置类才会生效！（原来它是这样做自动配置开关的）</p>
<p>注意到它继承了 <code>WebMvcConfigurerAdapter</code> ，但全篇没有找到跟 <code>WebMvcConfigurer</code> 相关的部分，也没重写对应的方法。那它这是几个意思？这个时候咱要了解一个小背景：</p>
<blockquote>
<p>在 SpringFramework5.0+ 后，因为接口可以直接声明 default 方法，所以 <code>WebMvcConfigurerAdapter</code> 被废弃（被标注 <code>@Deprecated</code>），替代方案是直接实现 <code>WebMvcConfigurer</code> 接口。</p>
</blockquote>
<p>那既然是这样， 它还继承着这个适配器类，那咱可以大概猜测：它应该是旧版本的遗留。</p>
<p>回到正题，咱看 <code>EurekaServerAutoConfiguration</code> 的类定义声明上还有什么值得注意的。除了上面说的，那就只剩下一个了：它导入了一个 <code>EurekaServerInitializerConfiguration</code> 。</p>
<h2 id="4-EurekaServerInitializerConfiguration"><a href="#4-EurekaServerInitializerConfiguration" class="headerlink" title="4. EurekaServerInitializerConfiguration"></a>4. EurekaServerInitializerConfiguration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerInitializerConfiguration</span> <span class="keyword">implements</span> <span class="title">ServletContextAware</span>, <span class="title">SmartLifecycle</span>, <span class="title">Ordered</span></span></span></pre></td></tr></table></figure>

<p>注意它实现了 <code>SmartLifecycle</code> 接口，之前咱在《SpringBoot源码解读与原理分析》原理小册中提到过（第16篇 12.2.2章节），如果小伙伴们对这部分不了解，可以移步我的 《<a href="https://juejin.im/book/5da3bc3d6fb9a04e35597a76" target="_blank" rel="noopener">SpringBoot源码解读与原理分析</a>》小册，这里咱直接说，它的核心方法是 <code>start</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> is this class even needed now?</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 初始化、启动 EurekaServer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                eurekaServerBootstrap.contextInitialized(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                        EurekaServerInitializerConfiguration.<span class="keyword">this</span>.servletContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                log.info(<span class="string">"Started Eureka Server"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 发布Eureka已注册的事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                publish(<span class="keyword">new</span> EurekaRegistryAvailableEvent(getEurekaServerConfig()));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 修改 EurekaServer 的运行状态</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                EurekaServerInitializerConfiguration.<span class="keyword">this</span>.running = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// 发布Eureka已启动的事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                publish(<span class="keyword">new</span> EurekaServerStartedEvent(getEurekaServerConfig()));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;).start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>（至此应该进一步意识到为什么上面 <code>EurekaServerAutoConfiguration</code> 继承了一个过时的类，<code>Runnable</code> 都没换成 Lambda 表达式。。。当然也跟 Eureka 1.x 不继续更新有关吧）</p>
<p>这个 <code>start</code> 方法只干了一件事，起一个新的线程来启动 EurekaServer 。这里面核心的 <strong>run</strong> 方法执行了这么几件事，都已经标注在源码中了。</p>
<p>这里面最重要的步骤就是第一步：<strong>初始化、启动 EurekaServer</strong> 。</p>
<p>在继续展开这部分源码之前，要带小伙伴了解一点前置知识。</p>
<p>EurekaServer 本身应该是一个完整的 Servlet 应用，在原生的 EurekaServer 中，<code>EurekaServerBootstrap</code> 这个类会实现 <code>ServletContextListener</code> 接口（Servlet3.0规范）来引导启动 EurekaServer 。SpringBoot 应用一般使用嵌入式 Web 容器，没有所谓 Servlet3.0 规范作用的机会了，所以需要另外的启动方式，于是 SpringCloud 在整合这部分时，借助了IOC容器中支持的 <code>LifeCycle</code> 机制，来以此触发 EurekaServer 的启动。</p>
<h3 id="4-0-eurekaServerBootstrap-contextInitialized：初始化、启动EurekaServer"><a href="#4-0-eurekaServerBootstrap-contextInitialized：初始化、启动EurekaServer" class="headerlink" title="4.0 eurekaServerBootstrap.contextInitialized：初始化、启动EurekaServer"></a>4.0 eurekaServerBootstrap.contextInitialized：初始化、启动EurekaServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContext context)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        initEurekaEnvironment();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        initEurekaServerContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        context.setAttribute(EurekaServerContext<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">this</span>.<span class="title">serverContext</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里面又分为两个部分，依此来看：</p>
<h3 id="4-1-initEurekaEnvironment：初始化Eureka的运行环境"><a href="#4-1-initEurekaEnvironment：初始化Eureka的运行环境" class="headerlink" title="4.1 initEurekaEnvironment：初始化Eureka的运行环境"></a>4.1 initEurekaEnvironment：初始化Eureka的运行环境</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST = <span class="string">"test"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT = <span class="string">"default"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    log.info(<span class="string">"Setting the eureka configuration.."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Eureka的数据中心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    String dataCenter = ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            .getString(EUREKA_DATACENTER);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (dataCenter == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        log.info(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                <span class="string">"Eureka data center value eureka.datacenter is not set, defaulting to default"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Eureka运行环境</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    String environment = ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            .getString(EUREKA_ENVIRONMENT);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        log.info(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                <span class="string">"Eureka environment value eureka.environment is not set, defaulting to test"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        ConfigurationManager.getConfigInstance()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                .setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, environment);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里面的逻辑咱乍一看，貌似都长得差不多啊，都是 <strong>获取 → 判断 → 设置</strong> ，而且它们都有对应的默认值（源码中已标注）。至于这部分是干嘛的呢，咱不得不关注一下 <code>setProperty</code> 方法中的两个常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_DATACENTER = <span class="string">"archaius.deployment.datacenter"</span>;</span></pre></td></tr></table></figure>

<p>配置项的前缀是 <code>archaius</code> ，它是 Netflix 旗下的一个配置管理组件（提到这里，是不是产生了一种感觉：它会不会跟 SpringCloudConfig 有关系？然而并不是，当引入 SpringCloudConfig 时，archaius 并不会带进来），这个组件可以实现更强大的动态配置，它的基底是 <strong>Apache</strong> 的 <code>commons-configuration</code> ：</p>
<p>![](服务发现-EurekaServer的初始化和启动原理/3. archaius的底层依赖是commons-configuration.png)</p>
<p>对于这个组件，小册不展开研究了，小伙伴们只需要知道有这么回事就可以了，下面的才是重点。</p>
<h3 id="4-2-initEurekaServerContext：初始化EurekaServer的运行上下文"><a href="#4-2-initEurekaServerContext：初始化EurekaServer的运行上下文" class="headerlink" title="4.2 initEurekaServerContext：初始化EurekaServer的运行上下文"></a>4.2 initEurekaServerContext：初始化EurekaServer的运行上下文</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaServerContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// For backward compatibility  兼容低版本Eureka</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    JsonXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            XStream.PRIORITY_VERY_HIGH);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    XmlXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            XStream.PRIORITY_VERY_HIGH);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (isAws(<span class="keyword">this</span>.applicationInfoManager.getInfo())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.awsBinder = <span class="keyword">new</span> AwsBinderDelegate(<span class="keyword">this</span>.eurekaServerConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">this</span>.eurekaClientConfig, <span class="keyword">this</span>.registry, <span class="keyword">this</span>.applicationInfoManager);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.awsBinder.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 注册EurekaServerContextHolder，通过它可以很方便的获取EurekaServerContext</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    EurekaServerContextHolder.initialize(<span class="keyword">this</span>.serverContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    log.info(<span class="string">"Initialized server context"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Copy registry from neighboring eureka node</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Eureka复制集群节点注册表</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> registryCount = <span class="keyword">this</span>.registry.syncUp();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.registry.openForTraffic(<span class="keyword">this</span>.applicationInfoManager, registryCount);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Register all monitoring statistics.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    EurekaMonitors.registerAllStats();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>前面的一大段都是为了低版本兼容而做的一些额外工作，咱不关心这些。中间又是注册了一个 注册<code>EurekaServerContextHolder</code> 的组件，通过它可以直接获取 <code>EurekaServerContext</code> （它的内部使用简单的单例实现，实现非常简单，小伙伴可自行查看）。</p>
<p>注意最后几行，倒数第二个单行注释的内容：</p>
<blockquote>
<p>Copy registry from neighboring eureka node。</p>
<p>从相邻的eureka节点复制注册表。</p>
</blockquote>
<p>节点复制注册表？这很明显是为了 Eureka 集群而设计的！由此可知 Eureka 集群能保证后起来的节点也不会出问题，是这里同步了注册表啊！这一步的操作非常复杂，咱后续另开一篇解释。</p>
<p>除了这部分之外，<code>EurekaServerInitializerConfiguration</code> 已经没有要配置的组件，回到 <code>EurekaServerAutoConfiguration</code> 中。</p>
<h2 id="5-EurekaServerAutoConfiguration中配置的核心组件"><a href="#5-EurekaServerAutoConfiguration中配置的核心组件" class="headerlink" title="5. EurekaServerAutoConfiguration中配置的核心组件"></a>5. EurekaServerAutoConfiguration中配置的核心组件</h2><h3 id="5-1-EurekaController"><a href="#5-1-EurekaController" class="headerlink" title="5.1 EurekaController"></a>5.1 EurekaController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"eureka.dashboard"</span>, name = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaController <span class="title">eurekaController</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EurekaController(<span class="keyword">this</span>.applicationInfoManager);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>呦，一看这是个 Controller ，有木有立马想到自己写的那些 Controller ？赶紧点进去瞅一眼：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;eureka.dashboard.path:/&#125;"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaController</span></span></span></pre></td></tr></table></figure>

<p>哇塞果然是我们熟悉的 SpringWebMvc 的内容！既然是一个 Controller ，那它肯定能给咱定义了一些处理方法，不然咱咋看到的 Eureka 控制台呢？翻看源码，它这里面定义了两个处理方法，分别是： <code>status</code> - 获取当前 EurekaServer 的状态（即控制台）、<code>lastn</code> - 获取当前 EurekaServer 上服务注册动态历史记录。这部分咱不展开描述了，有兴趣的小伙伴们可以深入这个类来研究。</p>
<h3 id="5-2-PeerAwareInstanceRegistry"><a href="#5-2-PeerAwareInstanceRegistry" class="headerlink" title="5.2 PeerAwareInstanceRegistry"></a>5.2 PeerAwareInstanceRegistry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PeerAwareInstanceRegistry <span class="title">peerAwareInstanceRegistry</span><span class="params">(ServerCodecs serverCodecs)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.eurekaClient.getApplications(); <span class="comment">// force initialization</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InstanceRegistry(<span class="keyword">this</span>.eurekaServerConfig, <span class="keyword">this</span>.eurekaClientConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            serverCodecs, <span class="keyword">this</span>.eurekaClient,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.instanceRegistryProperties.getExpectedNumberOfClientsSendingRenews(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.instanceRegistryProperties.getDefaultOpenForTrafficCount());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个 <code>PeerAwareInstanceRegistry</code> 很重要，它是 <strong>EurekaServer 集群中节点之间同步微服务实例注册表的核心组件</strong>（这里默认小伙伴已经对 EurekaServer 的集群配置及相关基础都了解了）。集群节点同步注册表的内容咱会另起一篇研究，这里咱只是看一下这个类的继承结构，方面后续看到时不至于不认识：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceRegistry</span> <span class="keyword">extends</span> <span class="title">PeerAwareInstanceRegistryImpl</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">PeerAwareInstanceRegistryImpl</span> <span class="keyword">extends</span> <span class="title">AbstractInstanceRegistry</span> <span class="keyword">implements</span> <span class="title">PeerAwareInstanceRegistry</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">AbstractInstanceRegistry</span> <span class="keyword">implements</span> <span class="title">InstanceRegistry</span></span></span></pre></td></tr></table></figure>

<p>这里面继承的两个类 <code>PeerAwareInstanceRegistryImpl</code> 、<code>AbstractInstanceRegistry</code> ，它们将会在后续研究节点同步时有重要作用，包括里面涉及的功能会在后面的组件（<code>EurekaServerContext</code> 等）发挥功能时带着一起解释。</p>
<h3 id="5-3-PeerEurekaNodes"><a href="#5-3-PeerEurekaNodes" class="headerlink" title="5.3 PeerEurekaNodes"></a>5.3 PeerEurekaNodes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PeerEurekaNodes <span class="title">peerEurekaNodes</span><span class="params">(PeerAwareInstanceRegistry registry, ServerCodecs serverCodecs,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        ReplicationClientAdditionalFilters replicationClientAdditionalFilters)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RefreshablePeerEurekaNodes(registry, <span class="keyword">this</span>.eurekaServerConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.eurekaClientConfig, serverCodecs, <span class="keyword">this</span>.applicationInfoManager,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            replicationClientAdditionalFilters);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个 <code>PeerEurekaNodes</code> 可以理解成<strong>微服务实例的节点集合</strong>。换言之，一个 <code>PeerEurekaNode</code> 就是一个微服务节点实例的包装，<code>PeerEurekaNodes</code> 就是这组 <code>PeerEurekaNode</code> 的集合，这种节点是可以被 EurekaServer 集群中的各个注册中心节点共享的（<code>PeerAwareInstanceRegistry</code>）。翻开 PeerEurekaNodes 的结构，可以发现它的结构中有这么几样东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</span></pre></td></tr></table></figure>

<ul>
<li><code>PeerAwareInstanceRegistry</code> ：集群间节点同步的核心组件</li>
<li><code>List&lt;PeerEurekaNode&gt;</code> ：节点集合</li>
<li><code>peerEurekaNodeUrls</code> ：所有节点所在url</li>
<li><code>ScheduledExecutorService</code> ：执行定时任务的线程池</li>
</ul>
<p>另外 <code>PeerEurekaNodes</code> 还提供了一个 <code>start</code> 和 <code>shutdown</code> 方法：</p>
<h4 id="5-3-1-start"><a href="#5-3-1-start" class="headerlink" title="5.3.1 start"></a>5.3.1 start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    taskExecutor = Executors.newSingleThreadScheduledExecutor(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">new</span> ThreadFactory() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                    Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                    thread.setDaemon(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">return</span> thread;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        updatePeerEurekaNodes(resolvePeerUrls());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                    updatePeerEurekaNodes(resolvePeerUrls());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        taskExecutor.scheduleWithFixedDelay(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                peersUpdateTask,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                TimeUnit.MILLISECONDS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ...... log ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以发现 start 方法的核心是<strong>借助线程池完成定时任务</strong>。定时任务的内容是中间那一段实现了 <code>Runnable</code> 接口的匿名内部类，它会执行一个 <code>updatePeerEurekaNodes</code> 方法来更新集群节点。下面定时任务的执行时间，借助IDEA跳转到 <code>EurekaServerConfigBean</code> 中发现默认的配置是 10 分钟，即<strong>每隔10分钟会同步一次集群节点</strong>。至于 <code>updatePeerEurekaNodes</code> 的具体实现，咱同样放到后面跟节点同步放在一起来解析。</p>
<h4 id="5-3-2-shutdown"><a href="#5-3-2-shutdown" class="headerlink" title="5.3.2 shutdown"></a>5.3.2 shutdown</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    taskExecutor.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    List&lt;PeerEurekaNode&gt; toRemove = <span class="keyword">this</span>.peerEurekaNodes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = Collections.emptyList();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.peerEurekaNodeUrls = Collections.emptySet();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (PeerEurekaNode node : toRemove) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        node.shutDown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个方法的内容比较简单，它会把线程池的定时任务停掉，并移除掉当前所有的服务节点信息。它被调用的时机是下面要解析的 <code>EurekaServerContext</code> 。</p>
<h3 id="5-4-EurekaServerContext"><a href="#5-4-EurekaServerContext" class="headerlink" title="5.4 EurekaServerContext"></a>5.4 EurekaServerContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaServerContext <span class="title">eurekaServerContext</span><span class="params">(ServerCodecs serverCodecs,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        PeerAwareInstanceRegistry registry, PeerEurekaNodes peerEurekaNodes)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultEurekaServerContext(<span class="keyword">this</span>.eurekaServerConfig, serverCodecs,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            registry, peerEurekaNodes, <span class="keyword">this</span>.applicationInfoManager);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>它创建了一个 <code>DefaultEurekaServerContext</code> ，文档注释原文翻译：</p>
<blockquote>
<p>Represent the local server context and exposes getters to components of the local server such as the registry.</p>
<p>表示本地服务器上下文，并将 getter 方法暴露给本地服务器的组件（例如注册表）。</p>
</blockquote>
<p>可以大概的意识到，它确实跟 SpringFramework 的 <code>ApplicationContext</code> 差不太多哈，可以这么简单地理解吧，咱还是看看里面比较特殊的内容。</p>
<p>进入到 <code>DefaultEurekaServerContext</code> 中，果然发现了两个特殊的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Initializing ..."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    peerEurekaNodes.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        registry.init(peerEurekaNodes);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Initialized"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Shutting down ..."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    registry.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    peerEurekaNodes.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Shut down"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>果然，是 <code>EurekaServerContext</code> 的初始化，带动 <code>PeerEurekaNodes</code> 的初始化，<code>EurekaServerContext</code> 的销毁带动 <code>PeerEurekaNodes</code> 的销毁。除了带动 <code>PeerEurekaNodes</code> 之前，还有一个 <code>PeerAwareInstanceRegistry</code> 也带动初始化了，看一眼它的 <code>init</code> 方法吧：</p>
<h4 id="5-4-1-PeerAwareInstanceRegistry-init"><a href="#5-4-1-PeerAwareInstanceRegistry-init" class="headerlink" title="5.4.1 PeerAwareInstanceRegistry#init"></a>5.4.1 PeerAwareInstanceRegistry#init</h4><p>关键部分注释已标注在源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(PeerEurekaNodes peerEurekaNodes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 5.4.1.1 启动续订租约的频率统计器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.numberOfReplicationsLastMin.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.peerEurekaNodes = peerEurekaNodes;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    initializedResponseCache();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 5.4.1.2 开启续订租约最低阈值检查的定时任务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    scheduleRenewalThresholdUpdateTask();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 5.4.1.3 初始化远程分区注册中心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    initRemoteRegionRegistry();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Monitors.registerObject(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        logger.warn(<span class="string">"Cannot register the JMX monitor for the InstanceRegistry :"</span>, e);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>源码标注了三个关键的环节，一一来看：</p>
<h5 id="5-4-1-1-numberOfReplicationsLastMin-start-：启动续订租约的频率统计器"><a href="#5-4-1-1-numberOfReplicationsLastMin-start-：启动续订租约的频率统计器" class="headerlink" title="5.4.1.1 numberOfReplicationsLastMin.start()：启动续订租约的频率统计器"></a>5.4.1.1 numberOfReplicationsLastMin.start()：启动续订租约的频率统计器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong currentBucket = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sampleInterval;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!isActive) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// Zero out the current bucket.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                    lastBucket.set(currentBucket.getAndSet(<span class="number">0</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                    logger.error(<span class="string">"Cannot reset the Measured Rate"</span>, e);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;, sampleInterval, sampleInterval);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        isActive = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个方法实现不难理解，它会隔一段时间重置 <code>lastBucket</code> 和 <code>currentBucket</code> 的值为0，那时间间隔是多少呢？翻看整个类，发现只有构造方法可以设置时间间隔：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MeasuredRate</span><span class="params">(<span class="keyword">long</span> sampleInterval)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.sampleInterval = sampleInterval;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.timer = <span class="keyword">new</span> Timer(<span class="string">"Eureka-MeasureRateTimer"</span>, <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.isActive = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>借助IDEA，发现设置 <code>sampleInterval</code> 的值有两处，但值都是一样的：<code>new MeasuredRate(1000 * 60 * 1);</code> ，也就是<strong>1分钟重置一次</strong>。可关键的问题是，它这个操作是干嘛呢？为啥非得一分钟统计一次续约次数呢？实际上，这个计算次数会体现在 Eureka 的控制台，以及配合 <strong>Servo</strong> 完成<strong>续约次数监控</strong>（说白了，咱这看着没啥用，微服务监控和治理还是管用的，不然为什么 Eureka 被称为<strong>服务发现与治理</strong>的框架呢）。</p>
<h5 id="5-4-1-2-scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务"><a href="#5-4-1-2-scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务" class="headerlink" title="5.4.1.2 scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务"></a>5.4.1.2 scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> renewalThresholdUpdateIntervalMs = <span class="number">15</span> * MINUTES;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleRenewalThresholdUpdateTask</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                       <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                           updateRenewalThreshold();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                       &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                   &#125;, serverConfig.getRenewalThresholdUpdateIntervalMs(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            serverConfig.getRenewalThresholdUpdateIntervalMs());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>又是一个定时任务，配置项中的默认时间间隔可以发现是15分钟。那定时任务中执行的核心方法是 <code>updateRenewalThreshold</code> 方法，跳转过去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRenewalThreshold</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        Applications apps = eurekaClient.getApplications();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isRegisterable(instance)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    ++count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Update threshold only if the threshold is greater than the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// current expected threshold or if self preservation is disabled.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((count) &gt; (serverConfig.getRenewalPercentThreshold() * expectedNumberOfClientsSendingRenews)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                    || (!<span class="keyword">this</span>.isSelfPreservationModeEnabled())) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">this</span>.expectedNumberOfClientsSendingRenews = count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                updateRenewsPerMinThreshold();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        logger.info(<span class="string">"Current renewal threshold is : &#123;&#125;"</span>, numberOfRenewsPerMinThreshold);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面的 for 循环很明显是检查当前已经注册到本地的服务实例是否还保持连接，由于该方法一定会返回 true （可翻看该部分实现，全部都是 <code>return true</code>），故上面统计的 count 就是所有的微服务实例数量。</p>
<p>下面的同步代码块中，它会检查统计好的数量是否比预期的多，如果统计好的服务实例数比预期的数量多，证明出现了<strong>新的服务注册</strong>，要替换下一次统计的期望数量值，以及重新计算接下来心跳的数量统计。心跳的数量统计方法 <code>updateRenewsPerMinThreshold()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> expectedClientRenewalIntervalSeconds = <span class="number">30</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> renewalPercentThreshold = <span class="number">0.85</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateRenewsPerMinThreshold</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfClientsSendingRenews</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            * (<span class="number">60.0</span> / serverConfig.getExpectedClientRenewalIntervalSeconds())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            * serverConfig.getRenewalPercentThreshold());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出来它的计算数是：<strong>每隔30秒发一次心跳</strong>（一分钟心跳两次），而且必须所有的服务实例的心跳总数要达到前面计算数量的85%才算整体微服务正常，其实这也就是 <strong>EurekaServer 的自我保护机制</strong>。</p>
<h5 id="5-4-1-3-initRemoteRegionRegistry：初始化远程分区注册中心"><a href="#5-4-1-3-initRemoteRegionRegistry：初始化远程分区注册中心" class="headerlink" title="5.4.1.3 initRemoteRegionRegistry：初始化远程分区注册中心"></a>5.4.1.3 initRemoteRegionRegistry：初始化远程分区注册中心</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initRemoteRegionRegistry</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Map&lt;String, String&gt; remoteRegionUrlsWithName = serverConfig.getRemoteRegionUrlsWithName();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!remoteRegionUrlsWithName.isEmpty()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        allKnownRemoteRegions = <span class="keyword">new</span> String[remoteRegionUrlsWithName.size()];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> remoteRegionArrayIndex = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; remoteRegionUrlWithName : remoteRegionUrlsWithName.entrySet()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            RemoteRegionRegistry remoteRegionRegistry = <span class="keyword">new</span> RemoteRegionRegistry(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    serverConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                    clientConfig,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                    serverCodecs,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    remoteRegionUrlWithName.getKey(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">new</span> URL(remoteRegionUrlWithName.getValue()));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            regionNameVSRemoteRegistry.put(remoteRegionUrlWithName.getKey(), remoteRegionRegistry);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            allKnownRemoteRegions[remoteRegionArrayIndex++] = remoteRegionUrlWithName.getKey();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    logger.info(<span class="string">"Finished initializing remote region registries. All known remote regions: &#123;&#125;"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            (Object) allKnownRemoteRegions);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里面提到了一个概念：<code>RemoteRegionRegistry</code> ，它的文档注释原文翻译：</p>
<blockquote>
<p>Handles all registry operations that needs to be done on a eureka service running in an other region. The primary operations include fetching registry information from remote region and fetching delta information on a periodic basis.</p>
<p>处理在其他区域中运行的eureka服务上需要完成的所有注册表操作。主要操作包括从远程区域中获取注册表信息以及定期获取增量信息。</p>
</blockquote>
<p>文档注释的解释看着似懂非懂，它没有把这个类的作用完全解释清楚。实际上这里涉及到 Eureka 的服务分区，这个咱留到后面解释 Eureka 的高级特性时再聊。</p>
<h4 id="5-4-2-PeerAwareInstanceRegistry-shutdown"><a href="#5-4-2-PeerAwareInstanceRegistry-shutdown" class="headerlink" title="5.4.2 PeerAwareInstanceRegistry#shutdown"></a>5.4.2 PeerAwareInstanceRegistry#shutdown</h4><p>当 <code>EurekaServerContext</code> 被销毁时，会回调 <code>@PreDestory</code> 标注的 <code>shutdown</code> 方法，而这个方法又调到 <code>PeerAwareInstanceRegistry</code> 的 <code>shutdown</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        DefaultMonitorRegistry.getInstance().unregister(Monitors.newObjectMonitor(<span class="keyword">this</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch .......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        peerEurekaNodes.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch .......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    numberOfReplicationsLastMin.stop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">super</span>.shutdown();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里它干的事情不算麻烦，它首先利用 <code>DefaultMonitorRegistry</code> 做了一个注销操作，<code>DefaultMonitorRegistry</code> 这个组件本身来源于 <strong>servo</strong> 包，它是做监控使用，那自然能猜出来这部分是<strong>关闭监控</strong>。接下来它会把那些微服务节点实例全部注销，停止计数器监控，最后回调父类的 <code>shutdown</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    deltaRetentionTimer.cancel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    evictionTimer.cancel();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    renewsLastMin.stop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以发现也是跟监控相关的组件停止，不再赘述。</p>
<h3 id="5-5-EurekaServerBootstrap"><a href="#5-5-EurekaServerBootstrap" class="headerlink" title="5.5 EurekaServerBootstrap"></a>5.5 EurekaServerBootstrap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaServerBootstrap <span class="title">eurekaServerBootstrap</span><span class="params">(PeerAwareInstanceRegistry registry,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        EurekaServerContext serverContext)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EurekaServerBootstrap(<span class="keyword">this</span>.applicationInfoManager,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">this</span>.eurekaClientConfig, <span class="keyword">this</span>.eurekaServerConfig, registry,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            serverContext);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个咱上面已经提过了，有了 <code>EurekaServerBootstrap</code> 才能引导启动 <code>EurekaServer</code> 。</p>
<h3 id="5-6-ServletContainer"><a href="#5-6-ServletContainer" class="headerlink" title="5.6 ServletContainer"></a>5.6 ServletContainer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">jerseyFilterRegistration</span><span class="params">(javax.ws.rs.core.Application eurekaJerseyApp)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    bean.setFilter(<span class="keyword">new</span> ServletContainer(eurekaJerseyApp));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    bean.setOrder(Ordered.LOWEST_PRECEDENCE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    bean.setUrlPatterns(Collections.singletonList(EurekaConstants.DEFAULT_PREFIX + <span class="string">"/*"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>它注册的 <code>FilterRegistrationBean</code> 我在之前的《<a href="https://juejin.im/book/5da3bc3d6fb9a04e35597a76" target="_blank" rel="noopener">SpringBoot源码解读与原理分析</a>》中有提过（第6章4.1.2节），这里咱直接说核心的 <code>Filter</code> 是 <code>ServletContainer</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.jersey.spi.container.servlet;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContainer</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> <span class="keyword">implements</span> <span class="title">Filter</span></span></span></pre></td></tr></table></figure>

<p>注意它所在的包，里面有一个很关键的词：<strong>jersey</strong> ，它是一个类似于 SpringWebMvc 的框架，由于 Eureka 本身也是一个 Servlet 应用，只是它使用的 Web 层框架不是 SpringWebMvc 而是 Jersey 而已，Jersey 在 Eureka 的远程请求、心跳包发送等环节起到至关重要的作用，后续咱会详细解释。</p>
<h3 id="5-7-Application"><a href="#5-7-Application" class="headerlink" title="5.7 Application"></a>5.7 Application</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> javax.ws.rs.core.<span class="function">Application <span class="title">jerseyApplication</span><span class="params">(Environment environment,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        ResourceLoader resourceLoader)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个类的创建咱不是很关心，瞅一眼这个类的子类，发现全部都是来自 <strong>Jersey</strong> 的：</p>
<p>![](服务发现-EurekaServer的初始化和启动原理/3. Application下面的子类全部都是jersey的.png)</p>
<p>而且上面的 <code>ServletContainer</code> 中正好也用到了这个 <code>Application</code> ，那大概也明白它是配合上面的过滤器使用，后续咱会跟上面的 <strong>Jersey</strong> 一起解释。</p>
<h3 id="5-8-HttpTraceFilter"><a href="#5-8-HttpTraceFilter" class="headerlink" title="5.8 HttpTraceFilter"></a>5.8 HttpTraceFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">traceFilterRegistration</span><span class="params">(@Qualifier(<span class="string">"httpTraceFilter"</span>)</span> Filter filter) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    bean.setFilter(filter);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    bean.setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">10</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>它注册了一个名为 <code>httpTraceFilter</code> 的过滤器，借助IDEA发现这个过滤器来自 <code>HttpTraceAutoConfiguration</code> 的内部类 <code>ServletTraceFilterConfiguration</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletTraceFilterConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> HttpTraceFilter <span class="title">httpTraceFilter</span><span class="params">(HttpTraceRepository repository, HttpExchangeTracer tracer)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpTraceFilter(repository, tracer);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个过滤器的作用也很容易猜想，<strong>trace</strong> 的概念咱从日志系统里也接触过，它打印的内容非常非常多，且涵盖了上面的几乎所有级别。这个类的文档注释也恰好印证了我们的猜想：</p>
<blockquote>
<p>Servlet Filter that logs all requests to an HttpTraceRepository.</p>
<p>记录所有请求日志的Servlet过滤器。</p>
</blockquote>
<h2 id="6-EurekaServerConfigBeanConfiguration"><a href="#6-EurekaServerConfigBeanConfiguration" class="headerlink" title="6. EurekaServerConfigBeanConfiguration"></a>6. EurekaServerConfigBeanConfiguration</h2><p><code>EurekaServerAutoConfiguration</code> 还有一个内部的配置类：<code>EurekaServerConfigBeanConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerConfigBeanConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> EurekaServerConfig <span class="title">eurekaServerConfig</span><span class="params">(EurekaClientConfig clientConfig)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        EurekaServerConfigBean server = <span class="keyword">new</span> EurekaServerConfigBean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Set a sensible default if we are supposed to replicate</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            server.setRegistrySyncRetries(<span class="number">5</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> server;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>它就是注册了默认的 EurekaServer 的配置模型，这个模型类里的配置咱上面也看到一些了，后面的部分咱还会接触它，先有一个印象即可。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><code>@EnableEurekaServer</code> 注解会激活 EurekaServer 的自动配置，核心是向IOC容器注册一个 <code>Marker</code> 的内部类。</li>
<li><code>EurekaServerInitializerConfiguration</code> 负责 EurekaServer 的初始化，初始化的过程包括本身初始化、运行环境初始化、运行上下文的初始化。</li>
<li><code>EurekaServerAutoConfiguration</code> 注册的核心组件包括展示控制台的 Controller 、微服务节点实例的模型和管理组件、<code>EurekaServerContext</code>、<code>EurekaServerBootstrap</code>（启动引导类）、两个过滤器。</li>
</ol>
</div><div class="post-copyright"><blockquote><p>原文作者: LinkedBear</p><p>原文链接: <a href="/http:/yoursite.com/2019/12/04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-EurekaServer%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/">http://yoursite.com/2019/12/04/服务发现-EurekaServer的初始化和启动原理/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/EurekaServer/">EurekaServer</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/" class="next">嵌入式容器：嵌入式Tomcat的优化和配置</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-EnableEurekaServer"><span class="toc-text">1. @EnableEurekaServer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-EurekaServerMarkerConfiguration"><span class="toc-text">2. EurekaServerMarkerConfiguration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-EurekaServerAutoConfiguration"><span class="toc-text">3. EurekaServerAutoConfiguration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-EurekaServerInitializerConfiguration"><span class="toc-text">4. EurekaServerInitializerConfiguration</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-0-eurekaServerBootstrap-contextInitialized：初始化、启动EurekaServer"><span class="toc-text">4.0 eurekaServerBootstrap.contextInitialized：初始化、启动EurekaServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-initEurekaEnvironment：初始化Eureka的运行环境"><span class="toc-text">4.1 initEurekaEnvironment：初始化Eureka的运行环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-initEurekaServerContext：初始化EurekaServer的运行上下文"><span class="toc-text">4.2 initEurekaServerContext：初始化EurekaServer的运行上下文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-EurekaServerAutoConfiguration中配置的核心组件"><span class="toc-text">5. EurekaServerAutoConfiguration中配置的核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-EurekaController"><span class="toc-text">5.1 EurekaController</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-PeerAwareInstanceRegistry"><span class="toc-text">5.2 PeerAwareInstanceRegistry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-PeerEurekaNodes"><span class="toc-text">5.3 PeerEurekaNodes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-start"><span class="toc-text">5.3.1 start</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-shutdown"><span class="toc-text">5.3.2 shutdown</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-EurekaServerContext"><span class="toc-text">5.4 EurekaServerContext</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-PeerAwareInstanceRegistry-init"><span class="toc-text">5.4.1 PeerAwareInstanceRegistry#init</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-1-numberOfReplicationsLastMin-start-：启动续订租约的频率统计器"><span class="toc-text">5.4.1.1 numberOfReplicationsLastMin.start()：启动续订租约的频率统计器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-2-scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务"><span class="toc-text">5.4.1.2 scheduleRenewalThresholdUpdateTask：开启续订租约最低阈值检查的定时任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-3-initRemoteRegionRegistry：初始化远程分区注册中心"><span class="toc-text">5.4.1.3 initRemoteRegionRegistry：初始化远程分区注册中心</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-PeerAwareInstanceRegistry-shutdown"><span class="toc-text">5.4.2 PeerAwareInstanceRegistry#shutdown</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-EurekaServerBootstrap"><span class="toc-text">5.5 EurekaServerBootstrap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-ServletContainer"><span class="toc-text">5.6 ServletContainer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-Application"><span class="toc-text">5.7 Application</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-HttpTraceFilter"><span class="toc-text">5.8 HttpTraceFilter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-EurekaServerConfigBeanConfiguration"><span class="toc-text">6. EurekaServerConfigBeanConfiguration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/04/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-EurekaServer%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/">服务发现-EurekaServer的初始化和启动原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/">嵌入式容器：嵌入式Tomcat的优化和配置</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/EurekaServer/" style="font-size: 15px;">EurekaServer</a> <a href="/tags/Tomcat-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8-SpringBoot/" style="font-size: 15px;">Tomcat, 嵌入式容器, SpringBoot</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 所有文章</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 外部链接</i></div><ul></ul><a href="https://github.com/LinkedBear" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://juejin.im/user/5d9c4a7b518825427b27645f/books?type=wrote" title="掘金小册" target="_blank">掘金小册</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">LinkedBear.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>