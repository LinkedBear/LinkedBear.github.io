<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="LinkedBear的GitHub博客"><meta name="keywords" content="LinkedBear, SpringBoot, 源码"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Spring中使用的设计模式，你都能说全吗？[下] | LinkedBear的GitHub</title><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring中使用的设计模式，你都能说全吗？[下]</h1><a id="logo" href="/.">LinkedBear的GitHub</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 所有文章</i></a><a href="/about/"><i class="fa fa-user"> 关于阿熊</i></a><a href="/juejin/"><i class="fa fa-rss"> 掘金小册</i></a><a href="/book/"><i class="fa fa-rss"> 纸质图书</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Spring中使用的设计模式，你都能说全吗？[下]</h1><div class="post-meta"><a href="/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F%5B%E4%B8%8B%5D/#comments" class="comment-count"></a><p><span class="date">Jun 13, 2020</span><span><a href="/categories/SpringFramework/" class="category">SpringFramework</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>这是 Spring 面试题系列的第二篇 【Spring 中的设计模式】 下半部分，</p>
<p>本篇只回答一个问题：</p>
<h2 id="Spring-中使用了哪些设计模式？分别都是如何实现的？"><a href="#Spring-中使用了哪些设计模式？分别都是如何实现的？" class="headerlink" title="Spring 中使用了哪些设计模式？分别都是如何实现的？"></a>Spring 中使用了哪些设计模式？分别都是如何实现的？</h2><p>回顾一下上一篇的概述，从整体上讲，SpringFramework 中使用了 11 种设计模式：</p>
<ul>
<li><strong>单例模式+原型模式</strong></li>
<li><strong>工厂模式</strong></li>
<li><strong>代理模式</strong></li>
<li><strong>策略模式</strong></li>
<li><strong>模板方法模式</strong></li>
<li><strong>观察者模式</strong></li>
<li><strong>适配器模式</strong></li>
<li><strong>装饰者模式</strong></li>
<li><strong>外观模式</strong></li>
<li><strong>委派模式</strong>（不属于GoF23）</li>
</ul>
<p>这一篇咱把下面的 6 个设计模式也详细解析一下。</p>
<blockquote>
<p>喜欢本文的小伙伴不要忘记点赞呀 ~ ~ ~ 三克油！！！</p>
</blockquote>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式，在 SpringFramework 中使用的那是相当的多啊！即便是初学 SpringFramework ，在学习到 jdbc 部分，也应该接触过一个模板方法模式的体现，就是 <code>JdbcTemplate</code> 的回调机制：（贴两个比较常见的经典方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result(query(sql, <span class="keyword">new</span> RowMapperResultSetExtractor&lt;&gt;(rowMapper)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql) <span class="keyword">throws</span> DataAccessException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> query(sql, getColumnMapRowMapper());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在调用时，只需要一句话就够了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; datas = jdbcTemplate.queryForList(<span class="string">"select * from user"</span>);</span></pre></td></tr></table></figure>

<p>小伙伴们可能会一脸懵，这么个方法就体现模板方法模式了吗？我也看不出来啊？莫慌，下面咱先回顾下原生 jdbc 的操作步骤，慢慢自然就明白了。</p>
<h4 id="原生jdbc使用步骤"><a href="#原生jdbc使用步骤" class="headerlink" title="原生jdbc使用步骤"></a>原生jdbc使用步骤</h4><p>原生的 jdbc 操作需要以下这么多步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册驱动</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">PreparedStatement statement = connection.prepareStatement(<span class="string">"select * from user"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装结果数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; datas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    data.put(<span class="string">"id"</span>, resultSet.getString(<span class="string">"id"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    data.put(<span class="string">"name"</span>, resultSet.getString(<span class="string">"name"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    datas.add(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">resultSet.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">statement.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">connection.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回/输出数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">System.out.println(datas);</span></pre></td></tr></table></figure>

<p>但是，这里面的操作有很多是重复的，所以这一段代码可以抽取为几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; encapsulate(ResultSet resultSet) <span class="keyword">throws</span> SQLException &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; datas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        data.put(<span class="string">"id"</span>, resultSet.getString(<span class="string">"id"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        data.put(<span class="string">"name"</span>, resultSet.getString(<span class="string">"name"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        datas.add(data);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> datas;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection connection, PreparedStatement statement, ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    resultSet.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    statement.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    connection.close();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如此下来，主干代码就只剩下这些了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Connection connection = getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    PreparedStatement statement = connection.prepareStatement(<span class="string">"select * from user"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装结果数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; datas = encapsulate(resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    close(connection, statement, resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回/输出数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    System.out.println(datas);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>那最后稍微调整一下，就可以成为一个通用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; query(String sql, List&lt;Object&gt; params) <span class="keyword">throws</span> Exception &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Connection connection = getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    PreparedStatement statement = connection.prepareStatement(sql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 填充占位符参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        statement.setObject(i + <span class="number">1</span>, params.get(i));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装结果数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; datas = encapsulate(resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    close(connection, statement, resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> datas;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>目前这个方法已经可以通用了，不过只能返回 Map ，如果想返回模型类对象怎么办呢？这样咱就可以扩展一个自定义结果集封装的方法，让调用者自己决定如何封装。再次改动的代码可以像如下优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql, List&lt;Object&gt; params, Function&lt;ResultSet, List&lt;T&gt;&gt; encapsulate)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Connection connection = getConnection();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 编写SQL获取预处理对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    PreparedStatement statement = connection.prepareStatement(sql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 填充占位符参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        statement.setObject(i + <span class="number">1</span>, params.get(i));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 执行SQL获取结果集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ResultSet resultSet = statement.executeQuery();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 封装结果数据（借助Function接口实现结果集封装）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    List&lt;T&gt; datas = encapsulate.apply(resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    close(connection, statement, resultSet);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> datas;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>看最后一个参数，我让方法的调用者传一个 <code>Function&lt;ResultSet, List&lt;T&gt;&gt;</code> 类型的自定义处理逻辑，这样返回的数据究竟是什么类型我也就不用管了，完全由调用者自己决定。</p>
<p>到这里，模板方法模式就得以体现了，整个查询的动作我只需要让方法调用者传 SQL 、SQL 中可能出现的参数，以及自定义的结果集封装逻辑，其余的动作都不需要方法调用者关注。</p>
<p>可是，这跟 <code>JdbcTemplate</code> 又有什么关系呢？？？</p>
<h4 id="JdbcTemplate中体现的模板方法"><a href="#JdbcTemplate中体现的模板方法" class="headerlink" title="JdbcTemplate中体现的模板方法"></a>JdbcTemplate中体现的模板方法</h4><p>我上面不是摘出来一个 <code>JdbcTemplate</code> 的方法嘛：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result(query(sql, <span class="keyword">new</span> RowMapperResultSetExtractor&lt;&gt;(rowMapper)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>咱点进去看 <code>query</code> 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// assert logger ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title">StatementCallback</span>&lt;<span class="title">T</span>&gt;, <span class="title">SqlProvider</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            ResultSet rs = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                rs = stmt.executeQuery(sql);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> rse.extractData(rs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                JdbcUtils.closeResultSet(rs);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> sql;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> execute(<span class="keyword">new</span> QueryStatementCallback());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>注意看方法参数列表的最后一个：<code>ResultSetExtractor</code> ，它是一个函数式接口，而且它只有一个方法，就是<strong>根据结果集返回泛型类型的数据</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetExtractor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="function">T <span class="title">extractData</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException, DataAccessException</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>是不是这个设计跟我上面演示的思路基本一致了？这就是 <code>JdbcTemplate</code> 中体现的模板方法模式。</p>
<p>除了这些 <code>xxxTemplate</code> 中有体现，其实在 SpringFramework 中的最底层 IOC 容器模型，<code>BeanFactory</code> 和 <code>ApplicationContext</code> ，以及 SpringWebMvc 中的 <code>HandlerMapping</code> 、<code>HandlerAdapter</code> 等等，都有很多模板方法模式的体现。下面咱也举两个例子来体会。</p>
<h4 id="ApplicationContext中体现的模板方法"><a href="#ApplicationContext中体现的模板方法" class="headerlink" title="ApplicationContext中体现的模板方法"></a>ApplicationContext中体现的模板方法</h4><p>说到 <code>ApplicationContext</code> ，最经典的方法莫过于 <code>AbstractApplicationContext</code> 中的 <code>refresh</code> ：（只截取很少的一部分）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            onRefresh();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="comment">// catch finally ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在这个方法中有一个动作是 <code>onRefresh</code> 方法，点进去发现它是一个空方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Template method which can be overridden to add context-specific refresh work.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Called on initialization of special beans, before instantiation of singletons.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * &lt;p&gt;This implementation is empty.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of errors</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refresh()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// For subclasses: do nothing by default.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>注意看文档注释的前两个单词：<strong>Template method</strong> ！！！文档注释已经告诉咱这是一个模板方法了！而且方法体中也说了，<strong>它默认不做任何事情，留给子类扩展使用。</strong>由此咱就可以了解 <code>ApplicationContext</code> 中最经典的模板方法模式设计之一了。</p>
<h4 id="HandlerMapping中体现的模板方法"><a href="#HandlerMapping中体现的模板方法" class="headerlink" title="HandlerMapping中体现的模板方法"></a>HandlerMapping中体现的模板方法</h4><p>在 <code>DispatcherServlet</code> 接收到客户端的请求，要进行实际处理时，需要先根据 uri 寻找能匹配的 <code>HandlerMapping</code> ，这一步它会委托 <code>HandlerMapping</code> 帮忙找（这里面涉及到委派了，下面会讲到），而这个寻找 <code>HandlerMapping</code> 的动作在 <code>AbstractHandlerMapping</code> 的 <code>getHandler</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Object handler = getHandlerInternal(request);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        handler = getDefaultHandler();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里面第一句就会调另一个 <code>getHandlerInternal</code> 方法，而这个方法在 <code>AbstractHandlerMapping</code> 中是自己定义的抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span></pre></td></tr></table></figure>

<p>这就是非常经典的模板方法模式的体现了：<strong>父类 / 抽象类把逻辑步骤都定义出来，具体的动作让子类实现</strong>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中体现的模板方法模式非常多，包括各种 Template （ <code>JdbcTemplate</code> 、<code>HibernateTemplate</code> 、<code>RedisTemplate</code> 等），以及核心源码内部设计的模板方法（如 <code>AbstractApplicationContext</code> 中的 <code>refresh</code> 套 <code>onRefresh</code> 、<code>AbstractHandlerMapping</code> 中的 <code>getHandler</code> 套 <code>getHandlerInternal</code> 等），它设计的核心思想是父类 / 抽象类把逻辑步骤都定义出来，具体的动作让子类实现。</strong></p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><strong>观察者模式</strong>，也被称为<strong>发布订阅模式</strong>，其实它还有一个叫法：<strong>监听器模式</strong>。那说到监听器，是不是就立马想起来 SpringFramework 中的 <strong><code>ApplicationListener</code></strong> 了？对了，就这么回事，其实都不用展开讲，小伙伴们也能答得出来了。不过，想回答的漂亮，还需要额外知道一点点东西。</p>
<h4 id="观察者模式的核心"><a href="#观察者模式的核心" class="headerlink" title="观察者模式的核心"></a>观察者模式的核心</h4><p>咱都知道，观察者模式的两大核心是：<strong>观察者、被观察主题</strong>。对应到 SpringFramework 中的概念分别是：<strong>事件、监听器</strong>。</p>
<p>不过我个人比较喜欢把 SpringFramework 的事件驱动核心概念划分为 4 个：<strong>事件源、事件、广播器、监听器</strong>。</p>
<ul>
<li><strong>事件源：发布事件的对象</strong></li>
<li><strong>事件：事件源发布的信息</strong></li>
<li><strong>广播器：事件真正广播给监听器的对象</strong>【即 <strong><code>ApplicationContext</code></strong> 】<ul>
<li><code>ApplicationContext</code> 接口有实现 <code>ApplicationEventPublisher</code> 接口，具备<strong>事件广播器的发布事件的能力</strong></li>
</ul>
</li>
<li><strong>监听器：监听事件的对象</strong></li>
</ul>
<p>在 SpringFramework 中，<strong>事件源想要发布事件，需要注入事件广播器，通过事件广播器来广播事件</strong>。</p>
<h4 id="SpringFramework使用监听器"><a href="#SpringFramework使用监听器" class="headerlink" title="SpringFramework使用监听器"></a>SpringFramework使用监听器</h4><p>以下是一个最简单的监听器使用实例：</p>
<h5 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceEvent</span><span class="params">(Object source)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">super</span>(source);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventService</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ApplicationContext ctx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        ctx.publishEvent(<span class="keyword">new</span> ServiceEvent(<span class="keyword">this</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext ctx)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ServiceEvent</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ServiceEvent event)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"监听到ServiceEvent事件："</span> + event);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中实现的观察者模式就是事件驱动机制，可以通过自定义监听器，监听不同的事件，完成不同的业务处理。</strong></p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>了解 SpringWebMvc 中 <code>DispatcherServlet</code> 的工作原理，应该对 <code>HandlerAdapter</code> 不陌生，它就是辅助执行 Controller 中具体方法的<strong>适配器</strong>。如果只答这一句当然够用，不过回答的再细致点，那自然是更好的。</p>
<h4 id="DispatcherServlet委派HandlerAdapter"><a href="#DispatcherServlet委派HandlerAdapter" class="headerlink" title="DispatcherServlet委派HandlerAdapter"></a>DispatcherServlet委派HandlerAdapter</h4><p>在 <code>DispatcherServlet</code> 的 <code>doDispatch</code> 方法中，有一句代码是根据 <code>HandlerMapping</code> 中的 <code>Handler</code> 获取 <code>HandlerAdapter</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span></pre></td></tr></table></figure>

<p>这个 <strong>Handler</strong> 就是<strong>目标 Controller 中的目标方法</strong>，在适配的过程中它会寻找现有的所有 <code>HandlerAdapter</code> 是否能支持执行这个 Handler ，根据 <code>RequestMappingHandlerMapping</code> 的命名，自然也能猜得出来，真正负责执行目标 Controller 中方法的是 <strong><code>RequestMappingHandlerAdapter</code></strong> 。</p>
<h4 id="HandlerAdapter执行Handler"><a href="#HandlerAdapter执行Handler" class="headerlink" title="HandlerAdapter执行Handler"></a>HandlerAdapter执行Handler</h4><p>在 <code>RequestMappingHandlerAdapter</code> 中，执行目标 Controller 中方法的核心方法是 <code>handle</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>看到了 <code>handleInternal</code> ，是不是又想到了<strong>模板方法</strong>？没错，就是这个设计。</p>
<p>在底层，核心的执行 Handler 的逻辑其实就是<strong>反射</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ReflectionUtils.makeAccessible(getBridgedMethod());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// method.invoke</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>由此可知，<code>HandlerAdapter</code> 的执行其实也没有很神秘，最终还是玩的反射而已。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中的适配器模式，体现之一是 <code>HandlerAdapter</code> 辅助执行目标 Controller 中的方法，底层是借助反射执行。</strong></p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰者跟代理、适配器都有些相似，不过<strong>装饰者</strong>更强调的是<strong>在原有的基础上附加额外的动作 / 方法 / 特性</strong>，而<strong>代理模式</strong>有<strong>控制内部对象访问</strong>的意思。</p>
<p>SpringFramework 中体现的装饰者模式，在核心源码中并没有体现，不过在缓存模块 spring-cache 中倒是有一个体现：<strong><code>TransactionAwareCacheDecorator</code></strong> 。</p>
<h4 id="Bean的包装"><a href="#Bean的包装" class="headerlink" title="Bean的包装"></a>Bean的包装</h4><p>了解过 Bean 的创建流程，应该知道最底层的创建动作发生在 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>doCreateBean</code>  中，而这里面第一波动作就把 <code>BeanWrapper</code> 都创建好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Instantiate the bean.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>注意看，它创建的动作是 <code>createBeanInstance</code> ，意为“创建 bean 实例”，那就可以理解为：<strong>bean 对象已经在这个动作下实例化好了</strong>。深入这个方法，最终可以在 <code>createBeanInstance</code> 方法的最后一句 return 中看到 bean 实例的创建，以及 <code>BeanWrapper</code> 的包装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        Object beanInstance;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 实例化对象......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        initBeanWrapper(bw);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> bw;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="comment">// catch ......</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>看到下面的代码中，它把 bean 的实例对象包装为一个 <code>BeanWrapper</code> ，形成装饰者。</p>
<h4 id="SpringCache的核心设计"><a href="#SpringCache的核心设计" class="headerlink" title="SpringCache的核心设计"></a>SpringCache的核心设计</h4><p>SpringCache 主做的是应用业务层级的缓存，它与 JSR107 有一定关系但又不同（Spring 自己实现了一套缓存，就是这个 SpringCache ）。</p>
<p>用一张简单的图解释 SpringCache 的核心，大概可以这样理解：</p>
<p><img src="/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8B]/1592051318911.png" alt></p>
<p>一个 <code>CacheManager</code> 中包含多个 <code>Cache</code> ，一个 <code>Cache</code> 可以简单理解为一个 <strong>Map&lt;String, T&gt;</strong> 。</p>
<p>从 <code>Cache</code> 接口的设计，也能看出来就是 <strong><code>Map</code></strong> 的思路：（核心方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">ValueWrapper <span class="title">get</span><span class="params">(Object key)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Object key, @Nullable Object value)</span></span>;</span></pre></td></tr></table></figure>

<h4 id="Cache的装饰者体现"><a href="#Cache的装饰者体现" class="headerlink" title="Cache的装饰者体现"></a>Cache的装饰者体现</h4><p><code>TransactionAwareCacheDecorator</code> 作为装饰者，那肯定要实现 Cache 接口，并且组合一个 Cache 的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAwareCacheDecorator</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Cache targetCache;</span></pre></td></tr></table></figure>

<p>这里面，真正体现装饰者的位置是在 <code>put</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">final</span> Object key, @Nullable <span class="keyword">final</span> Object value)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                TransactionAwareCacheDecorator.<span class="keyword">this</span>.targetCache.put(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.targetCache.put(key, value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以发现，它会在 <strong>put 之前，检查当前线程中是否存在已经开启的事务</strong>：如果存在事务，则会将 put 操作注册到<strong>事务结束后</strong>。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p><strong>SpringFramework 中实现的装饰者模式，体现之一是在 SpringCache 缓存的存放逻辑中，如果执行缓存时的线程中存在事务，则缓存的保存会在事务结束后再执行。</strong></p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式算是比较简单的模式，它强调的是<strong>统一入口，内部组合</strong>。一个经典的体现是在 IOC 解析 Bean 的定义信息时使用的 <code>BeanDefinitionLoader</code> 。</p>
<p>在 <code>BeanDefinitionLoader</code> 中，它组合了 4 种不同类型的解析器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionLoader</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 注解式Bean定义解析器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader annotatedReader;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// xml文件的Bean定义解析器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader xmlReader;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Groovy的Bean定义解析器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> BeanDefinitionReader groovyReader;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 类路径的Bean定义扫描器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span></pre></td></tr></table></figure>

<p>尽管组合的解析器很多，但最终暴露出来的方法是同样的名：<code>load</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Class&lt;?&gt; source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(GroovyBeanDefinitionSource source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Resource source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Package source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(CharSequence source)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span></pre></td></tr></table></figure>

<p>由此可以体现出很经典的外观模式。</p>
<h3 id="委派模式"><a href="#委派模式" class="headerlink" title="委派模式"></a>委派模式</h3><p>委派模式本不属于 GoF23 中的设计模式，不过既然咱在前面也反复提到过几次，这里咱还是摘出来说两句。</p>
<p>在 <code>DispatcherServlet</code> 的核心工作流程中，委派模式体现在 <code>HandlerMapping</code> 、<code>HandlerAdapter</code> 、<code>ViewResolver</code> 接受 <code>DispatcherServlet</code> 的委派，如下面的整体流程图：</p>
<p><img src="/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F[%E4%B8%8B]/DispatcherServlet%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt></p>
<p>到这里，SpringFramework 中使用的设计模式就差不多整理完了，想要回答的尽可能全面、准确、有深度，小伙伴们要好好理解这些模式的设计、思想，以及 SpringFramework 中的源码实现，这样在被面试官问到才会更加游刃有余。</p>
<p>【都看到这里了，小伙伴们要不要关注点赞一下呀，有源码学习需要的可以看我小册哦，学习起来 ~ 奥利给】</p>
</div><div class="post-copyright"><blockquote><p>原文作者: LinkedBear</p><p>原文链接: <a href="/http:/yoursite.com/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F%5B%E4%B8%8B%5D/">http://yoursite.com/2020/06/13/Spring中使用的设计模式，你都能说全吗？[下]/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Spring/">Spring</a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/" class="pre">【不懂就问】SpringFramework中的注解声明式事务怎么被Shiro搞失效了</a><a href="/2020/06/09/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F%5B%E4%B8%8A%5D/" class="next">Spring中使用的设计模式，你都能说全吗？[上]</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-中使用了哪些设计模式？分别都是如何实现的？"><span class="toc-text">Spring 中使用了哪些设计模式？分别都是如何实现的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#模板方法模式"><span class="toc-text">模板方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原生jdbc使用步骤"><span class="toc-text">原生jdbc使用步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JdbcTemplate中体现的模板方法"><span class="toc-text">JdbcTemplate中体现的模板方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationContext中体现的模板方法"><span class="toc-text">ApplicationContext中体现的模板方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HandlerMapping中体现的模板方法"><span class="toc-text">HandlerMapping中体现的模板方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#观察者模式"><span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#观察者模式的核心"><span class="toc-text">观察者模式的核心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringFramework使用监听器"><span class="toc-text">SpringFramework使用监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#事件模型"><span class="toc-text">事件模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事件源"><span class="toc-text">事件源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#监听器"><span class="toc-text">监听器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适配器模式"><span class="toc-text">适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DispatcherServlet委派HandlerAdapter"><span class="toc-text">DispatcherServlet委派HandlerAdapter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HandlerAdapter执行Handler"><span class="toc-text">HandlerAdapter执行Handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结-2"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装饰者模式"><span class="toc-text">装饰者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean的包装"><span class="toc-text">Bean的包装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringCache的核心设计"><span class="toc-text">SpringCache的核心设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache的装饰者体现"><span class="toc-text">Cache的装饰者体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结-3"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#外观模式"><span class="toc-text">外观模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#委派模式"><span class="toc-text">委派模式</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/15/2021.05.15%20%20%E9%97%B2%E8%81%8A/">2021.05.15  闲聊</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/08/Spring%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%9F/">Spring如何在运行期动态注册新的数据源？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/01/2020%E6%8E%98%E9%87%91%E5%B9%B4%E5%BA%A6%E5%BE%81%E6%96%87/">艰难又收获满满的2020</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/18/%E8%AE%B0%E3%80%90%E5%9C%A8%E6%8E%98%E9%87%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B4%E6%92%AD%E3%80%91/">记【在掘金的第一次直播】</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/28/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91MyBatis%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AB%9F%E7%84%B6%E8%BF%98%E4%BC%9A%E5%BC%95%E6%9D%A5%E9%BA%BB%E7%83%A6%EF%BC%9F/">【不懂就问】MyBatis的一级缓存竟然还会引来麻烦？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/%E3%80%90%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE%E3%80%91SpringFramework%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E8%A2%ABShiro%E6%90%9E%E5%A4%B1%E6%95%88%E4%BA%86/">【不懂就问】SpringFramework中的注解声明式事务怎么被Shiro搞失效了</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F%5B%E4%B8%8B%5D/">Spring中使用的设计模式，你都能说全吗？[下]</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/09/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BD%A0%E9%83%BD%E8%83%BD%E8%AF%B4%E5%85%A8%E5%90%97%EF%BC%9F%5B%E4%B8%8A%5D/">Spring中使用的设计模式，你都能说全吗？[上]</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/18/Spring%E7%9A%84IOC%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E8%83%BD%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9A%E5%90%97%EF%BC%9F/">Spring的IOC，你真的能解释清楚吗？</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%9A%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%85%8D%E7%BD%AE/">嵌入式容器：嵌入式Tomcat的优化和配置</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringFramework/">SpringFramework</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8D%E6%87%82%E5%B0%B1%E9%97%AE/">不懂就问</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%98%E9%87%91%E6%97%A5%E8%AE%B0/">掘金日记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%97%B2%E8%81%8A%E6%9D%82%E8%AE%B0/">闲聊杂记</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 15px;">声明式事务</a> <a href="/tags/2020/" style="font-size: 15px;">2020</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/IOC/" style="font-size: 15px;">IOC</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98/" style="font-size: 15px;">一级缓存</a> <a href="/tags/%E6%9D%82%E8%AE%B0/" style="font-size: 15px;">杂记</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8/" style="font-size: 15px;">嵌入式容器</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/Shiro/" style="font-size: 15px;">Shiro</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 所有文章</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 外部链接</i></div><ul></ul><a href="https://github.com/LinkedBear" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://juejin.cn/user/3808363977640301/books?type=wrote" title="掘金小册" target="_blank">掘金小册</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">LinkedBear.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>